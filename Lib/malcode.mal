; -*- scheme -*-
;
; $Id: malcode.mal,v 1.2 1997/02/03 20:07:13 lth Exp $
;
; malcode.mal -- all MacScheme assembly language to support Larceny.
;
; June 27, 1995 / lth
;   Created (by merging some older files).
;
; January 17, 1996 / lth
;   Added sys$continuation-data-structure

; @raw-apply@
;
; The raw apply procedure has to be written in mal
; (MacScheme assembly language) because the compiler
; never emits an apply instruction.

`((,$lambda ((,$.proc)
             (,$args= 3)
             (,$reg 1)
             (,$apply 2 3)
             (,$.label 1001)
             (,$branch 1001))  ; just a precaution
            0
            (#t))
  (,$setglbl @raw-apply@)
  (,$const @raw-apply@)
  (,$return))


; call-with-current-continuation
;
; Call-with-current-continuation has to be written in mal to 
; make sure that the compiler does not mess with the stack frames;
; the creg/creg-set! primitives need predictable stack behavior.

`((,$lambda ((,$.proc)
	     (,$args=   1)
	     (,$op1     creg)
	     (,$setreg  2)
	     (,$lambda  ((,$.proc)
			 (,$lexical 0 2)
			 (,$op1     creg-set!)
			 (,$reg     1)
			 (,$return))
			2
			(#t))
	     (,$setreg  3)
	     (,$reg     1)
	     (,$movereg 3 1)
	     (,$invoke  1))
	    0
	    (#t))
  (,$setglbl call-with-current-continuation)
  (,$const   call-with-current-continuation)
  (,$return))


; sys$continuation-data-structure
;
; This procedure knows about the layout of the procedure created by
; call-with-current-continuation (above), and given such a procedure
; it returns the actual continuation structure stored in the environment
; of that procedure.  There is currently no way to distinguish a 
; continuation procedure from another procedure (we could do this by
; embedding a magic cookie in the procedure at a known spot) so
; use with extreme care.
;
; This procedure does not need to be written in MAL but it's easier
; to keep it in sync that way.

`((,$lambda ((,$.proc)
	     (,$args=   1)
	     (,$const   4)  ; Lexical slot 2 is procedure slot 4.
	     (,$setreg  2)
	     (,$reg     1)
	     (,$op2     procedure-ref 2)
	     (,$return))
	    0
	    (#t))
  (,$setglbl sys$continuation-data-structure)
  (,$const   sys$continuation-data-structure)
  (,$return))


; syscall
;
; Syscall is written in mal because the arguments are passed in a
; non-standard way and because the compiler cannot handle a primitive
; with a variable, large, number of parameters. Syscall is simply a
; trampoline into a millicode procedure. RESULT has the number of 
; arguments, and the arguments are passed in registers as usual.

`((,$lambda ((,$.proc)
	     (,$op1 syscall)
	     (,$return))
	    0
	    (#t))
  (,$setglbl syscall)
  (,$const   syscall)
  (,$return))


; eof
