; Copyright Lightship Software, Incorporated.
;
; $Id$
;
; MAL code that supports Larceny's standard libraries

; @raw-apply@
;
; The raw apply procedure has to be written in mal
; (MacScheme assembly language) because the compiler
; never emits an apply instruction.

`((,$lambda ((,$.proc)
             (,$args= 3)
             (,$reg 1)
             (,$apply 2 3)
             (,$.label 1001)
             (,$branch 1001))  ; just a precaution
            0
            #f)
  (,$setglbl @raw-apply@)
  (,$const @raw-apply@)
  (,$return))


; call-with-current-continuation
;
; Call-with-current-continuation has to be written in mal to 
; make sure that the compiler does not mess with the stack frames;
; the creg/creg-set! primitives need predictable stack behavior.

`((,$lambda ((,$.proc)
	     (,$args=   1)
	     (,$op1     creg)
	     (,$setreg  2)
	     (,$lambda  ((,$.proc)
			 (,$args=   1)
			 (,$lexical 0 2)
			 (,$op1     creg-set!)
			 (,$reg     1)
			 (,$return))
			2
			#f)
	     (,$setreg  3)
	     (,$reg     1)
	     (,$movereg 3 1)
	     (,$invoke  1))
	    0
	    #f)
  (,$setglbl call-with-current-continuation)
  (,$const   call-with-current-continuation)
  (,$return))


; sys$continuation-data-structure  (Obsolete?)
;
; This procedure knows about the layout of the procedure created by
; call-with-current-continuation (above), and given such a procedure
; it returns the actual continuation structure stored in the environment
; of that procedure.  There is currently no way to distinguish a 
; continuation procedure from another procedure (we could do this by
; embedding a magic cookie in the procedure at a known spot) so
; use with extreme care.
;
; This procedure does not need to be written in MAL but it's easier
; to keep it in sync that way.

`((,$lambda ((,$.proc)
	     (,$args=   1)
	     (,$const   4)  ; Lexical slot 2 is procedure slot 4.
	     (,$setreg  2)
	     (,$reg     1)
	     (,$op2     procedure-ref 2)
	     (,$return))
	    0
	    #f)
  (,$setglbl sys$continuation-data-structure)
  (,$const   sys$continuation-data-structure)
  (,$return))


; syscall
;
; Syscall has to be coded in mal because the arguments are passed in a
; non-standard way and because the compiler cannot handle a primitive
; with a variable, large, number of parameters.  Syscall is simply a
; trampoline into a millicode procedure.  RESULT has the number of 
; arguments, and the arguments are passed in registers as usual.

`((,$lambda ((,$.proc)
	     (,$op1 syscall)
	     (,$return))
	    0
	    #f)
  (,$setglbl syscall)
  (,$const   syscall)
  (,$return))


; read-char
;
; read-char has been coded in MAL for performance -- it avoids consing
; up the varargs list.  We should keep this version even if the compiler
; is taught about read-char, because the interpreter will still call
; this version.
;
; The original is in Lib/stdio.h; make sure to reflect changes there.
; RESULT has the number of arguments.
;
; Incidentally, this is mostly how we'd generate code for case-lambda,
; and case-lambda is a better solution than MAL :-)

`((,$lambda ((,$setreg 2)
	     (,$reg 2)
	     (,$op2imm eq? 1)
	     (,$branchf 1001)
	     (,$global io/read-char)	; One argument: pass it on.
	     (,$invoke 1)
	     (,$.label 1001)
	     (,$reg 2)
	     (,$op2imm eq? 0)
	     (,$branchf 1002)
	     (,$save 0)			; Zero arguments: get the port
	     (,$store 0 0)
	     (,$global current-input-port)
	     (,$setrtn 1003)
	     (,$invoke 0)
	     (,$.align 4)
	     (,$.label 1003)
	     (,$.cont)
	     (,$load 0 0)
	     (,$setreg 1)
	     (,$pop 0)
	     (,$global io/read-char)
	     (,$invoke 1)
	     (,$.label 1002)		; Other cases: an error.
	     (,$const "read-char: Too many arguments.")
	     (,$setreg 1)
	     (,$global error)
	     (,$invoke 1))
	    0
	    #f)
  (,$setglbl read-char)
  (,$const read-char)
  (,$return))

; write-char
;
; write-char has been coded in MAL for performance; see comments for
; read-char, above.

`((,$lambda ((,$setreg 3)
	     (,$reg 3)
	     (,$op2imm eq? 2)
	     (,$branchf 1001)
	     (,$global io/write-char)	; Two arguments: pass them on
	     (,$invoke 2)
	     (,$.label 1001)
	     (,$reg 3)
	     (,$op2imm eq? 1)
	     (,$branchf 1002)
	     (,$save 1)			; One argument: get the port
	     (,$store 0 0)
	     (,$store 1 1)
	     (,$global current-output-port)
	     (,$setrtn 1003)
	     (,$invoke 0)
	     (,$.align 4)
	     (,$.label 1003)
	     (,$.cont)
	     (,$load 0 0)
	     (,$load 1 1)
	     (,$setreg 2)
	     (,$pop 1)
	     (,$global io/write-char)
	     (,$invoke 2)
	     (,$.label 1002)		; Other cases: an error.
	     (,$const "write-char: wrong number of arguments.")
	     (,$setreg 1)
	     (,$global error)
	     (,$invoke 1))
	    0
	    #f)
  (,$setglbl write-char)
  (,$const write-char)
  (,$return))

; eof
