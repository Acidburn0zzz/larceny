% -*- TeX -*-
% $Id: 8:gc.tex,v 1.2 1992/05/08 18:42:40 lth Exp $

\input{larceny.sty}
\title{Larceny Note \#8: \\
       Garbage Collector Interface Definition}
\author{Lars Thomas Hansen}

\begin{document}
\maketitle

\begin{abstract}
This document describes the conventions that must be followed by an
application using the garbage collector (henceforth called "the mutator").
There are specifications for collector initialization, space allocation, and
invariants that must be upheld by the mutator. 
\end{abstract}


\section{General Conventions}

All global variables defined by the collector are kept in the "globals"
table. They must have their correct values when the "collect()" procedure is
called.  However, the mutator may keep these variables in registers between
calls to the collector.  The ``globals'' table is an array of the data type
``word''; the ``word'' data type is defined in the file ``Sys/gcinterface.h''.
The collector does not define ``globals''.

\section{The Collector's World View}

There are four areas of memory, called the Static, Ephemeral, Tenured, and
Stack areas. There is also a set of Root Pointers.

\begin{itemize}
\item
The Static area has no out-pointers and will not be used for roots during a
collection, nor will pointers into the Static area be traversed during a
collection. The collector initialization routine allocates this area as
requested but never references it.

\item
The Ephemeral area is used for data structure creation; all memory 
allocation is performed in the ephemeral area.

\item
The Tenured area is used for keeping data structures that are assumed to
have an extended life. No memory is ever allocated directly in the Tenured
area; data structures are created here only when they are moved from the
Ephemeral area. The Tenured area also holds the ``transaction list'', which
is a set of pointers to data structures in the Tenured area which might have
pointers to data structures in the Ephemeral area. Or: if there is a data
structure in the tenured area which references a data structure in the
ephemeral area, then there must be a pointer in the transaction list to the
tenured-area data structure.

\item
The Stack area has no in-pointers and is used only by the mutator; the
collector allocates this area as requested but never references it. If there
are out pointers from the Stack area into the Tenured or Ephemeral areas,
these pointers must also exist in data structures in those areas or in the
root pointer set.

\item
The root pointers are those elements of the globals table between the indices
{\sc first\_root} and {\sc last\_root}, both of which are constants
which must be defined in the file ``Sys/offsets.h''.

\end{itemize}


\section{Basic Procedural Interface}

The garbage collector has two levels of interface, corresponding to the
two files its source code lives in. Although this document does not
describe the internal workings of the garbage collector, an brief overview
is in order.

\subsection{Low-level interface}

The file ``Sys/gc.c'' implements the basic initialization and allocation
procedures, and exports the following interface:

\begin{verbatim}
    int init_collector( int static, int tenured, int ephem, int stack );
    int gc_trap( int type );
    int collect( int type );
\end{verbatim}

{\tt Init\_collector()} initializes the memory areas; the parameters are the
requested sizes (in bytes) of each area. For those areas with an oldspace
and a newspace, the size is for one of the spaces, not for both. It returns
a success code: 0 for failure and non-0 for success.  Upon initialization,
the collector will honor the given sizes insofar as they do not violate the
constraints set forth in the header file "Sys/gc.h".  The collector will
attempt to change unreasonable values into reasonable ones.

{\tt Gc\_trap()} can be called in case an overflow of a memory area was
detected outside of the garbage collector.

{\tt Collect()} simply performs the requested collection, although sometimes
a heavier collection will be invoked if this appears to be necessary to
prevent memory overflow. Beyond such a change, however, {\tt collect()} does
not perform any policy decisions about what to collect. {\tt Collect()}
returns the type of collection actually performed.

The {\tt type} parameter for {\tt collect()} is one of {\tt
TENURING\_COLLECTION}, {\tt FULL\_COLLECTION}, and {\tt
EPHEMERAL\_COLLECTION}.

The {\tt type} parameter for {\tt gc\_trap()} is one of {\tt
EPHEMERAL\_TRAP}, {\tt TENURED\_TRAP}, and {\tt FULL\_TRAP}.

\subsection{High-level Interface}

The file ``Sys/memsupport.c'' provides a higher level of interface to the
memory management system, and all policy decisions are implemented on
this level. The interface is:

\begin{minipage}{\linewidth}
\begin{verbatim}
    int  init_mem( int ephem, int tenured, int static, int stack, int elimit );
    word gcstart2( int code );
    int  load_heap( FILE *fp, int which_heap );
    int  dump_heap( FILE *fp );
    void restore_frame( void );
    void flush_stack_cache( void );
\end{verbatim}
\end{minipage}

{\tt Init\_mem()} takes arguments like {\tt init\_collector()} did (the
difference in the ordering of the parameters is completely gratuitous) and
in addition a parameter {\tt elimit} which is a byte offset from the bottom
of the ephemeral area. This offset functions as the watermark in the
ephemeral area; when, after an ephemeral collection, there is enough live
data in the ephemeral area to fill it past the watermark, then the next
collection should tenure the entire area.

{\tt Gcstart2()} is the high-level interface to {\tt collect()}. The {\tt
code} parameter is a fixnum indicating the kind of collection to perform and
more: if {\tt code} is {\tt fixnum( -1 )}, then a tenuring collection is to
be performed. If {\tt code} is {\tt fixnum( -2 )}, then a full collection is
to be performed. Otherwise, {\tt code} has to be positive and will indicate
the number of words which will be attempted allocated when the collector
returns to the caller; this also implies that an ephemeral collection should
be performed. {\tt Gcstart2()} allocates the requested memory and returns
an untagged pointer to it.

{\tt Load\_heap()} and {\tt dump\_heap()} do exactly that. Details are
forthcoming.

{\tt Restore\_frame()} restores a stack frame from the heap into the bottom
of the stack cache. The heap frame is the one pointed to by the continuation
pointer at {\tt globals[ CONTINUATION\_OFFSET ]}.

{\tt Flush\_stack\_cache()} flushes the stack cache to the heap and installs
a pointer to the top frame in {\tt globals[ CONTINUATION\_OFFSET ]}; the
old value of this global is the {\tt next} link of the (previously) bottom 
frame of the stack cache.


\section{Globals}

The basic collector defines the following variables in the ``globals'' table
(the names used are the symbolic names of the offsets into the table, as
defined in the file ``Sys/offsets.h''):

\begin{description}

\item {\sc e\_base\_offset}

A pointer pointing to the first word of the current Ephemeral space.

\item {\sc e\_top\_offset}

A pointer pointing to the first unallocated word of the
current Ephemeral space.

\item {\sc e\_max\_offset}

A pointer to the last word of the current Ephemeral space.

\item {\sc e\_limit\_offset}

A pointer to the last usable word of the current Ephemeral area; the area
between e\_limit and e\_max is designated as a stack spill buffer area and
must be big enough to spill an entire stack cache into.

\item {\sc e\_mark\_offset}

A byte offset from the bottom of the Ephemeral area. If, after a collection
of the ephemeral area, the data in the Ephemeral area goes past this mark,
then the next collection will be a tenuring collection. The mutator may
change the value of this variable at will.

\item {\sc e\_new\_base\_offset, e\_new\_max\_offset }

Ditto for the ephemeral newspace. The mutator should *never* use these values.

\item {\sc t\_base\_offset}

A pointer to the first word of the current Tenured space.

\item {\sc t\_top\_offset}

A pointer to the first unallocated word of the current Tenured space.

\item {\sc t\_trans\_offset}

A pointer to the last word of the current Tenured space
before the transaction area; the transactions are allocated
towards low memory.

\item {\sc t\_max\_offset}

A pointer to the last word of the current Tenured area.
The words between {\sc t\_max\_offset} (inclusive) and 
{\sc t\_trans\_offset} (exclusive) make up the transaction list.

\item {\sc t\_new\_base\_offset, t\_new\_max\_offset}

Ditto for the tenured newspace.

\item {\sc s\_base\_offset}

A pointer to the first word of the Static space.

\item {\sc s\_max\_offset}

A pointer to the last word of the Static space.

\item {\sc stk\_base\_offset}

A pointer to the first (lowest-addressed) word of the Stack space.

\item {\sc stk\_max\_offset}

A pointer to the last word of the Stack space.

\item {\sc stk\_limit\_offset}

A pointer to the lowest-addressed usable word of the stack cache. The area
between stk\_limit and stk\_base is designated as a register spill area; it
is used to hold any extra stack frames which must be created before a
stack flush can be performed.

\item {\sc sp\_offset}

The stack pointer.

\item {\sc stk\_start\_offset}

A pointer to the highest-addressed usable word of the stack cache. The area
between stk\_max and stk\_start contains a dummy stack frame which, when
returned through, will restore a real stack frame to the stack cache.

\item {\sc continuation\_offset}

Contains a pointer to the chain of dynamic frames in the heap, or is
\verb+#f+, if there are none.

\item {\sc memstats\_vector\_offset}

Contains a pointer to a global variable cell in the Scheme heap which in
turn may contain a vector pointer to a vector which holds memory management
statistics. If the vector has not been installed yet, then the value field
of the globals cell has the value \verb+#!unspecified+.

\item {\sc must\_tenure\_offset}

Is 1 if the next ephemeral collection must be a tenuring one; or 0 otherwise.

\end{description}

The mutator may only change {\sc t\_trans\_offset}, {\sc e\_mark\_offset},
and {\sc e\_top\_offset}; all other values are to be considered read-only to
the mutator. All Tenured and Ephemeral pointers are subject to change after
a collection.

All pointers into all spaces are comparable. The Ephemeral area pointers
always compare less than the Tenured area pointers. The relations of and to
the other areas is implementation-defined, and may indeed change at run-time.

\section{Memory Allocation}

Recall from the above discussion that there is room between {\sc
e\_limit\_offset} and {\sc e\_max\_offset} to spill the stack in.

To allocate 'n' words from the ephemeral area, the procedure would be this:

\begin{minipage}{\linewidth}
\begin{verbatim}
   word *alloc( int n )
   {
     word *p;

     p = globals[ E_TOP_OFFSET ];

     /* Allocate the requested memory; round number of words to even */
     globals[ E_TOP_OFFSET ] += n + (n & 0x01);

     /* Check for ephemeral area overflow */
     if (globals[ E_TOP_OFFSET ] >= globals[ E_LIMIT_OFFSET ]) {
	globals[ E_TOP_OFFSET ] = globals[ E_LIMIT_OFFSET ];
         p = gcstart2( n );
     }
     return p;
   }
\end{verbatim}
\end{minipage}

The first two statements allocate memory (notice that we must allocate an
even number of words always, even if an odd number was requested).  If the
allocation moves {\sc e\_top\_offset} beyond {\sc e\_limit\_offset}, the
collector is invoked (notice that we must still adjust the TOP pointer to be
valid).  Otherwise, a pointer to the structure is returned.


\section{The Transaction List}

Memory for the ``transaction list'' -- the list of pointers to data
structures in the Tenured space which contain pointers into the Ephemeral
space -- is allocated in the Tenured area.

Whenever the mutator side-effects a data structure in the tenured area
(using ``set-car!'', ``set-cdr!'', ``vector-set!'', or similar procedured)
with a value that is a tagged pointer into the Ephemeral area, then a
transaction should be added to the transaction list. The transaction should
be a tagged pointer not to the new object but to the header of the data
structure in the Tenured area that was changed.

The value stored into the Tenured-area data structure does not strictly
speaking have to be a pointer into the Ephemeral area, but it is necessary
to store a transaction on the transaction list when the stored value is
such a pointer.  The collector deals with entries on the transaction list
which are not pointers into the tenured area in a reasonable way.

To allocate a transaction on the tranaction list, put the transaction in the
location pointed to by the pointer {\sc t\_trans\_offset}, and then
decrement this pointer. Then change the value in the data structure in the
Tenured space.  Entries are allocated from the top of the tenured area with
the initial value of {\sc t\_trans\_offset} being {\tt t\_max\_offset}.

If, before allocating space for the entry, {\sc t\_trans\_offset} is
less than {\sc t\_top\_offset}, then the tenured area has overflowed,
and must be collected. The mutator must check this.

We provide some example code for 'set-car!':

\begin{minipage}{\linewidth}
\begin{verbatim}
   void set_car( word objp, word val )
   {
     /* Check if we're storing into a Tenured object */
     if (ptrof( objp ) >= globals[ T_BASE_OFFSET ]) {
       if (globals[ T_TRANS_OFFSET ] < globals[ T_TOP_OFFSET ]) {
         /* at this point do a tenuring collection */
       }
       else
         *globals[ T_TRANS_OFFSET ]-- = objp;
     }
     *ptrof( objp ) = val;
   }
\end{verbatim}
\end{minipage}


\section{Calling the Garbage Collector}

The garbage collector traces all objects reachable from the set of root
objects, as outlined in section 3.  It is the duty of the storage allocating
procedures (like 'alloc()' above) to store all root objects in the 'globals'
table before the collector is invoked. In the case of 'alloc()' it calls the
procedure 'gcstart2()', which could look something like this:

\begin{minipage}{\linewidth}
\begin{verbatim}
   gc( int n )
   {
     word *p;

     globals[ REGO_OFFSET ] = REG0;
     globals[ REG1_OFFSET ] = REG1;
       :
     globals[ REGn_OFFSET ] = REGn;

     flush_stack_cache();
     flush_instruction_cache();

     collect( EPHEMERAL_COLLECTION );

     REG0 = globals[ REG0_OFFSET ];
     REG1 = globals[ REG1_OFFSET ];
       :
     REGn = globals[ REGn_OFFSET ];

     calculate_e_limit();

     p = globals[ E_TOP_OFFSET ];
     globals[ E_TOP_OFFSET ] += n + (n & 0x01);
     if (globals[ E_TOP_OFFSET ] >= globals[ E_LIMIT_OFFSET ]) {
       /* at this point either do major GC or just give up. */
     }
     return p;
   }
\end{verbatim}
\end{minipage}

This code assumes that we have two stacks: one for Scheme, and one for C.

First all rootable registers (\reg{reg0} through \reg{regn}) are
stored.  There might be other registers as well, depending on the
implementation.

Then the stack cache is flushed. This code is not shown here, as it depends
on the details of the stack layout, which in turn is irrelevant in the
context of this document.

Flushing the instruction cache is a system-dependent procedure; some
systems will not need it. A selective flush is probably best; I think (but
haven't decided yet) that it is always best to selectively flush oldspace,
which is why the icache flush comes before the collection. It is probably
equivalent to flush newspace (after the collection); and don't forget that
we must flush the icache after an interactive compile-and-load.

The collector is then called. The entry point of the collector is the
'collect()' procedure; the constants {\sc ephemeral\_collection},
{\sc tenuring\_collection}, and {\sc full\_collection} are defined in the file
``gcinterface.h''

Finally, when the collector has finished, each element of the
``globals'' array is copied out to where they came from (they may all
have changed).  A new {\sc e\_limit\_offset} is computed, and space is
allocated. (If we fail again, there is one more hope: to do a tenuring
collection. The code for this has not been shown.)


\section{Memory statistics}

The garbage collector keeps track of how much space is allocated and
collected from the heap. These statistics are available in the vector 
pointed to by the global {\sc memstats\_vector\_offset}. The values of
that vector are not described here.

\section{Requirements}

The garbage collector requires the availability of the following 
procedures:
\begin{description}
\item {\tt malloc()}

Standard C library memory allocation procedure

\item {\tt panic()}

Must be provided by the mutator. It takes one argument (a string), and
displays this string before terminating the program. Panic() will be
called in the case of an unrecoverable error, and should not return to
its caller.
\end{description}
It also requires the following variable:
\begin{verbatim}
   extern word globals[]
\end{verbatim}
which is the ``globals'' table that has been mentioned above.
The procedures and the variable should all be declared in ``Sys/gc.h''.

Furthermore, ``Sys/offsets.h'' must define all the offsets into the 
``globals'' table.


\section{Setting the Limits}

The file ``Sys/gc.h'' contains a number of \#definitions of limits on the
various memory areas. The collector uses these definitions as sanity checks
on the arguments to init\_collector(). The utility of this facility is to
remove the chore of sanity checking from the mutator.  However, the
programmer needs to come up with values to use. The comments in the header
file should adequately explain the restrictions.


\section{Notes}

The initialization routine will eventually take an additional argument
which is the alignment to use in allocating memory for the spaces. On many
systems, the alignment will be on a page boundary; this is interesting
because we have to set access privileges on some of the spaces.

\end{document}