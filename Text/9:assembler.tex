% -*- TeX -*-
% $Id: assembler.tex,v 1.3 92/02/23 16:56:42 lth Exp $
%
% WARNING. THE PRESENT AUTHOR ASSUMES NO RESPONSIBILITY FOR ANY AND ALL
% DAMAGES RESULTING FROM THE HANDLING OF THIS FILE, INCLUDING BUT NOT LIMITED
% TO READING, EDITING, DIGESTING, DELETING, DUPLICATING, OR TRANSFERRING
% BY MEANS ELECTRONIC, MANUAL, OR OTHERWISE.
%
% (From alt.suicide.holidays -- for no particular reason):
%
% P.S. Happy St. Valentine's day.  Today's method:
% Buy a hunting bow. Paint it pink.  Write a depressing note, like "Cupid
% did it." or "Love hit a little too hard." Using a chair and a strong 
% piece of wood to wedge the strings back, set the arrow in the bow. 
% Line up arrow with your heart.  Using a small sledge hammer, knock the
% wood loose. :-) ;-)
%
%               /   \_/   \
%              |           |
%      \\\      \         /
%       |||------\    ------------>
%      ///        \     /
%                  \   / 
% 

\input{larceny.sty}

\title{Larceny Note \#9: \\
       The Hitchhiker's Guide to the Assembler \\
       {\tenrm (draft!!)}}
\author{Lars Thomas Hansen}

\begin{document}
\maketitle

\begin{abstract}
This document describes the Larceny assembler. The assembler has two
parts: a target-independent front end (which was derived from pass 5
of the scheme 313 compiler) and a target dependent back end. Since a
back end exists only for the Sparc, only Sparc targetting issues will
be discussed.

Be aware that the term ``assembler'' is a bit of a misnomer. Although the
input is MacScheme assembly language and the output is Sparc object code,
both Sparc code generation and optimization is done by the assembler.

The author does not apologize for the somewhat irreverent tone of this
document. See, however, the last section for a general disclaimer.
\end{abstract}

\section{Overview}

As described in Larceny Note \#5, the assembler takes MacScheme
assembly language (in a form where the opcode is a small nonnegative
integer) as input and produces Sparc assembly language in the form of
segments as output. The current assembler does this in three passes.
The first pass takes the original MacScheme assembly language input
and and produces Sparc assembly language, also in a symbolic form
where the opcode is represented by a small nonnegative integer. The
second pass makes a pass over the Sparc code, collecting labels and so
on. The third pass makes another pass over the Sparc code and
generates Sparc object code in relocatable form.

The files needed by the assembler are these:

\begin{itemize}
\item
``Compiler/assembler.sch'' is the front end and overall driver. It takes as
input a list of MacScheme assembly language instructions and produces as
output a segment. This file was derived from pass5, part 1, of the Scheme 313
compiler, and the changes are partly gratuitous. The rest of the assembler
should really be changed to work with pass5p1 so that we can have as much
common code as much.

\item
``Sparc/gen-msi.sch'' has procedures which generate Sparc instructions from
MacScheme instructions.

\item
``Sparc/gen-primops.sch'' has procedures which generate Sparc code for
the primops found in the {\tt op}, {\tt op2}, {\tt op3}, and {\tt op2imm}
instructions generated by the compiler, as well as for primops which are
not found in compiler-generated code but which are generated by peephole
optimization.

\item
``Sparc/asm.sparc.sch'' is the Sparc assembler. It takes as input
a list of sparc instructions and procedures a list of raw object code bytes.

\end{itemize}

In addition, several headers are needed. These headers are all autogenerated
by the config program; we want all the files ``Sparc/*.sch.h''.

\section{Larceny Sparc Assembly Language Syntax}

The syntax is really straightforward, although a tad wordy. In essence (and
in order to make things easier for the assembler, which already has to
work hard), each instruction for which it is applicable has a suffix which
specifies the kind of second operand it takes. For example, ``ld'' comes
in two flavors: ``ldi'' (reg + immediate) and ``ldr'' (reg + reg).
Similarly for the rest. Each instruction is wrapped in a list. The car of
the list is the opcode; all opcodes are defined in the assembler itself,
way at the beginning of the file. So, continuing our example, ``ld'' is
actually named ``\$i.ldi'' and ``\$i.ldr'' as appropriate.

The other operands are encoded as integers, although expressions which yield
integers can be used (see below). For immediate operands, the value of the
integer is what gets stuffed into the object code in the immediate field;
the assembler munges the operands for branches and jumps and calls as you
would expect. For register operands, the registers are defined in
``registers.cfg'' at the top level and in ``registers.sch.h'' in the Sparc
directory. A register is ``\$r.'' followed by the register name. The aliases
used in Larceny are all there. So, you can say ``\$r.result'' and ``\$r.g0''
and all that (and don't you too wish \LaTeX\  did not use \$ to mean something
special?).

You can have expressions in all operand fields (yes, even those for
registers, although it may not be advisable). These expressions are evaluate
by the assembler at assemble time; not all desirable expressions (although
many) can be evaluated at code generation time. Especially labels are
resolved late. Expressions have the form of Scheme expressions, and
available operators are ``+'', ``-'', ``hi'', and ``lo''. The two latter
have the same meaning as in the Sparc assembler: ``hi'' returns the high 22
bits of its argument (shifted 10 bits to the right), and ``lo'' returns the
low 10 bits. Valid operands are labels (which are always in the form of
symbols), integers, and the special symbols ``\$'' (there it is again!).
The symbol ``\$'' evaluates to the address of the start of the current
instruction, relative to the start of the code vector currently being
assembled. Since labels have similar semantics -- the value of a label is
its offset from the start of the current code vector -- interesting
expressions can be constructed with which we can figure out the distance
from the current point to a label.

If you reference a label but forget to define it, the assembler will be very
upset during pass 2 (aka pass 3) of the assembly.  If you use too large
constants in immediate fields, the assembler will silently truncate them to
fit them into the fields. This is not a feature, but fast assembly is, and
one day there will be no more bugs in the code generator and then what do
we need error checking for?

Here's an example of the assembly language, taken mostly from ``gen-msi.sch'':

\begin{minipage}{\linewidth}
\begin{verbatim}
  (let ((label (new-label)))
    (list `(,$i.subicc ,r ,$imm.unspecified ,$r.g0)
          `(,$i.bne.a ,l1)
          `(,$i.slot)
          `(,$i.orr ,$r.tmp1 ,$r.g0 ,$r.argreg2)
          `(,$i.jmpli ,$r.millicode ,$m.undef-exception ,$r.o7)
          `(,$i.addi ,$r.o7 (- ,l0 (- $ 4) 8) ,$r.o7)
          `(,$i.label ,l1)))
\end{verbatim}
\end{minipage}

The ``\$i.slot'' instruction is a hint to the assembler that the delay
slot may be filled from the branch target (or from the previous instruction,
if the assembler is intelligent enough to make that sort of a decision).

There are two other pseudo-ops defined: ``\$i.label'' and ``\$i.ceai''.  The
former is show above; it shows the presence of a label in the code.  The
latter stands for ``calculate effective address with immediate operand'' and
is not implemented (although it ought to be); it is equivalent to the
sequence of ``jmpli'' + ``addi'' shown above (see Larceny Note \#1 for
grungy details). The idea is that the pseudo-op can expand into the quick or
the slow sequence for calculating the effective address, depending on how
far away the target it. The assembler is not smart enough to figure this out
at present. There are other instruction sequences with the same problem;
these should get pseudo-ops as well.

\section{MacScheme Assembly Language to Sparc Assembly Language}

(stuff about the table and pass4.imp.sch and the finalization and all that.)

\section{Sparc Assembly Language to Sparc Object Code}

(stuff about the table and the bits and all that and why bignums are not
the right way to do it even if it makes it simpler for the assembler writer)

\section{Disclaimer}

The author wishes to make it known that the Sparc assembler described
in the preceding sections is the first assembler he has ever written,
and that the Sparc is the first RISC architecture he has ever known
the assembly language of. As a consequence, and in order to redeem
himself, he would like to point out that had he had to write the
assembler over again, he would indeed have done it differently, if not
in the small details so at least in the large.

\end{document}
