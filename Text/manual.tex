% -*- LaTeX -*-

\documentstyle[10pt]{article}
\newcommand{\reg}[1]{{\sc \%#1}}

\topmargin      -2.0cm
\oddsidemargin   0.0cm
\evensidemargin  0.0cm
\textwidth      6.5in
\textheight     9.5in
% \parindent       0.0cm
% \parskip         0.4cm

\newcommand{\proc}[2]{\noindent \code{(#1 {\em #2})} \hfill {\em procedure} \\}
\newcommand{\arg}[1]{{\em #1}}
\newcommand{\code}[1]{{\tt #1}}

\title{Larceny User's Manual \\ {\large Version 0.25}}
\author{}
\date{January 13, 1995}

\begin{document}

\section{Installation}

You need two files: the executable (\code{larceny}) and a heap image
(\code{larceny.heap} or -- more typically -- \code{compiler.heap}).

\section{Startup}

Larceny's default read-eval-print loop allows files to be automatically
loaded at startup time.  If a file called \code{.larceny} exists in the
current directory or in the user's home directory (searched in that
order), then it is assumed to contain either Scheme source code or
Larceny fast-load format code, and the read-eval-print loop will attemt
to load it and evaluate each expression.  If any expression causes an
error to be signalled, the load is aborted and the actual
read-eval-print loop is entered.

\section{Lists}

list-copy
last-pair
remq
remv
remove
append!
reverse!

\section{Symbols}

symbol-hash
gensym
getprop
putprop
remprop

\section{Numbers}

Larceny implements the entire numeric tower as described in R4RS, and all
the operations on those numbers.

\subsection{Generic operations}

random

\subsection{Representations}

Larceny has six representations for numbers.  These are:

\begin{description}

\item{fixnums} are small exact integers in the range $-2^{29} \ldots 2^{29}-1$,
 represented using two's complement;

\item{bignums} are large exact integers outside the fixnum range and in
 the range $-2^{2097152} \ldots 2^{2097152}$, (631305 decimal digits);

\item{ratnums} are exact rational numbers where the numerator and denominator
are both exact integers (fixnums or bignums);

\item{flonums} are inexact rational numbers implemented using IEEE double
 precision floating point numbers (11 bit exponent, 53 bit significand);

\item{compunums} are inexact complex numbers where the real and
 imaginary parts are represented using IEEE double precision floating point
 numbers; and

\item{rectnums} are exact complex numbers where the real and imaginary
 parts are represented using exact numbers (fixnums, bignums, or ratnums).

\end{description}

\proc{fixnum?}{obj}
\proc{bignum?}{obj}
\proc{compnum?}{obj}
\proc{flonum?}{obj}
\proc{ratnum?}{obj}
\proc{rectnum?}{obj}

\subsection{Fixnum operations}

Larceny provides some operations on fixnums.

\proc{lsh}{fixnum bits}

Left-shift logical the \arg{fixnum} argument by \arg{bits} bits.
\arg{Bits} must be an exact nonnegative integer.  On the SPARC, the
number of bits is interpreted modulo 32.  Bits shifted out at the high
end are lost.

\proc{rshl}{fixnum bits}

Right-shift logical \arg{fixnum} by \arg{bits} bits.  \arg{Bits} must
be an exact nonnegative integer.  On the SPARC, the number of bits is
interpreted modulo 32.  Bits shifted out at the low end are lost.

\proc{rsha}{fixnum bits}

\proc{logand}{m n}
\proc{logior}{m n}
\proc{lognot}{m n}
\proc{logxor}{m n}


\section{Strings}

string-hash
substring-fill!

\section{Control features}

call/cc
list->procedure
make-procedure
procedure-length
procedure-ref
procedure-set!

\section{Input and Output}

port?
flush-output-port
eof-object
delte-file
reset-iosystem
rename-file
file-exists?
file-modification-time

\section{Bytevectors}

A {\em bytevector} is a fixed-length constant-access-time data structure
containing bytes, where a byte is an exact integer in the range $0\ldots
255$.  

\proc{make-bytevector}{k l}
\proc{bytevector?}{obj}
\proc{bytevector-length}{bv}
\proc{bytevector-fill!}{bv k}
\proc{bytevector-copy}{bv}
\proc{bytevector-ref}{bv k}
\proc{bytevector-set!}{bv k l}



\section{Error handling}

Larceny gives the program some control over how errors are handled, but
stops short of providing a general exception handling mechanism at this
time.

\proc{error}{msg irritant ...}

The expression \code{(error msg irritant ...)} is equivalient to 
the expression \code{((error-handler) '() (list msg irritant))}.  See the
description of \code{error-handler}.

\proc{error-handler}{[arg]}

If called without arguments, \code{error-handler} returns the currently
installed error handler.  If called with a single argument, which must be
a procedure with one fixed argument and a rest argument, it installs
the procedure as the current error handler in a global location.

The error handler is called to signal a system or library error, and by
the default \code{error} procedure.  The first argument to the error
handler is either an exact nonnegative integer, the empty list, or some
other object.  If the first argument is an exact nonnegative integer,
then the error being reported is a primitive error, the number is the
error code, and there will be three arguments, one for each of the
virtual machine primitive argument registers (RESULT, SECOND, THIRD).
If the first argument to the error handler is the empty list, then the
argument is to be ignored and the rest are to be treated as an error
message.  If the first argument is neither a number nor the empty list,
then it constitutes the first element of the error message.  The default
error handler decodes the error if it is a system error, and in either
case prints an error message and calls \code{reset}.

\proc{reset}{}

The expression \code{(reset}) is equivalent to the expression
\code{((reset-handler))}.  See the description of \code{reset-handler}.

\proc{reset-handler}{[arg]}

If called without arguments, \code{reset-handler} returns the currently
installed reset handler, a procedure of no arguments, which, if called,
performs a reset.  The exact semantics of a reset are not well defined,
but in an interactive setting it would typically return the state of the
system to a read-eval-print loop.  If \code{reset-handler} is called with
a single procedure argument, it installs that procedure as the current
reset handler.

\proc{error-continuation}{}

\section{Timer interrupts}

\proc{interrupt-handler}{[arg]}
\proc{disable-interrupts}{}
\proc{enable-interrupts}{count}
\proc{call-without-interrupts}{thunk}

\section{Performance}

run-with-stats
run-benchmark
collect
memstats
display-memstats

\section{Miscellaneous}

exit
eval
unspecified
undefined
dumpheap
getenv

\end{document}
