% -*- TeX -*-
% $Id: compmodel.tex,v 1.2 1992/05/15 22:18:56 lth Exp $
%
% MacScheme's computational model

\input{larceny.sty}

\title{Larceny Note \#12: \\
       The MacScheme Computational Model}
\author{Lars Thomas Hansen}

\begin{document}
\maketitle

\begin{abstract}
I am writing this note in order to clarify and disambiguate several situations
for myself, with the presumed side effect that others can read this and be
enlightened somewhat quicker than I was.
\end{abstract}

\section{The Stack}

The name of the game is ``stacks'' -- what they are, how we use them, and
what kind of semantics the MacScheme stack operations have. On the surface
it is all very simple, but when you start playing around with the stack cache
and you get underflows, overflows, flushes, and restores, things become
more intricate.

A stack frame has the following abstract structure:

\begin{verbatim}
            +------------------+   <-- stack ptr
            |  return address  |
            +                  +
            |  saved REG0      |
            +                  +
            |  saved REG1      |
            +                  +
            |  etc...          |
            +------------------+
            |  (next frame)    |
\end{verbatim}

The return address is into the procedure which is the saved REG0. An 
optimization is to cache the return address in a register, but if it
always is in the stack frame when it counts (i.e. when the runtime
system looks for it), this tweak is not important.

Stack frames are kept not in an infinite stack but rather in a stack
cache -- a relatively small bounded area of memory. When a stack frame
is created, the stack cache may overflow, and if so happens, it is
flushed to the heap. Similarly, when we drop a stack frame and move
to a previous stack frame, the stack cache may underflow if it previously
overflowed and was flushed. These exceptional conditions must be
detected and dealt with.

When the stack cache is flushed, each frame is put into the heap in a
separate continuation frame, and a linked list is constructed of the
frames. A global register is set to point to this chain of frames in
the heap. On an underflow, only one frame is restored at a time. This
strategy, known as the incremental stack/heap strategy, is described
in \ref{continuation-paper}.

The following MacScheme instructions operate on the stack in some way
or another:\footnote{All descriptions verbatim from the instruction
set reference sheet.}

\begin{description}

\item \verb+stack n+

Loads RESULT with the value of slot n in the topmost frame of the stack cache.
(Slot n is the saved value of REGn.)

\item \verb+setstk n+

Stores RESULT in slot n in the topmost frame of the stack cache. Destroys
RESULT.

\item \verb+load n, k+

Loads REGk with the value of slot n in the topmost frame of the stack cache.

\item \verb+store k, n+

Stores REGk in slot n of the topmost frame of the stack cache.

\item \verb+save L, k+

Pushes a new continuation frame onto the stack cache containing return address
L and the values of registers REG0-REGk. Faults on stack cache overflow.

\item \verb+setrtn L+

Stores the return address L in the return address slot in the topmost frame
of the stack cache.

\item \verb+restore k+

Restores registers REG0-REGk from the topmost frame of the stack
cache.  This frame is known to have been created by \verb+save L, n+,
where {\tt k} <= {\tt n}.

\item \verb+pop n+

Pops the topmost frame from the stack cache.  This frame is known
to have been created by \verb+save L, n+.

\item \verb+return+

Jumps to the return address contained in the topmost frame of
the stack cache.

\end{description}

From this it is clear that the only instruction which creates a new frame
is {\tt save}, and the only instruction which destroys a frame is {\tt pop}.

If the stack were of infinite size (or simulated by a list of frames
in the heap, which is possible given the definition of the
instructions) then there would be no problem. As it is, however, we
have a small, bounded stack cache which holds a limited number of
frames and which is subject to both overflows and underflows, and in
addition, the application of a continuation captured with {\tt
call/cc} replaces the contents of the stack cache with the contents of
a previous stack (more on this below).

Briefly, the problem is to always ensure that there is a stack frame in
the stack cache when it is accessed with a stack instruction. 

It appears that it is {\em sufficient} to always make {\tt pop} check for a
stack underflow, and to restore a frame if there is an underflow. In
addition, the capture of a continuation (which entails a stack flush)
must restore the top frame, and the reinstating of a continuation must
also restore the top frame. 

The question is whether this solution is in fact {\em necessary} --
the less we have to do, the better. However, and in particular, the
previous solution used (which restores on {\tt return} by falling into
an underflow handler when the stack cache underflows; there is a
return address at the bottom of the stack cache in which the return
address points to the underflow handler) appears to be insufficient
when stack frames are created to a depth of more than one in a
procedure, i.e. if there exists some execution sequence within a
procedure in which two {\tt save}s are not separated by a {\tt pop}.

\end{document}
