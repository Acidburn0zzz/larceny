Information about Petit Larceny on Win32
28 September 2002 / lth

HOW TO BUILD.

See HOWTO-PETIT for information about this.  COMPILE-FILES works.

BUILD-EXECUTABLE usually results in linking warnings; it is safe to
ignore them.


STATUS.

Currently compiles, loads and runs, and seems to work OK:
 - Can load scheme files and run them
 - Compiling FIB.SCH to a code-less FASL, linking the code statically
   into the executable with BUILD-APPLICATION, loading the FASL, and 
   running FIB now works.
 - Compiling FIB.SCH to a code-less FASL + a DLL for the code, loading
   the FASL, and running FIB now works.
 - FFI works!!
 - Passes Aubrey Jaffer's R4RS test suite
 - Self-hosting works: have rebuilt entire system from within the
   interpreter.
 - Microsoft Visual C/C++ 6.0 (Personal Edition) has code pointer alignment
   issues and cannot be used; MetroWerks CodeWarrior does not have any 
   problems, as every procedure appears to be 16-byte (?) aligned.


I've tested both with the longjmp jump discipline (which doesn't work
well, see below) and the trampoline technique (which works fine).


TODO.

Code pointer alignment under MSVC -- appears not to do any alignment.

FIXMEs in the Win32 support code (osdep-win32); nothing important,
mostly version number / time measurement.

Synchronous interrupts are disabled because longjmp out of signal
handler does not work on WinNT or Win2K; it would be nice to fix
this (or some blocking syscalls will not be interruptible).


Access to OS functions.

There is a callout FFI implementation in Ffi/ffi-i386.sch --
incorporated into the FFI system as well as into Auxlib/std-ffi.sch,
with minimal adaptations needed -- which passes the std-ffi test suite
in Testsuite/FFI, so Petit Larceny on this platform can actually load
and use foreign functions!  (Note, libc is not loaded by default.)


Performance.

The generated code is not at all good in the MSVC++ Standard Edition
("cheap") compiler: the code contains many redundant loads, and stack
slots are not reused, so stack frames are huge.  At a guess there is
no global optimization in this compiler.  (I've tried /O2.
Optimization switches are not documented in the compiler help
message.)

With MSVC compiled code, interpreter performance is generally iffy:
interpreted fib(25) is a factor of 10 slower than in Petite Chez
Scheme.  In Petite Chez Scheme, compiling and assembling the basic
heap image takes a few minutes; in Petit Larceny it takes 35 minutes.
The bulk of the time is spent running Twobit; just assembling the LAP
and compiling the C code and building heap takes a few minutes.

Metrowerks CodeWarrior 6.0 generates *much* better code, and just
recompiling Interpreter\interp.c and Interpreter\inter-prim.c with
that compiler on full optimization cuts the running time of fib(25) in
half.  It also cuts generated code size in half, on those two files.

(General performance hint: it may be important for truly good code
generation to generate completely dense switches for dispatch in a
procedure -- no gap between the start label 0 and normal label, and no
dead labels.)

Compiled fib(30) is about four times faster than Petite Chez Scheme;
not exactly impressive, but OK, maybe?

Peephole optimization in the Standard-C assembler may be important for
good performance.


Codewarrior issues.

Can't compile at least lib/common/ehandler.c with '-opt full'; the
optimizer runs out of memory (about 300MB).  This is a problem also on
the Mac.  Might consider rewriting the Scheme code to accomodate the C
compiler.  Even so, some other files may cause problems (reader.sch,
memstats.sch, toplevel.sch).  The change in optimization switches may
matter: the interpreter compiled with '-opt on' seems to be slower
than when compiled with '-opt full' as measured by fib(25).

Just compiling with '-opt on' takes a looooong time on some files.


Jump discipline issues.

The MSVC++ 6.0 Standard Edition compiler is not very good.  In
particular it does does not reuse stack slots.  As a result, the
generated code is not good, and the stack frames are enormous: in the
reader procedure, admittedly an outlier, the stack frame is 3.5KB.

Therefore, a longjmp control discipline only works if the stack is
really huge, and I have not been able to specify a large enough stack
for this to work reliably.  (The largest stack I've been able to set
up is about 1MB; the OS requires a set stack size, apparently.)  In
practice, this discipline is not a good choice with this compiler.


Linking problems.

It is painful to link with /Zi to get (rudimentary) debug information
for compiled scheme code.  The problem seems to be that the debug info
database is always called vc60.pdb and is co-located with the library,
*and* the library must be compiled with a lib-path that indicates the
location of the pdb (it seems).  For the time being, I compile the
compiled scheme code with /Zd and then delete the resulting pdb before
linking; this gives full debug info for the RTS but very little for
the compiled scheme code (enough for the moment).


Debugging in Visual Studio.

To run under debugger, start MSVC and select 'File | Open workspace'
and then open petit.exe as the workspace; then run.  Breakpoints can
be set; variables in the RTS can be inspected (full debug info).
