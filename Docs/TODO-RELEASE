$Id$

Release 2 todo and check lists

Working on:

 * Implement pointer transformation for non-aligning compilers.
   Works for USE_GOTOS_LOCALLY+RETURN_WITH_VALUE, not otherwise tested.
   Need to test:
     - other jump disciplines
     - other C compilers than mingw
     - that twobit.exe works as it should (it does, with mingw)


Things That Must Be Done (tm) aka Significant Usability Bugs (r)

 * Bug: DLL loader code (in Lib/Standard-C/loadable.sch) does not
   properly adjust the code pointer.  One problem is that it is not
   known to that code whether the code pointer has to be adjusted or
   not!

 * Bug: HOWTO-SPARC is incomplete.

 * Quality: the HOWTO documentation needs to be HTML, it is becoming
   increasingly cross-referenced.

 * Quality: Implement and document REMOVE-TWOBIT-OBJECTS.

 * Update all documentation to reflect the actual state of the system.
   In general, HOWTO-WIN32 has a lot of old cruft.

 * Quality: wizard options help should be available with -wizardhelp
   only

 * Quality: should accept -- as the options character

 * Quality: Instances of OPTIMIZEME in Rts/Standard-C/petit-instr.h.  

 * Quality: Get rid of Auxlib/ altogether.  Stuff that must be available
   for twobit goes into Lib; the rest moves to the external library.

 * Quality: Online help not quite right for Petit Larceny

 * For most people it is most reasonable that Twobit share the macro
   definitions between the interpreter and compiler, so that loading
   a file with macros in the interpreter is reflected when the compiler
   is invoked.  This does not work now.  Fix it!

 * Better dynamic loading of compiled code: as it is, a given file
   can only be loaded once, so if foo.fasl points to foo.so and
   foo.so is regenerated, then (a) if the old version is overwritten
   we crash, and (b) even if we don't crash the loader will refuse to
   load a file with the same name again.  So either (a) give the
   object files consecutive names (.1.so, .2.so, ...) or (b) store
   the object code in the FASL file (in a bytevector) and dump it 
   into /tmp and load it from there when loading the FASL.  Gambit
   does the former, it requires being able to inspect the directory.
   The latter solves the silly LD_LIBRARY_PATH problem and makes
   FASL files easily moveable.

 * Make the debugger work with both x86-NASM and Petit, and make sure
   debug info is emitted correctly.  Information is probably missing
   for internal procedures.  See Larceny note #12 and 
   Lib/Common/procinfo.sch.

 * SRFI: The most important non-supported SRFIs are the exception
   and condition SRFIs.  It would be very nice to have these.

 * FFI: Test well on Win32 -- does it work according to the docs?

 * FFI: Test well on Linux -- does it work according to the docs?

 * FFI: Does the docs reflect how it works?

 * SRFI: I am using COND-EXPAND to load SRFIs but this is sort
   of bogus, cf recent discussion on SRFI-0 list.  Should probably
   fix this both in SRFI code as well as in test code.


Release candidate 1 -> Release candidate 2

  Building and running

  - testbuild petit / win32 / CodeWarrior
    - build instructions
    - build twobit
    - rebuild with self
    - run test suite compiled
    - run test suite interpreted
  - testbuild petit / x86-linux / gcc
    - build instructions
    - build twobit
    - rebuild with self
    - run test suite compiled
    - run test suite interpreted
  - testbuild petit / MacOSX / gcc
    - build instructions
    - build twobit
    - rebuild with self
    - run test suite compiled
    - run test suite interpreted
  - testbuild petit / Solaris / gcc
    - build instructions
    - build twobit
    - rebuild with self
    - run test suite compiled
    - run test suite interpreted
  - testbuild native / Solaris / gcc 
    - build instructions
    - build twobit
    - rebuild with self
    - run test suite compiled
    - run test suite interpreted

  Test heap dumping everywhere?

  Package libraries and scripts so that it is convenient to
  build apps without having a source tree available?


