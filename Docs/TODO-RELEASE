$Id$

Release 2 todo and check lists


Things That Must Be Done (tm)

 * Merge Util/petit-macosx.sch into Util/petit-unix-be.sch,
   ditto for any configuration stuff in Util/configurations.
   Change doc'n as appropriate.

 * SRFI: The most important non-supported SRFIs are the exception
   and condition SRFIs.  It would be very nice to have these.

 * Remove the local SRFI directory, since it is now in the external 
   library.

 * FFI: Test on Win32 and Linux, make sure it works and that the
   documentation reflects how it works.

 * Test peephole optimization in Petit Larceny, and when it
   appears to work, turn it on by default.  Consider backporting
   eg GLOBAL/INVOKE from the x86-nasm version.

 * Figure out how to emit #defines into the generated C and ASM
   for compiler switches that effect the macros, like unsafe-code
   and inline-allocation.

 * Make work under Win32 with Cygwin or MinGW.

 * Implement pointer transformation for non-aligning compilers,
   to work properly under Win32 with Codewarrior and MSVC.

 * Better dynamic loading of compiled code: as it is, a given file
   can only be loaded once, so if foo.fasl points to foo.so and
   foo.so is regenerated, then (a) if the old version is overwritten
   we crash, and (b) even if we don't crash the loader will refuse to
   load a file with the same name again.  So either (a) give the
   object files consecutive names (.1.so, .2.so, ...) or (b) store
   the object code in the FASL file (in a bytevector) and dump it 
   into /tmp and load it from there when loading the FASL.  Gambit
   does the former, it requires being able to inspect the directory.
   The latter solves the silly LD_LIBRARY_PATH problem and makes
   FASL files easily moveable.

 * Update documentation to reflect the actual state of the system

 * X86-NASM: Finish up the exception handling millicode.  Make sure 
   it can at least rebuild itself and run the test suites, we can
   put off more optimization and call it 'alpha'.

 * Make the debugger work with both x86-NASM and Petit, and make sure
   debug info is emitted correctly.  (This seems OK in the x86 version
   but not OK in 0.51, there might be a bug in emitting debug info
   for some system thunks in Petit Larceny?)

 * The require system must play nice with heap dumping: the database
   must not be unconditionally reinitialized even if .larceny reloads
   the REQUIRE package.


Release candidate 1 -> Release candidate 2

  Building and running

  - testbuild petit / win32 / CodeWarrior
    - build instructions
    - build twobit
    - rebuild with self
    - run test suite compiled
    - run test suite interpreted
  - testbuild petit / x86-linux / gcc
    - build instructions
    - build twobit
    - rebuild with self
    - run test suite compiled
    - run test suite interpreted
  - testbuild petit / MacOSX / gcc
    - build instructions
    - build twobit
    - rebuild with self
    - run test suite compiled
    - run test suite interpreted
  - testbuild petit / Solaris / gcc
    - build instructions
    - build twobit
    - rebuild with self
    - run test suite compiled
    - run test suite interpreted
  - testbuild native / Solaris / gcc 
    - build instructions
    - build twobit
    - rebuild with self
    - run test suite compiled
    - run test suite interpreted

  Test heap dumping everywhere?

  Package libraries and scripts so that it is convenient to
  build apps without having a source tree available?


