Building Larceny
27 April 2006 / pnkfelix+samth+tov

WHAT YOU NEED

You will need a Scheme system to host the Larceny build process;
currently this works with MzScheme 209 and Larceny [1].

Additional requirements for building Petit Larceny are the same as the
requirements for compiling Scheme sources using Larceny (see
../README-FIRST.txt).  For Native Larceny (SPARC), you will need a C
compiler (such as GCC).

WHAT TO DO

Building Larceny has three major steps:

1. Get the Larceny development environment working.

Run your host Scheme (either another Larceny or MzScheme 209), and
change to the root directory of the Larceny tree.

    > (load "Util/petit-setup.sch")
    > (setup 'scheme: ${SCHEME} 'host: ${HOST} ['native])
    > (setup-directory-structure)       ; The first time only
    > (build-config-files)              ; [2]
    > (load-compiler)

The call to setup (above) has several options that determine which
version of Larceny you build:

        SCHEME ::= 'mzscheme | 'larceny | 'petite | 'chez       [1]
        HOST   ::= 'macosx | 'solaris | 'linux86 | 'win32

Additionally, the optional 'native flag will build Native Larceny
(SPARC) on Solaris, or will use the NASM backend on x86.  The 'native
flag is necessary to use dynamic loading on Win32, and is thus strongly
recommended in that case. [3]

Some useful examples:

    > (setup 'scheme: 'larceny  'host: 'solaris 'native)
    > (setup 'scheme: 'mzscheme 'host: 'win32 'native)
    > (setup 'scheme: 'larceny  'host: 'linux86 'native)
    > (setup 'scheme: 'mzscheme 'host: 'linux86)
    > (setup 'scheme: 'larceny  'host: 'solaris)
    > (setup 'scheme: 'mzscheme 'host: 'macosx)

There are also several optional parameters, which turn on features of
the compiler.

2. Build Larceny components

After the development environment is setup, you can compile Larceny:

    > (build-heap)
    > (build-runtime)
    > (build-executable)

For the compiler:

    > (build-twobit)

On Native Larceny (SPARC), you should also run:

    > (build-larceny-files)
    > (build-r5rs-files)

3. Create heap images

Step 2 above creates a "bootstrap heap" (petit.heap on Petit, and
sparc.heap on Native (SPARC)).  To use the compiler on Petit Larceny,
you need to then create the twobit.heap image.  Starting in the shell,
once you've done (build-twobit) above:

    % ./twobit.bin -heap petit.heap -- Util/petit-twobit-heap.sch
    > (dump ${HOST} ['native])

You can now run ./twobit (or twobit.bat on Windows).

If you are using Native Larceny (SPARC), you should dump heaps
corresponding to (build-twobit), (build-larceny-files), and
(build-r5rs-files) above:

    % ./larceny.bin -heap sparc.heap -- Util/twobit-heap.sch

    % ./larceny.bin -heap sparc.heap -- Util/larceny-heap.sch

    % ./larceny.bin -heap sparc.heap -- Util/r5rs-heap.sch

You can now run ./twobit, ./larceny, and ./larceny-r5rs.


NOTES

[1] Currently we support MzScheme 209; MzScheme 3xx will be supported in
a later release.  Use (Petite) Chez at your own risk.

[2] This is only strictly necessary the first time and when the options
given to setup have changed, but it should be safe to do every time.

[3] Two other potentially useful flags, given optionally at the end of
the call to setup:

'code-cov - This enables loading of the instrumented files generated by
          the stcov tool when loading the compiler. Use this to test
          code coverage of the compiler testsuite

'rebuild-code-cov - This causes the stcov files to be regenerated before
          loading.  This implies 'code-cov.

