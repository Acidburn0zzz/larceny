Building and using Petit Larceny
15 August 2003 / lth


HOW TO BUILD PETIT LARCENY AND USE THE BUILD ENVIRONMENT

If you haven't read the build instructions on the web page, do so now.

For the most part Petit Larceny is built by tools written in Scheme,
so you need a working host Scheme system; a version of Petit Larceny
with just the interpreter is sufficient.  See below under
BOOTSTRAPPING if you don't have a working Scheme system.

First things first:

  * You must inspect Rts/Sys/config.h and choose the configuration
    you are building.

  * You will probably need to edit Rts/Makefile to make it fit your
    system -- "make" is used to build the run-time system.

Then start your host Scheme system, change your working directory to
be the Larceny source directory if necessary, and load the appropriate
configuration file for your operating system, currently one of:

	Util/petit-win32.sch
	Util/petit-macosx.sch
	Util/petit-unix-be.sch
	Util/petit-unix-el.sch

These programs sometimes invoke external programs and may place
additional demands on your host system.  Currently all systems need
some version of "make" to be able to build the run-time system, and
will need access to a command interepreter.

The first time you run the build environment you will want to evaluate:

	> (setup-directory-structure)

Whenever you have altered any of the Rts/*.cfg, or the first time you
run the build environment, you will want to evaluate:

	> (build-config-files)

Most of the time you will just load Twobit (you can't load Twobit
until after you have created the directory structure and config files,
which is why it is a separate step):

	> (load-compiler)

and then build the heap image, the runtime system, and finally the
executable:

	> (make-petit-heap)
	> (build-runtime-system)
	> (build-executable)

Other useful commands are:

	> (remove-heap-objects)   ; removes generated files (LAP, LOP, C, OBJ)
	> (remove-rts-objects)    ; removes OBJ files in the Rts tree

It is also possible to create an application that contains more
compiled code than the standard heap image.  In this case, the object
code for your program is linked statically into the Larceny executable
but the program's data are available in code-less FASL files, as for
the native Larceny.  This may seem a little strange and unnecessary
but it simplifies things overall, because scripts for native Larceny
will work unaltered in Petit Larceny.

	> (build-application "petit" <list-of-lop-files>)

(On Win32 the executable name would be "petit.exe".)  The command
above generates an executable called "petit" and a bunch of FASL
files.  For convenience, one can just catenate all these FASL files
into a single FASL file that can be loaded with one command, making it
easier to package a lot of compiled code into an application-like
bundle.

A facility built on BUILD-APPLICATION is called BUILD-TWOBIT:

	> (build-twobit)

The BUILD-TWOBIT command compiles all the Twobit source files and
creates an executable "twobit" (or "twobit.exe") that contains the
code for Twobit, as well as FASL files for all these files.

If you build Twobit using BUILD-TWOBIT, and then start "twobit" and
follow the directions above (loading "Util/petit-macosx.sch", say, and
then running LOAD-COMPILER), you will have a development environment
with a compiled compiler.

On some systems it is possible to load compiled Scheme code
dynamically.  A driver routine called COMPILE-FILES compiles a group
of Scheme files into a single shared object and a group of code-less
FASL files.  Loading the FASL files with LOAD will load and link the
shared object:

	> (compile-files '("fib.sch") "fib.fasl")
	> (load "fib.fasl")
	> (fib 10)
	55

The COMPILE-FILES facility is working but it is not 100% clean; see
notes in the file TODO-PETIT.


PLATFORM SPECIFICS

Read the files HOWTO-WIN32, HOWTO-MACOSX, and HOWTO-UNIX for status on
the various ports and special instructions for building on specific
systems.


BOOTSTRAPPING

There is an *example* Makefile called 'bootstrap.mak' that you can use
to build Petit Larceny from C sources.  This requires that you cross
compile to C on some other host.  Cross compilation is supported in
the same build environment as described above; for example, the file
"Util/macosx-on-win32.sch" was used to cross-compile to C for MacOS X
from a Win32 system.
