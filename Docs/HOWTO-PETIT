Building and using Petit Larceny
18 November 2002 / lth

HOW TO BUILD AND USE.

Rather than relying on various platform hacks, the build logic has
been moved into Scheme.  So you need a working Scheme system to build
Petit Larceny; a version of Petit Larceny with just the interpreter is
sufficient.  See below under BOOTSTRAPPING if you don't have a working
Scheme system.

As always, you must first of all look at Rts/Sys/config.h and choose
the configuration you are building.

Start your Scheme system, change to the Larceny source directory if
necessary, and load the appropriate file for your operating system,
currently this is one of:

	Util/petit-win32.sch
	Util/petit-macosx.sch
	Util/petit-unix-be.sch
	Util/petit-unix-el.sch		; currently mythical

These programs sometimes invoke external programs and may place
additional demands on your system; currently all systems need some
version of "make" to be able to build the run-time system.

The first time you run the build environment you will want to evaluate:

	> (setup-directory-structure)

Whenever you have changed Rts/*.cfg, or the first time you run the
build environment, you will want to evaluate:

	> (build-config-files)

Most of the time you will just load Twobit (you have to do this
*after* you create the directory structure and config files, which is
why it is a separate step):

	> (load-compiler)

and then build the heap image, the runtime system, and the final
executable:

	> (make-petit-heap)
	> (build-runtime-system)
	> (build-executable)

NOTE.  Build-runtime-system currently invokes 'make' on your system,
using Rts/Makefile for the rules.  It is probably necessary to configure
that makefile for your system.  I'm working on fixing this by getting
rid of Rts/Makefile altogether (replacing it with a Scheme version).

Other useful commands are:

	> (remove-heap-objects)           ; removes all generated files (LAP, LOP, C, OBJ) and 
	> (remove-rts-objects)            ; removes all .OBJ files in the RTS

It is also possible to create an application that contains code in
addition to the standard heap image.  In this case, the code is
compiled into the application but the data are available in code-less
FASL files, as for the native Larceny.  This may seem a little strange
and unnecessary but it simplifies things overall, because scripts for
native Larceny will work unaltered in Petit Larceny.

	> (build-application "petit" <list-of-lop-files>)

(On Win32 the executable name is "petit.exe".)  In addition, one can
just concatenate all these FASL files into a single FASL file that
can be loaded with one command, making it easier to package a lot of
compiled code into an application-like bundle.

A facility built on this is called BUILD-TWOBIT:

	> (build-twobit)

This command compiles all the Twobit source files and creates an
executable "twobit" (or "twobit.exe") that contains the code for
Twobit, as well as FASL files for all these files.

If you build Twobit using BUILD-TWOBIT, and then start "twobit" and
follow the directions above (loading "Util/macosx.sch", say, and then
running LOAD-COMPILER), you will have a development environment with a
compiled compiler.

On some systems it is possible to load compiled Scheme code
dynamically.  A driver routine called COMPILE-FILES compiles a group
of Scheme files into a single shared object and a group of code-less
FASL files; loading the FASL files with LOAD will load and link the
shared object:

	> (compile-files '("fib.sch") "fib.fasl")
	> (load "fib.fasl")
	> (fib 10)
	55

This facility is working but not 100% clean; see working notes below.


PLATFORM SPECIFICS

See HOWTO-WIN32, HOWTO-MACOSX, and HOWTO-UNIX for status on the
various ports.


BOOTSTRAPPING

There is an *example* Makefile called 'bootstrap.mak' that you can use
to build Petit Larceny from C sources.  This requires that you cross
compile to C on some other host.  Cross compilation is supported in
the same build environment as described above; for example, the file
Util/macosx-on-win32.sch was used to cross-compile to C for MacOS X
from a Win32 system.


STATUS
 - Works on Windows 2000 with MetroWerks CodeWarrior.  This port
   actually has a working FFI subsystem!
 - Works on MacOS X 10.1.5 with Apple's tools, compiled as Unix app
 - Peephole optimization is implemented, though off by default


TODO / IN PROGRESS

Petit Larceny on Sparc/Solaris and other big-endian Unix:
 - have defined Util/unix-be.sch and Util/nbuild-param-C-be-unix.sch
 - can load compiler
 - can compile heap image
 - can compile and link RTS
 - RTS loads and runs in heap image
 - above process is portable (enough)
 - can rebuild itself in the interpreter
 - Must fix: Rts/Makefile is a mess because it has too many things 
   in it that need configuring by hand; it is not nearly portable.  
   Much can be done by requiring some non-basic Make system 
   (GNU Make, say) but then Win32 may suffer?  Am working on using
   Larceny for this, see Rts/makefile.sch.
 - Must do: build and test twobit
 - Must do: can we fix dynamic loading of compiled twobit?

Petit Larceny on x86 Linux:
 - Must test this (little endian)

Compatibility packages:
  Must add call-with-binary-input-file and call-with-binary-output-file
  to the compatibility packages?  These are now used by the twobit
  drivers and the heap dumper.  (Do we even care about building under
  other systems any more?)

  Must clean up dumpheap-unix.sch so that it is usable; the rest of the
  system may have diverged (again).  (Works OK on MacOS X and Solaris!)

Primitives:
  - Some primitives (in the 500 series) must be implemented

Peephole optimization:
  - Optimizations have been implemented, not enabled by default
  - Must test the peephole optimizations.  Almost all have been tested already,
    see testpeep.sch in this directory.
  - Must recompile everything with peephole optimization enabled
  - Some test cases it should get right but does not:
       (lambda (v) (vector-ref v 10))
       (lambda (v n) (vector-ref v n))
    In the first case it does not generate code that the peephole optimizer
    is able to match on (because the peephole optimizer does not match well
    on constant indices, because the optimizer removes half of the pattern).
    In the second case the optimizer matches but there are still five
    instructions generated, and a lot of access to the register file, which
    is not all that good, certainly not on RISC systems where all operands
    could be loaded once.
  - Another case it should get right:
        op2         <:fix:fix,3
        branchf     1005,5
    It's sort of stupid to optimize the comparison and then have to generate
    and test a boolean.

Loading compiled code:
  Dynamic loading of objects so that we can compile to FASL without
  having to rebuild the executable:

	> (compile-files '("fib.sch") "fib.fasl") ; in Util/win32.sch
	> (load "fib.fasl")                       ; loads the dll too!
	> (fib 10)
	55

  The basic architecture is to compile a *group* of files into FASL, but
  their code will be dumped into a single shared object.

  The code basically works -- the DLL can be loaded, the code can be run.

  To fix:
  - Must try to build the development environment as FASL.

    This sort of works now, except that:
     - The resulting .c file is 6MB and compilation with optimization
       enabled never completes (CodeWarrior)
     - Incremental recompilation is not possible because of the *one*
       .c file; there is nothing to be incremental about
     - Compiling without optimization works but linking to a dll fails
       on Win32 because the code is missing _memset and __stack_alloc; 
       the former is obvious but the latter may be some sort of MWC rts thing?

    A better solution is to generate separate .c and .obj files but then
    link them all into a dll.  This should not be a problem.

  - Compile-files must probably always recompile all files, not check
    if the obj or c file exists, as it does now
  - Debug info: I'm working on getting debug info into the dll (experimenting
    with -g to mwcc and mwld, have not tested.)

Other performance:
  - Inline allocation for CONS and peepholed MAKE-VECTOR, at least.
  - Consider further peephole optimizations
      
Cleanup:
  - *Maybe* move compile-files into standard driver code?
  - Compile-file should be an alias for compile-files with just one
    input file
  - Compile-files could default the output name to the first name
    in the input list

Bugs to fix:
  - One bug report about heap loader from Brown U?

Test cases to add to test suite:
  - Bignum bug: This would result in a division by zero error:
     (/ 0 4217293152016490)
  - Bignum bug: This used to return an illegal ratnum (both numerator
    and denominator were negative):
       (/ -123234566789000009 -1234512345000)
  - Bignum bug: This would return the wrong sign (should be positive):
      (remainder 3303030303030 -12345566789012)
  - Number bug: expt 0 anything returns 1, but should not, here are tests
    and desired results:
      (expt 0 0) => 1
      (expt 0 2) => 0


PORTABILITY TODO

Apparently the MacOS X system header files define BIG_ENDIAN, so we
might use a different name for Larceny for this macro.


PERFORMANCE TODO

Can use first-class labels under Gnu C, this should be a big win.
