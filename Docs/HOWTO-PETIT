Building and using Petit Larceny
29 August 2003 / lth


HOW TO BUILD PETIT LARCENY AND USE THE BUILD ENVIRONMENT

If you haven't read the build instructions on the web page, do so now.

For the most part Petit Larceny is built by tools written in Scheme,
so you need a working host Scheme system; a version of Petit Larceny
with just the interpreter is sufficient.  See below under
BOOTSTRAPPING if you don't have a working Scheme system.

First things first:

  * You must inspect Rts/Sys/config.h and choose the configuration
    you are building.

  * You will probably need to edit Rts/Makefile to make it fit your
    system -- "make" is used to build the run-time system.

Then start your host Scheme system, change your working directory to
be the Larceny source directory if necessary, and load the appropriate
configuration file for your operating system, currently one of:

	Util/petit-win32.sch
	Util/petit-macosx.sch
	Util/petit-unix-be.sch
	Util/petit-unix-el.sch

These programs sometimes invoke external programs and may place
additional demands on your host system.  Currently all systems need
some version of "make" to be able to build the run-time system, and
will need access to a command interepreter.

The first time you run the build environment you will want to evaluate:

	> (setup-directory-structure)

Whenever you have altered any of the Rts/*.cfg, or the first time you
run the build environment, you will want to evaluate:

	> (build-config-files)

Most of the time you will just load Twobit (you can't load Twobit
until after you have created the directory structure and config files,
which is why it is a separate step):

	> (load-compiler)

and then build the heap image, the runtime system, and finally the
executable:

	> (make-petit-heap)
	> (build-runtime-system)
	> (build-executable)

Other useful commands are:

	> (remove-heap-objects)   ; removes generated files (LAP, LOP, C, OBJ)
	> (remove-rts-objects)    ; removes OBJ files in the Rts tree

It is also possible to create an application that contains more
compiled code than the standard heap image.  In this case, the object
code for your program is linked statically into the Larceny executable
but the program's data are available in code-less FASL files, as for
the native Larceny.  This may seem a little strange and unnecessary
but it simplifies things overall, because scripts for native Larceny
will work unaltered in Petit Larceny.

	> (build-application "petit" <list-of-lop-files>)

(On Win32 the executable name would be "petit.exe".)  The command
above generates an executable called "petit" and a bunch of FASL
files.  For convenience, one can just catenate all these FASL files
into a single FASL file that can be loaded with one command, making it
easier to package a lot of compiled code into an application-like
bundle.

Be aware that BUILD-APPLICATION will create a working file called
"exename.c" in the current directory, for whatever name you choose for
the executable ("petit.c" in the example above).  Do be sure not to
have a file "exename.lop" in the list of files passed to
BUILD-APPLICATION, the .c file generated from the .lop file will be
clobbered and you will see strange link errors.

A facility built on BUILD-APPLICATION is called BUILD-TWOBIT:

	> (build-twobit)

The BUILD-TWOBIT command compiles all the Twobit source files and
creates an executable "twobit" (or "twobit.exe") that contains the
code for Twobit, as well as FASL files for all these files.

If you build Twobit using BUILD-TWOBIT, and then start "twobit" and
follow the directions above (loading "Util/petit-macosx.sch", say, and
then running LOAD-COMPILER), you will have a development environment
with a compiled compiler, suitable mainly for compiler development.
(See a later section for how to turn this into a standalone compiler
for other kinds of development.)

On some systems it is possible to load compiled Scheme code
dynamically.  A driver routine called COMPILE-FILES compiles a group
of Scheme files into a single shared object and a group of code-less
FASL files.  Loading the FASL files with LOAD will load and link the
shared object:

	> (compile-files '("fib.sch") "fib.fasl")
	> (load "fib.fasl")
	> (fib 10)
	55

Note that a single C source file is generated from all the Scheme
source files in the input list.  Be aware that some C compilers have
problems with very large files at high optimization settings.


PLATFORM SPECIFICS

Read the files HOWTO-WIN32, HOWTO-MACOSX, and HOWTO-UNIX for status on
the various ports and special instructions for building on specific
systems.


BOOTSTRAPPING

There is an *example* Makefile called 'bootstrap.mak' that you can use
to build Petit Larceny from C sources.  This requires that you cross
compile to C on some other host.  Cross compilation is supported in
the same build environment as described above; for example, the file
"Util/petit-macosx-on-win32.sch" was used to cross-compile to C for
MacOS X from a Win32 system.


INSTALLING TWOBIT AND LARCENY ON YOUR SYSTEM

Installing Petit Larceny without Twobit is simple:
  (1) Create a suitable directory for Larceny's files, say,
      /usr/lib/larceny
  (2) Copy the Petit Larceny executable and petit.heap to that
      directory
  (3) Create an executable script called 'larceny' in another suitable 
      directory to run Larceny, usually it contains something like this:
        /usr/lib/larceny/petit /usr/lib/larceny/petit.heap
Now type 'larceny' anywhere and you're up and running.

Installing Twobit outside the Larceny build directory is more
complicated, and it requires that Petit Larceny be able to dump a heap
image on your system, which generally means that a program must always
be loaded at the same address every time it is executed.  Systems that
do not obey this rule include the old MacOS and probably most
operating systems on machines without paged memory support --
handhelds, phones, and other embedded-type devices.

Anyway, to create a standalone compiler do the following:

  (1) Create directories /usr/lib/larceny/include and /usr/lib/larceny/lib
  (2) In the development directory, start twobit:
	./twobit -stopcopy
      and load the development environment in the normal manner
      with LOAD-COMPILER.
  (3) Incant
         > (install-twobit "/usr/lib/larceny")
         > (dump-interactive-heap "twobit.heap")
      This copies a bunch of files to your new directories and creates
      a heap image containing twobit, but also changes some global
      settings internally about where twobit will look for include files
      and libraries
  (4) Exit.  There should be a file twobit.heap in the current
      directory.
  (5) Test it by starting thetwobit executable with twobit.heap
      as its argument, then evaluate
         > COMPILE313
      The REPL should print #<PROCEDURE compile313>.
  (6) Exit.  Copy the twobit executable and twobit.heap to /usr/lib/larceny,
      then create another script in /usr/bin called "twobit" which
      contains
        /usr/lib/larceny/twobit /usr/lib/larceny/twobit.heap
      You should now be able to type 'twobit' anywhere, and you should
      be able both to compile to FASL and to create entire applications
      using BUILD-APPLICATION.
