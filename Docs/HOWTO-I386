Information about native Larceny on Intel 386-class systems
15 November 2003 / lth


HOW TO BUILD AND USE.

See HOWTO-PETIT for general information about how to use the build
system.  Rather than loading Util/petit-whatever.sch you load one of
these base files:

    Util/nasm-unix.sch
    Util/nasm-win32.sch     (does not yet exist :-)

The system works like Petit Larceny except that it generates source
files in assembly language (to be processed by the NASM assembler)
rather than source files in C.

Obviously you need to have NASM installed on your system.  It is free
and can be downloaded from http://sourceforge.net/projects/nasm.

Technical details are scattered (too much) across Asm/Intel/README and
files in Rts/Intel.


STATUS.

In development.  Generates code that can be compiled to a heap image,
and Larceny can boot this image.  Works at least in part:

  * Loading and running FIB in the interpreter shows no problems.
    Interpreted FIB(30) is about twice as fast as in Petit Larceny.

  * Loading and running REQUIRE works -- can (require 'fortune)
    and get fortunes.

  * Interpreter can rebuild itself and the heap image to bitwise
    identical images!


PERFORMANCE.

Programs that do a lot of traps to millicode will likely be slower than they
used to be, because there is more state to save and a more costly call protocol
(one indirect and one direct jump, rather than just one direct jump).

One benchmark is the time it takes to load the compiler from the
interpreter (this should not vary much) and the time it takes to
rebuild the system in the interpreter.


TODO.

 - implement exception signalling in Rts/Intel/i386-millicode.asm (important)
 - a few FIXMEs in Rts/Intel/i386-instr.asm (unproblematic)
 - a few OPTIMIZEMEs ditto (ditto)
 - twobit needs to be set up with the right number of hardware registers
 - test, test, test


OTHER NOTES.

Future ideas:
 - put most-used millicode procs at negative offsets from GLOBALS, so that
   short offsets are generated in calling them.  This reduces code size.
 - nasm can generate .bin format files, ie, raw code.  We can use this to 
   create a system with on-line compilation: just dump the code to an asm 
   file in /tmp, assemble it to a .bin, and slurp the object code into a
   code vector in the heap.  There should be very little extra work involved 
   in getting this done, once the rest works.


--- Local Variables: ---
--- mode: text ---
--- indent-tabs-mode: nil ---
--- End: ---
