Petit Larceny status, architecture, etc.
$Id$

1. Status

Where it is known to run
  Architecture         Operating system    Compiler           System name

  SPARC 10             SunOS 4.1.4         gcc 2.8.1          k2
  SPARC Ultra 1        SunOS 5.6           gcc 2.8.1          vega
  Intel 486            Redhat Linux 5.1    gcc 2.8.1 (?)      underground
  Alpha (32-bit mode)  DEC OSF/1 4.0       cc                 carbon
 +PowerPC 601          MacOS 7.6.1         Codewarrior 10     (Mac 7100/66)
 +PowerPC 750          MacOS 8.5.1         Codwarrior Pro 4.1 (Mac G3/350)
 *Intel 486            Windows 95          gcc / cygwin       underground

*=not yet self-hosting on this system
+=not yet fully-compiled self-hosting on this system

Future platforms to test on:
  Architecture         Operating system    Compiler           System name

  SPARC                (any)               lcc (this has worked in the past)
  SPARC                (any)               cc (if we can find it)
  Motorola 68030       MacOS 7.1           ??                 (Mac LC III)
  Intel 486            Windows 95          lcc-win32          underground
  Intel 486            Windows 95          gcc + cygwin       underground
  Pentium              Windows NT 4.0      MSVC++             (josh's machine)
  Intel IA32 class     Windows 95 or NT    Watcom C
  MIPS R3000           Ultrix              cc                 (CCS machine?)
  MIPS R4000 (32-bit)  Irix                cc
  Motorola 68020       AmigaDOS                               (Galen's?)
  Intel IA32 class     MS-DOS              djgpp
  Intel IA32 class     MS-DOS              Watcom C
  Intel IA32 class     Windows 3.1         Watcom C

Known portability issues:
  - Many 32-bit dependencies in the code, most not documented.  This
    complicates portability to 64-bit platforms, because we can't rely
    on having a 32-bit mode available.
  - Assumes that C procedure addresses are at least 4-byte aligned.
    This is not true on Intel platforms with lcc-win32, at least, and
    probably won't be true on the MC68000 and other CISC systems.
  - Assumes that right shift of a signed quantity is an arithmetic shift
    (shifts in sign bit) and that right shift of an unsigned quantity is 
    a logical shift (shifts in zero).  This is true on many compilers but
    is not guaranteed by the standard.
  - Signal handling is just plain difficult to get right in a portable way.
    Most likely more signal handling will need to be written for every
    class of operating systems.  The current system abstracts out the
    signal handling pretty well to facilitate that.


2. Current task (i386 / Linux version)

To do
  - Must take some principled approach to text file format translation,
    see tounix.sh in test/ directory.
  - Must take some principled approach to how compilation is managed
    when compiler is invoked from within Larceny -- what are the
    libraries, etc.  It almost seems preferable to invoke the makefile
    separately to build petit.a / petit.so.  In any case the knowledge
    inside dumpheap-extra.sch about library names and so on does not
    seem like a feature.  For now I have made 'none the default compiler.

  - Must take care to set in_noninterruptible_syscall when
    appropriate in millicode, cf the code in Sparc/cglue.c.

3. Tasks underway

GOLD STANDARD
 - merge in Alpha version, then distribute the resulting code base and
   compile it everywhere: Sparc-sunos, alpha, linux, mac.  Ignore win32
   for the time being.  Make sure GENERIC version works everywhere.

Win32 version
 - LCC-WIN32 doesn't work because it doesn't align procedure addresses.
   Petit Larceny must be fixed.  See below.
 - The OS distinguishes text and binary files (by convention).  We need
   to make this distinction visible on the Scheme level.  See section
   "NEWLINE issue" below.
 - stdio console may have CR-only line termination on input.  Must 
   investigate.
 - Win32 graphical console.

Building
  - Need to develop an interface to Petit Larceny's compilation system to
    allow it to be used conveniently both by me (for further development)
    and by casual users (for casual stuff) without having to implement
    dynamic loading/linking.  One interface is suggested below in the
    section PACKAGING, but needs to be extended/tested.
  - Need to consider formalizing the three-step build process; currently
    the sources use a two-step process.  See dumpheap-extra.sch.  (It
    _may_ make sense to split Lib/makefile.sch into makefile-native.sch
    and makefile-petit.sch.)  Make the split explicit and formalize an
    interface, eg, make-petit-heap followed by make-petit-application
    (which takes optional app name and list of LOP files).  Need a more
    convenient way to compile files to LOP (ie, a shorter name).

NEWLINE issue:
 - Text files have CRLF line termination; i/o subsystem isn't set up
   to handle a #\newline character that is more than one character long.
   The right way to fix this seems one of:
     - have write-char recognize #\newline specially and write CRLF if
       the underlying file is a text file
     - have read-char recognize CRLF specially and return #\newline for
       the pair if the underlying file is a text file
     - implement translation in fill-buffer and flush-buffer to translate
       #\newline to CRLF and vice versa
   Translation in fill-buffer and flush-buffer are attractive because
   they probably incur less overhead overall and because read-char and 
   write-char will continue to work on string ports and other kinds of
   ports.  On the other hand, other ports reading from text sources must
   implement their own translation procedures (or we must expose those
   used by the system).
   See file Experimental/translate-text.sch.
 - Must distinguish between binary files and text files
   - write-char no longer fits all; should really use WRITE-BYTE on
     binary files and WRITE-CHAR on text files.
   - heap dumper really creates a BINARY file
   - FASL and LOP files containing native code are really BINARY files
     (whereas FASL and LOP files containing bytecodes and C code are
     really TEXT files)
   - need new procedures:

      open-binary-input-file
      open-binary-output-file
      with-input-from-binary-file
      with-output-from-binary-file
      read-byte
      write-byte

     READ-BYTE and WRITE-BYTE can also be used on text files but any
     multi-byte representation of a character will be read as several
     individual bytes.  READ-BYTE returns a fixnum and WRITE-BYTE takes
     a fixnum.

     READ, WRITE, DISPLAY, READ-CHAR, WRITE-CHAR, NEWLINE, can also 
     be used on binary files but the representation written for NEWLINE
     is not necessarily the representation used by text files.

Packaging
 - Package twobit.h so that it can be included w/o reference to the
   header files it includes; this makes it easier to compile
   standalone (like Gambit).  Use the program Util/fold-includes.sch 
   to create the packaged file.
 - Setup command lines to reference the "packaged" twobit.h.
 - Setup command lines in dumpheap-extra.c to reference the full
   path of libpetit.so so that the executable can be moved.
   There's an argument to be made for LD_LIBRARY_PATH also.  
   In any case the current setup is the wrong thing.

   A somewhat general design for these things:

      A directory ${PETIT}
      Subdirs     ${PETIT}/bin        script goes here
                  ${PETIT}/lib        executables and binaries go here
                  ${PETIT}/include    twobit.h goes here

   When petit-larceny.so is built, it must reference libpetit.so
   in the correct location.  Thus, the install process is three-step:
   copy the libraries and headers to the correct location, then
   link petit-larceny.so, copy it to the right place, and finally
   link petit-larceny.

   Since the C files are portable, it is possible to distribute a set
   of C files and a Makefile.  (However, there are really two sets of
   C files -- one for each endianness, and more to come, for different
   word sizes.)

   The problem is really that different operating systems search for
   shared libraries in different ways.  (The MacOS got it right: look
   in the application directory first, then in increasingly public
   places.)  So the install process will vary from system to system.
   Can't be helped.  Would be helpful to get the major systems fairly
   right, with a small number of variations:

          Unix with shared library paths hardwired
          Unix with LD_LIBRARY_PATH
          Unix with static libraries
          Win32 with DLLs
          MacOS with dynamic libraries
          MacOS with static libraries

   It is possible to build a standard distribution and then override paths
   and so on with interpreted Scheme code before dumping twobit.heap... or
   overrides can go in ".larceny".  Neat!  (As long as the system is set up
   for it.)  It's still necessary to put things in the right places before
   building, though.

   I guess the two obvious choices are to use a hard path and no path --
   in the former case, we have security against LD_LIBRARY_PATH; in the
   latter, we have some flexibility.

   An interface:
     *petit-include-directories*      a list of directories to search for
                                      twobit.h and files it includes; 
                                      for the compiler.
     *petit-library-directory*        a directory in which libraries are
                                      stored; for the linker.

   The trick is to make it simple on most systems while not overly 
   cumbersome on systems where we could obviously do better.

Performance
 - Code quality -- see separate section.
 - Use -O or -O3?  The former results in 25% shorter C compile times, and
   in smaller object code.  What is performance impact of compiled code?
   (Select benchmarks carefully.)
 - Compare quality of -O to quality produced by LCC.
 - Jump discipline on this machine? (Select benchmarks carefully)
 - Heap dumper performance
   - -O vs -O3 (see separate item)
   - cost of reading/dumping/writing
   - code quality (avoid trips thru trampoline)

Missing features
 - How to use the FFI (essentially a dynamic-loading problem too).
 - Reasonable documentation of architecture, compilation strategies,
   and so on.
 - Dynamic loading on Unix.
 - Dynamic loading on MacOS.

Quality-of-implementation things; portability
 - Architecture for using C compiler and Linker, and a published way
   of setting it up for a new system.
 - Need to distribute a list of the names of files to be compiled and
   linked so that people on non-Unix systems can setup their compiler to
   compile the generated code.
 - Running _build_ must also make cdefs.h and those files now created by
   the compilation of libpetit.so, because compilation of the generated
   C files requires them to be present.
   (Not an issue for the common user, as cdefs.h is folded into the
   twobit.h that the user gets.)
 - Heap images should contain information about binary format in
   addition to version, eg, PETIT-BE, PETIT-EL, SPARC-NATIVE, ...
 - Change filenames so that there are no duplicate file names in
   the files compiled for the basic heap.  This fixes the problem
   with Codewarrior on Mac and .a archives on Unix.
 - Run-time libraries, notably I/O-related [Non-Unix OSs only]
 - Not all systems guarantee that procedure pointers look like fixnums.
   This will break Petit Larceny (it already breaks on Win32 with LCC).

   I see two general solutions:

    - Split a code vector pointer into two words, the high part and the
      low part: (procedure*)(proc[0] + prc[1] >> 2)().  Cost: 
      two loads, two ALU instructions.
    - Store a jump table index in the code vector slot and always jump
      through the table: (table[proc[0]])()  Cost: two loads, and probably
      some code to setup the pointer to the table unless this can be
      cached in a register.  It's probably a wash, relative to the other
      technique.

   The second technique is desirable because it does not require procedure
   pointers to fit into a word.  Thus Larceny may be portable to systems
   where code pointers have more bits, like capability-based systems such
   as the IBM AS/400.  (These systems would still have to have data words
   with reasonable semantics.)

   On the other hand the second technique is less desirable because it
   requires a single table for all code pointers, which we don't have --
   we want to have any number of tables (currently two, more when we
   get dynamic loading).  That would complicate compilation, loading,
   linking, and so on -- a mess.

Build system
 - Cross compilation from a host of one endianness to a target of another
   is not well supported.  There is some hackish code in 
   Compat/Larceny/compat2.sch that makes it work: essentially, the
   ->bytevector routines must produce data that are of appropriate 
   endianness for the target.  A better way might be for the heap dumper
   to receive native bytevector layout and convert to the target layout.

Alpha
 - Note the ugly argv[] hack at the beginning of main() in larceny.c --
   presumably this can be fixed somehow.  Must find and read the C 
   Programmer's Manual.

Win32
 - Make it work
 - NEWLINE issue
 - binary vs text files (for self-hosting)

Alternative branch technique based on SWITCH statement
 - Used by MIT Scheme's C back-end, projected use by Kawa for complete
   tail-recursion optimization.
 - Every MAL procedure is compiled into a single C procedure where the
   code is wrapped in a SWITCH statement; every label is a SWITCH case
   and the case number 0 is always the entry point:
      RTYPE twobit_compiled_xyzzy( int entrypoint, CONT_PARAMS )
      {  switch (entrypoint) {
           case 0: ...A... ; break;
           case 1001 : ...B... ; break;   /* L1001 */
           case 1002: ...C...; break;
         }
      }
 - A continuation is a function pointer + an entry point: a two-word
   structure:
      typedef struct {
        cont_fn_t f;
        int l;
      } cont_t;
 - Several optimizations reduce the amount of information stored:
   - in a procedure, the entry point label is implicit (always 0), so
     only the function pointer need be stored in the procedure
   - in a stack frame, the procedure is implicit (always R0), so only
     the entry point label need be stored in the return address slot
 - There are no programmatic ways to manipulate entry points short
   of setrtn and return, so we never need pass around the packet
   on the VM level -- only the VM implementation needs to deal
   with the cont_t structure.
 - Returning a cont_t structure may not be efficient but is
   straightforward.
 - Global control flow: either return a cont_t to the dispatch loop
   or call the continuation with the correct label; all three control
   flow disciplines can be combined with the SWITCH technique.
 - Local control flow: either set the entrypoint value and jump to
   the top to let the switch handle it, or use a GOTO directly.  Should
   probably allow both techniques to be able to measure performance
   impact.
 - Can hide the implementation:
      RTYPE twobit_compiled_xyzzy( CONT_PARAMS )
      { twobit_prologue();
        ...A...
        twobit_label( 1001 );
        ...B...
        twobit_label( 1002 );
        ...C...
        twobit_epilogue();
      }
  It is possible to define these macros so that they can accomodate all
  the control flow techniques; thus, no regeneration of code is necessary
  to switch techniques, only recompilation.
   
Code generation quality [order of priority and expected payoff]
 - Introduce peephole optimizations in the assembler.
 - Cache STKP for speedup (maybe -- time both ways).
 - Deal with fallthrough issue in a reasonable way.
 - Can introduce a twobit_label macro that would be an implicit 
   function split.  It would make the code look a lot more natural, 
   and with the twobit_prologue() and a corresponding twobit_epilogue()
   [more properly called twobit_begin() and twobit_end()] it would 
   allow the use of the switch() technique.


--- Older stuff ---

This is the old TODO-PETIT

Compiling
 - Should get LCC to use GNU as, or turn off -g during LCC compilation 
   because of Solaris assembler's massive lossage on dealing with the amount 
   of LCC debug info.

Testing
 - Must test with Boehm collector.
 - Must run GC tests and other test suite.

Usability and portability
 - Compilation technology
   - Package twobit.h so that it can be included w/o reference to the
     header files it includes; this makes it easier to compile
     standalone (like Gambit).
 - Portability
   - Portability issues with the use of the use of the C compiler and
     linker.  This includes name *and location* of libpetit.so
   - Portability issues with the use of 'cat' to build heap image under Unix.
   - Need a mechanism to allow static linking (for the sake of portability).
     However, .a files can't have multiple files with the same basename,
     so we must be careful -- static linking can't obviously rely on an 
     archive.  This is annoying.  "Unix: There Has Got To Be a Better Way."
 - MacOS support
 - Windows support
 - Run-time libraries, notably I/O-related [Non-Unix OSs only]

Missing features
 - SWITCH-based jump discipline
 - Dynamic loading of compiled files, on platforms where it makes sense.
 - Foreign function interface
   - How to use the FFI (essentially a dynamic-loading problem)
   - how to generate FFI call code in the compiler.  See separate
     section below.

Code generation quality [order of priority and expected payoff]
 - Introduce peephole optimizations in the assembler.
 - Cache STKP for speedup (maybe -- time both ways).
 - Deal with fallthrough issue in a reasonable way.
 - Can introduce a twobit_label macro that would be an implicit 
   function split.  It would make the code look a lot more natural, 
   and with the twobit_prologue() and a corresponding twobit_epilogue()
   [more properly called twobit_begin() and twobit_end()] it would 
   allow the use of the switch() technique.

Foreign function interface
  There's currently no support for FFI in the compiler, but in a C
  backend, there must be such support.  One possibility is to introduce
  a new primop that takes a signature and effectively compiles into a 
  call to a procedure with that signature.  Example: PLUS is a foreign
  function that takes two ints and return an int.  Thus the syntax

	(foreign-procedure "plus" (int int) int)

  can be compiled into something like

	const	"plus"
	op1	ffi-get-address
	setreg	1
	lambda *, 1, #f
		args=	2
		lexical	1,1
		op2imm	ffi-call, ((int int) int)
		return
	return

  The inner procedure would then turn into something like this:

	twobit_argseq( 2 );
	twobit_lexical( 1, 1 );
        int _tmp1 = object2nativeint( reg(1) );  /* unchecked */
        int _tmp2 = object2nativeint( reg(2) );  /* unchecked */
        int _tmp3 = ((int(*)(int,int))RESULT)( _tmp1, _tmp );
        RESULT = nativeint2object( _tmp3 );
        twobit_return();

  It's not straightforward to do this since we must guarantee that the
  compiler does not change registers 1 .. n in the inner procedure
  above; the compiler may believe they are dead and do something silly.

  One possible hack is to generate in-line MAL that is not passed through
  any compiler stages, but this requires -- of course -- another change
  to the compiler.
