; -*- mode: m4 -*-
;
; Copyright 2004 Lars T Hansen
;
; Documentation for the PowerPC implementation of Larceny;
; PowerPC machine description.
;
; $Id$
;
;
; The general idea.
;
; Asm/PowerPC/pass5p2-m4.sch translates LAP code to a simple
; textual form, like this:
;     T_LEXICAL(1)
;     T_SETREG(3)
;     T_LEXICAL(2)
;     T_OP2_61(3)   ; +
; Each line is actually a macro call, and each macro expands
; to some number of PowerPC assembly instructions.  The file
; that is created by the Larceny assembler is run through M4
; first and then through a PowerPC assembler, creating a program
; in PowerPC machine language.
;
; The instruction macros are defined in ppc-instr.asm.
;
; It is not necessary to use M4 macros for this, since the assembler
; could emit textual assembly language instead.  It is really a
; holdover from the x86 back-end, where the NASM macro assembler could
; also do some optimization, and from the C back-end, where it is
; very clean to emit macro calls rather than raw C code.  On the
; other hand, it does provide very clearly separated layers.
;
;
; Register usage and so on.
;
; Larceny is currently adapted to the MacOS X ABI only.  See below
; for a summary of the ABI conventions.  There are probably few
; assumptions on the ABI, and they can probably be adapted to by changing
; the scheme entry and exit points in the file ppc-millicode.asm.
;
; r0 is mapped to TEMPX: it is special, because r0 is special on the PPC
; r1 is not used (the ABI uses it for the C stack pointer)
; r2 is mapped to TEMP
; r3 is mapped to SECOND
; r4 is mapped to TIMER
; r5 is mapped to RESULT
; r6 is mapped to GLOBALS
; r7 is mapped to CONT
; r8 is mapped to HEAP
; r9-r31 are mapped to REG0-REG22
; lr is used for non-tail calls (when possible)
; ctr is used for tail calls
;
; THIRD is stored in the software register file
; REG23-REG31 are stored in the software register file
;
; Even though the PowerPC has plenty of real registers for Larceny,
; I've decided to keep the register count at 32 to keep differences
; with other versions at a minimum.
;
; The x86 back-end maps TEMP and SECOND to the same register to
; save registers; it would be possible to do the same thing here.
;
;
; Globals table and millicode calls.
;
; The globals table is nonmoveable and contains run-time system data
; followed by a branch table for millicode entry points.  Generated
; code is made position independent by branching indirectly via the
; GLOBALS register into the branch table, which then branches into
; the millicode proper.  In unoptimized form a millicode call will
; therefore look something like this:
;     addi   TEMPX, GLOBALS, M_ADD ; compute address in branch table
;     mtctr  TEMPX                 ; move it to CTR
;     bcctrl 20, 31                ; branch and link through CTR
;
;
; Millicode.
;
; Millicode procedures are implemented in assembler in ppc-millicode.asm.
; For the sake of simplicity however, most millicode procedures are
; simply stubs that branch into the corresponding C versions.  The
; overhead of calling C, especially on a register-rich architecture
; like the PowerPC, is substantial.  The system can be made faster by
; reimplementing millicode procedures in assembly language (or at least
; by reimplementing them partly).
;
;
; Continuable and noncontinuable exceptions.
;
; Obviously, exceptions like timer, heap overflow, and stack overflow
; and underflow are continuable.
;
; However, there is not yet any coherent strategy for making errors
; continuable, so basically none are, and there is no reason for
; code to be emitted to retry an operation following an error.
;
;
; MacOS X ABI summary.
;
; GPR0 is a temp
; GPR1 holds C stack pointer
; GPR2 is a temp
; GPR3 - GPR10 are used for parameter passing
; GPR3 is used for the C return value
; GPR11 is a temp
; GPR12 is used when calling dynamically linked code, but is 
;   otherwise a temp
;
; GPR1 and GPR13 - GPR30 are callee-saves, all others are caller-saves
;
; FPR0 is a temp
; FPR1 - FPR13 are used for parameter passing
;
; FPR14 - FPR31 are callee-saves, all others are caller-saves
;
; CR2 - CR4 are callee-saves, others are caller-saves
;
; LR and CTR are caller-saves

changecom(`;')

define(`wordsize', 4)
define(`object_align', 8)
define(`code_align', 4)

define(`TEMPX',`r0')
define(`TEMP', `r2')
define(`SECOND', `r3')
define(`TIMER',`r4')
define(`RESULT', `r5')
define(`GLOBALS', `r6')
define(`CONT', `r7')
define(`HEAP', `r8')
define(`REG0',`r9')
define(`REG1',`r10')
define(`REG2',`r11')
define(`REG3',`r12')
define(`REG4',`r13')
define(`REG5',`r14')
define(`REG6',`r15')
define(`REG7',`r16')
define(`REG8',`r17')
define(`REG9',`r18')
define(`REG10',`r19')
define(`REG11',`r20')
define(`REG12',`r21')
define(`REG13',`r22')
define(`REG14',`r23')
define(`REG15',`r24')
define(`REG16',`r25')
define(`REG17',`r26')
define(`REG18',`r27')
define(`REG19',`r28')
define(`REG20',`r29')
define(`REG21',`r30')
define(`REG22',`r31')

define(`FIRST_HWREG',0)
define(`LAST_HWREG',22)

define(`STK_OVERHEAD',12)
define(`STK_RETADDR',4)
define(`STK_REG0',12)

include(`config.ah')
include(`asmdefs.ah')

define(`LASTREG',31)

define(`PROC_OVERHEAD_WORDS',2)                  ; code and constants
define(`PROC_CONSTVECTOR',CONSTVECTOR)           ; byte offset
define(`PROC_CODEVECTOR_NATIVE',CODEVECTOR)      ; byte offset
define(`PROC_REG0',12)                           ; byte offset

define(`EX_PROCEDURE_REF', EX_PREF)
define(`EX_MAKE_BYTEVECTOR', EX_MKBVL)           ; FIXME: bogus
define(`EX_BYTEVECTOR_LENGTH', EX_BVLEN)
define(`EX_BYTEVECTOR_LIKE_LENGTH', EX_BVLLEN)
define(`EX_BYTEVECTOR_LIKE_REF', EX_BVLREF)
define(`EX_BYTEVECTOR_LIKE_SET', EX_BVLSET)
define(`EX_MAKE_STRING', EX_MKBVL)	         ; FIXME: bogus
define(`EX_STRING_LENGTH', EX_SLEN)
define(`EX_STRING_REF', EX_SREF)
define(`EX_STRING_SET', EX_SSET)
define(`EX_MAKE_VECTOR', EX_MKVL)                ; FIXME: bogus
define(`EX_VECTOR_LENGTH', EX_VLEN)
define(`EX_VECTOR_REF', EX_VREF)
define(`EX_VECTOR_SET', EX_VSET)
define(`EX_VECTOR_LIKE_LENGTH', EX_VLLEN)
define(`EX_VECTOR_LIKE_REF', EX_VLREF)
define(`EX_VECTOR_LIKE_SET', EX_VLSET)
define(`EX_BYTEVECTOR_REF', EX_BVREF)
define(`EX_BYTEVECTOR_SET', EX_BVSET)
define(`EX_MAKE_PROCEDURE', EX_MKVL)	         ; FIXME: bogus
define(`EX_PROCEDURE_LENGTH', EX_PLEN)
define(`EX_PROCEDURE_REF', EX_PREF)
define(`EX_PROCEDURE_SET', EX_PSET)

; eof
