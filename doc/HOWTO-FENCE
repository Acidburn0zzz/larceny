2 August 2012 / lth@acm.org
23 August 2015 / WillClinger (updated status)


Overview.

This file contains some information about the Fence platform for
Larceny, and for native ports built on Fence.  The Fence is a
"platform-independent platform".

The Fence assembler is machine independent and takes a high-level
intermediate code (MacScheme assembly instructions with many primitive
operations) and translates it to a low-level intermediate code.  The
low-level intermediate code is called the Cant; it is at the level of
a real CPU.  The Cant assembler, in turn, is machine-dependent and
translates Cant to machine code for a specific target machine.

The Fence assembler supports many optimizations in a portable way and
generates good code.  In particular, it open-codes many primitives,
translates the rest to millicode calls, and performs many useful
peephole optimizations.  All this code will work with any platform
built on Fence/Cant without further work required.

A simple Cant implementation (minimally about 500 lines of Scheme code
and 200 lines of assembler in the millicode layer, see the last
section of this document) will provide decent performance.  An
optimizing Cant implementation will provide good performance, at least
on systems that are not completely register-starved.

The Cant instruction set is defined at the end of
Asm/Fence/pass5p2.sch.  Some assumptions and simplifications are
documented at the head of that file.

At the time of writing one Cant implementation is operational, for the
32-bit ARM instruction set on the ARMv7-A CPU.


Quick start for developers.

The build procedure is standard; see HOWTO-BUILD for the details.  I
use the following command for setting up the build system, there is at
present no "softfp" target but one is easy to create.

  > (setup 'target: 'linux-arm-el-hardfp 'native)


Status, 23 April 2015:

- The little-endian ARM-32 Cant implementation is good enough for
  Larceny to self-host on Arm Linux, with flat4 strings.  It is
  possible to dump larceny.heap and run with the compiler installed as
  the evaluator.  Basically the port appears to be mostly working and
  the code is decent.

- Peephole optimizations have been ported from IAssassin.  There is an
  ARM-specific optimizer for branch elimination and an ARM
  disassembler that eases debugging.

- Crashers (details down below, after bugs and other items)
   - build process may segfault while loading src/Asm/Shared/dumpheap.sch
        (can use interpreter for build if this becomes too frequent)
   - test/Compiler will crash with jump to 0x0
   - test/R7RS/Lib case-lambda tests crash with illegal instruction
   - test/R7RS/Numbers/clisp-number-tests.sps segfaults reading source code
   - test/Benchmarking/R7RS destruc and sum1 may crash with illegal instruction

- Tests passed
   - System can rebuild its heap in both interpreted and compiled mode
     (loading from fasl).
   - Reloading the development system in larceny.heap from source and
     rebuilding the heap works (usually)
   - test/Benchmarking/R7RS (except destruc and sum1, which crash sometimes)
   - test/Jaffer
   - test/Lib
   - test/Stress
   - test/R6RS
   - test/R7RS/Lib (except case-lambda tests)

- Tests NOT passed (details down below, after bugs and other items)
   - test/Compiler (crashes reliably)
   - test/GC
   - test/FFI (no FFI)
   - test/R7RS/Lib case-lambda tests (crashes reliably)
   - test/R7RS/Numbers/clisp-number-tests.sps (crashes reliably)

Non-filed bugs and other to-do items:

- BUG (possibly very old, OK to just file the bug):

  Looks like the stop-and-copy collector will never collect in
  response to a stack overflow, but always expand the heap: passing 0
  to collect_if_no_room() means it will always return 0 (no
  collection).  Passing STACK_ROOM would have been more appropriate.

- Lars has been rebuilding heaps on the ARM device using interpreter.
  Will has been rebuilding heaps under Arch Linux ARM using compiler.
   - Goal: bitwise identical heap

- fence-millicode.c: mc_alloc_bv: some magic to "align" the bytevector
  so that it is better for code.  Probably x86-specific but lacking a
  proper ifdef and reasonable motivation.  There is similar code
  lurking in cheney.c (at least) in forward(), also not ifdef'd.

- Need to work around the use of MOVT in order to run on the ARMv6
  CPU.  The ARM11 implementation is popular (eg Raspberry Pi, many
  existing devices) and that uses the ARMv6 architecture.

- Should get Petit Larceny running under ARM Linux.  That would help
  to distinguish bugs in the ARM code generator from bugs in C code.


Bugs.

- Timer issues:

  There's a workaround in the Fence millicode for a problem seen on
  ARM where disable_interrupts() would return a large negative number
  or zero.  The underlying bug is not known, but it might be a problem
  (discovered late) where a stale enregistered value was used after
  the return from a timer trap.

  Need to retest this now, when the bug has been fixed.


Larceny bugs to file:

- The test suite in test/Lib fails with an error in the Record tests
  if run twice in the same system ("nongenerative record type").

- In src/Lib/Arch/Fence/toplevel-target.sch and primops.sch there are
  commented-out definitions of eg fx+, fx-, fx* -- these are disabled
  because the R6RS mandated specific exceptions when these operations
  overflow or are given non-fixnum arguments.  R6RS-compatible (hence
  slow) definitions are found in Lib/Common/fx.sch and in
  Compiler/common.imp.sch

- There is no primitive support for bitwise-and, etc, used in eg
  string->utf8 and utf8->string, but it does not seem that it would be
  hard to add fixnum fast cases?


Other optimization items and concerns.

- Performance: No performance testing has been done.  Performance
  should be good when we stay in native code; bad when we trap to
  millicode because the millicode traps to C in almost all cases,
  notably for generic arithmetic.

  * According to singled-threaded GeekBench, our 3.6 GHz i7-4790
    is about 4 times as fast as our 2.0 GHz Exynos 5800 (ARMv7A).
    Eyeballing R7RS benchmark results, Will thinks the Fence/ARM
    code generator is doing pretty well:

    the i7 is roughly 4 to 5 times as fast on tak, fib, sum
    the i7 is 10 to 17 times as fast on fibfp, sumfp, fft, nucleic, mbrot
        (because the IAssassin millicode is bummed for flonums)
    the i7 is 6 to 25 times as fast on cat, tail, wc, read1, slatex
        (io-intensive; read1 is the 25x outlier, attributable to the
        SSD vs micro SD mismatch)
    the i7 is 4 to 10 times as fast on nboyer, sboyer, gcbench, mperm
        (gc-intensive, where the i7's 8 MB L3 cache should help)

- Asm/Fence/*.sch

  * Search for TODO in all these files to locate opportunities for
    performance tweaks (better instruction selection, better
    strategies) and some other spots that may need attention.

- Code size remains a concern; ARM-32 is about as bad as Sparc.

- It would be better for both ARM and x86 if the value for UNDEFINED
  could be represented in 8 bits.  Since the low two bits are 10 we
  can't use a shifted constant on ARM, so it has to be a byte constant.
  The payoff is smaller code when checking for undefined globals.
  Unfortunately it looks like the immediate space does not have room for
  that encoding.

  It is possible to define undefined to mean imm.misc + (0 << 8)
  instead of imm.misc + (3 << 8) as now.  Nobody uses the former value.

  Measurements shows that that would reduce the ARM heap by 42904 bytes.
  Probably worth doing, eventually.


How to port Larceny using Fence/Cant.

TO BE WRITTEN.


------------------------------------------------------------

Some crashes are reliable, while others are intermittent.

  WHY SHOULD ANYTHING BE NONDETERMINISTIC?

     - GC is not time-based.  (or wasn't, before).
        (Some gc activity is now time-based, and timer interrupts
        may be nondeterministic as well.  Timer interrupts based
        entirely on the software countdown timer produced too much
        variation for scheduling tasks in the regional collector;
        this was solved by using a rather short countdown interval
        while ignoring countdown interrupts that occurred too soon
        after the previous scheduling interrupt, as determined by
        the operating system's notion of the actual time.)
     - Heap addresses as a result of mmap?
        (Yes, these are nondeterministic.  See below.)
     - If icache flush, how?  Surely not by the program moving
       between cores, we must assume the OS takes care of that.
       (If it's an icache flush bug it's something that is "random"
       because the program is sometimes moved, sometimes not, and
       when it is not we have a bug.)  Affinity can be controlled:
       http://unix.stackexchange.com/questions/23106/limit-process-to-one-cpu-core

  Heap addresses are indeed not stable.  Here are four consecutive
  invocations with larceny.heap (first expression after start):

     > (syscall 36 (cons 1 2))
     3055912328

     > (syscall 36 (cons 1 2))
     3055285640

     > (syscall 36 (cons 1 2))
     3055338888

     > (syscall 36 (cons 1 2))
     3055203720

  Nondeterministic heap addresses in Windows 7 helped us to find
  long-standing latent bugs in alloc.c and memmgr.c; see these
  commits from 24 and 26 February 2015:

    532461822a157d67c5048daf95df38b5d6faf8df
    d90f165d98a7250c1425a4b5309727f19467a36e

------------------------------------------------------------

Test suites that do not pass.

The tests in test/Compiler do NOT pass, instead we crash after a while:

     >>> benchmark-mode off
     >> Compiling p2tests
     >> Compiling p4tests
     >> Compiling primtests

     >> Loading p2tests
     Illegal instruction

  This is not directly repeatable, though when I run larceny under GDB
  with the compiler tests I hit other crashes (branch to zero in this
  case).  This might be the offending code (from LR), the offending
  call marked with **:

   0xb651d1b8:	beq	0xb651d1dc
   0xb651d1bc:	movw	r11, #8
   0xb651d1c0:	ldr	r0, [r5, #9]
   0xb651d1c4:	str	r11, [r0, #-1]
   0xb651d1c8:	tst	r11, #1
   0xb651d1cc:	movne	r1, r11
   0xb651d1d0:	addne	r12, r2, #564	; 0x234
   0xb651d1d4:	blxne	r12
   0xb651d1d8:	b	0xb651d1e0
   0xb651d1dc:	movw	r0, #278	; 0x116
   0xb651d1e0:	movw	r0, #4
   0xb651d1e4:	cmp	r0, r7
   0xb651d1e8:	movwlt	r1, #4
   0xb651d1ec:	addlt	r11, r10, r1
   0xb651d1f0:	ldrlt	r11, [r11, #1]
   0xb651d1f4:	movlt	r0, r6
   0xb651d1f8:	movlt	r1, r11
   0xb651d1fc:	addlt	r12, r2, #616	; 0x268
   0xb651d200:	bge	0xb651d300
** 0xb651d204:	blx	r12
   0xb651d208:	cmp	r0, #2
   0xb651d20c:	beq	0xb651d268
   0xb651d210:	ldr	r4, [r2, #196]	; 0xc4
   0xb651d214:	sub	r3, r3, #16
   0xb651d218:	cmp	r3, r4
   0xb651d21c:	bhi	0xb651d230
   0xb651d220:	add	r3, r3, #16
   0xb651d224:	add	r12, r2, #520	; 0x208
   0xb651d228:	blx	r12
   0xb651d22c:	b	0xb651d210

  r12 has the value 0x10.  Looks like the optimizer has been here,
  look at that line of "lt" instructions.  r0 is RESULT, r7 is REG2.
  r7 has the value 12.  However, r12 != r2 + 616, so I'm not sure.

  Yow, this crash is repeatable within GDB using current compiled
  files - same crash address, same register contents.

  (Observe heap addresses with the high bit set, this could be a
   source of errors.)

  CSPR is 80070010 which I think means that neither Z, C, or V are
  set, ergo not "less than", ergo we might have arrived at the
  instruction from a jump.  But the value in r0 definitely suggests that
  the mov r0 <- r6 is performed since r6 has the value 0x10 and
  r0 should not.  And then, yet, r12 != r2+616.  The values of r1 and
  r11 are also not aligned.

  The instruction sequence is a trap to globals.  0x268 is not very far
  into the table I think, each entry point is quite large (probably a
  design flaw).

  It looks like a red herring - probably the LR register is the last
  millicode call, we could be anywhere after that.  The code leads
  to a return.

  Anyway, to repro:

    $ cd test/Compiler
    $ gdb ../../larceny.bin
    (gdb) run -heap ../../larceny.heap
    > (load "run-tests.sch")
    > (run-compiler-tests)

  Crashes in the local-optimizations off case, with a segv.  LR=0xb651d208.

The GC tests do NOT pass:

   - Benchmark runner just hangs, no diagnosis yet.
     It could be the missing write barrier or whatever.
     It hangs hard, ^C does not kill it (from within *shell*),
     though sending a HUP does.  It does not use any CPU, very strange.


----------------------------------------

Instruction cache flushing on ARM and elsewhere.

Apparently ARM can use the same flushing method as on Sparc, where we
flush individual addresses / cache lines as we generate code or copy
bytevectors.  But the instructions to perform the flushing are
privileged, so a system call is required.  On Linux, there is a system
call "clear_cache" to clear a range of addresses in the instruction
cache, but some noise on the web indicates that it is not properly
implemented in libc on all Android platforms.  Right now
fence-driver.c makes the system call with inline assembler but this
could be investigated further.
