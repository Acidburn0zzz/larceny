2 August 2012 / lth@acm.org


Overview.

This file contains some information about the Fence platform for
Larceny, and for native ports built on Fence.  The Fence is a
"platform-independent platform".

The Fence assembler is machine independent and takes a high-level
intermediate code (MacScheme assembly instructions with many primitive
operations) and translates it to a low-level intermediate code.  The
low-level intermediate code is called the Cant; it is at the level of
a real CPU.  The Cant assembler, in turn, is machine-dependent and
translates Cant to machine code for a specific target machine.

The Fence assembler supports many optimizations in a portable way and
generates good code.  In particular, it open-codes many primitives,
translates the rest to millicode calls, and performs many useful
peephole optimizations.  All this code will work with any platform
built on Fence/Cant without further work required.

A simple Cant implementation (minimally about 500 lines of Scheme code
and 200 lines of assembler in the millicode layer, see the last
section of this document) will provide decent performance.  An
optimizing Cant implementation will provide good performance, at least
on systems that are not completely register-starved.

The Cant instruction set is defined at the end of
Asm/Fence/pass5p2.sch.  Some assumptions and simplifications are
documented at the head of that file.

At the time of writing one Cant implementation is operational, for the
32-bit ARM instruction set on the ARMv7-A CPU.


Quick start for developers.

The build procedure is standard, see HOWTO-BUILD for the details.  I
use the following command for setting up the build system, there is at
present no "softfp" target but one is easy to create.

  > (setup 'target: 'linux-arm-el-hardfp 'native)


Status, 7 February 2015:

- The little-endian ARM-32 Cant implementation is good enough for
  Larceny to self-host on Arm Linux, with flat4 strings.  It is
  possible to dump larceny.heap and run with the compiler installed as
  the evaluator.  Basically the port appears to be working and the
  code is decent.

- Peephole optimizations have been ported from IAssassin.  There is an
  ARM-specific optimizer for branch elimination and an ARM
  disassembler that eases debugging.

- Tests passed
   - System can rebuild its heap in both interpreted and compiled mode
     (loading from fasl).
   - Reloading the development system in larceny.heap from source and
     rebuilding the heap works
   - The test suite in test/Lib passes


To-do, roughly in decreasing order of importance.

- BUG (possibly very old, OK to just file the bug):

  Looks like the stop-and-copy collector will never collect in
  response to a stack overflow, but always expand the heap: passing 0
  to collect_if_no_room() means it will always return 0 (no
  collection).  Passing STACK_ROOM would have been more appropriate.

- Currently rebuilding heap on the device using interpreter.
   - Goal: bitwise identical heap

- fence-millicode.c: mc_alloc_bv: some magic to "align" the bytevector
  so that it is better for code.  Probably x86-specific but lacking a
  proper ifdef and reasonable motivation.  There is similar code
  lurking in cheney.c (at least) in forward(), also not ifdef'd.

- The FFI has not yet been implemented for ARM

- Integrate the ARM disassembler with disassemble-file, etc.  The FASL
  format has changed a bit so there's surgery to be done to handle
  FASL files.

- Asm/Fence/*.sch

  * Search for TODO in all these files to locate opportunities for
    performance tweaks (better instruction selection, better
    strategies) and some other spots that may need attention.

- Need to work around the use of MOVT in order to run on the ARMv6
  CPU.  The ARM11 implementation is popular (eg Raspberry Pi, many
  existing devices) and that uses the ARMv6 architecture.

- The flat1 string representation has not been tested at all.

- Performance: No performance testing has been done.  Performance
  should be good when we stay in native code; bad when we trap to
  millicode because the millicode traps to C in almost all cases,
  notably for generic arithmetic.

- The test suite in test/Lib fails with an error in the Record tests
  if run twice in the same system ("nongenerative record type").
  This could be by design but needs to be investigated.


Bugs.

- Inline allocation issues:

  The Fence assembler does not consistently emit code to take into
  account any stack red zone ("sce_buffer").

- Write barrier issues:

  The Fence assembler only emits code for the "simple" barrier
  (pointer check and then a call to partial_barrier), no code for the
  full barrier.

  The Fence millicode has been configured with
  SSB_ENQUEUE_OFFSET_AS_FIXNUM=0 because the calls to the barrier do
  not set up THIRD to hold the offset.  This is related to the
  previous problem.

- Timer issues:

  There's a workaround in the Fence millicode for a problem seen on
  ARM where disable_interrupts() would return a large negative number
  or zero.  The underlying bug is not known, but it might be a problem
  (discovered late) where a stale enregistered value was used after
  the return from a timer trap.

  Need to retest this now, when the bug has been fixed.


Larceny bugs to file:

- In src/Lib/Arch/Fence/toplevel-target.sch and primops.sch there are
  commented-out definitions of eg fx+, fx-, fx* -- not clear why these
  are disabled, the code comes from the IAssassin port.  Must
  investigate.  There are alternate (and slow) definitions in
  Lib/Common/fx.sch.

- There is no primitive support for bitwise-and, etc, used in eg
  string->utf8 and utf8->string, but it does not seem that it would be
  hard to add fixnum fast cases?

- There's a Twobit "bug" that's annoying, where it performs a
  dead store of an intermediate boolean result, effectively disabling
  some peephole optimization of boolean evaluation for control, eg in

    (if (< x y) a b)

  which compiles as this:

    ((global b)
     (setreg 5)
     (global a)
     (setreg 4)
     (reg 4 \x2e;T2)
     (op2 < 5)
     (setreg 3)
     (reg 3 \x2e;T3)
     (branchf 1002 3)
     (const 2)
     (return)
     (\x2e;label 1002)
     (const 3)
     (return))

   However it seems to happen in global code, not obviously in
   procedure-local code, so it may not be a big deal.


Other optimization items and concerns.

- Code size remains a concern, ARM-32 is about as bad as Sparc.

- It would be better for both ARM and x86 if the value for UNDEFINED
  could be represented in 8 bits.  Since the low two bits are 10 we
  can't use a shifted constant on ARM, so it has to be a byte constant.
  The payoff is smaller code when checking for undefined globals.
  Unfortunately it looks like the immediate space does not have room for
  that encoding.

  It is possible to define undefined to me imm.misc + (0 << 8)
  instead of imm.misc + (3 << 8) as now.  Nobody uses the former value.

  Measurements shows that that would reduce the ARM heap by 42904 bytes.
  Probably worth doing, eventually.


How to port Larceny using Fence/Cant.

TO BE WRITTEN.


----------------------------------------

Instruction cache flushing on ARM and elsewhere.

Apparently ARM can use the same flushing method as on Sparc, where we
flush individual addresses / cache lines as we generate code or copy
bytevectors.  But the instructions to perform the flushing are
privileged, so a system call is required.  On Linux, there is a system
call "clear_cache" to clear a range of addresses in the instruction
cache, but some noise on the web indicates that it is not properly
implemented in libc on all Android platforms.  Right now
fence-driver.c makes the system call with inline assembler but this
could be investigated further.
