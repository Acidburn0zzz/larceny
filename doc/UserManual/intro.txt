Installing Larceny
------------------

anchor:installation[installation]

System requirements
~~~~~~~~~~~~~~~~~~~

There are three main varieties of Larceny.

Native Larceny is the fastest and most convenient variety
of Larceny.  It compiles directly to native machine code
for Intel x86-32 or SPARC microprocessors running Windows,
Linux, MacOS X, or Solaris operating systems.

Petit Larceny compiles to C instead of machine code.  It
runs on most Unix machines, including PowerPC Macintoshes
with MacOS X.

Common Larceny compiles to JIT-compiled IL on Microsoft's
Common Language Runtime (CLR) or Mono.  It provides access
to the .NET libraries from Scheme.

Downloading
~~~~~~~~~~~

The current versions of Larceny are available for
download at
http://larceny.ccs.neu.edu/[Larceny's main web page].

Twobit and Larceny are distributed in two forms: as a precompiled
binary, or as source code that can be used to reconstruct
any of the precompiled binary distributions.
Unless you intend to modify Larceny yourself, you do not
need to download the source code.

Installing the programs
~~~~~~~~~~~~~~~~~~~~~~~

If you are installing or running Common Larceny, please
consult the
http://larceny.ccs.neu.edu[Common Larceny User Manual]
instead of becoming confused by the instructions in this
manual.

Unpack the distribution files with an appropriate command such
as one of the following:


        tar -xzf larceny-X.Y-bin-native-sparc-solaris.tar.gz
        tar -xzf larceny-X.Y-bin-native-ia32-macosx.tar.gz
        tar -xzf larceny-X.Y-bin-native-ia32-linux86.tar.gz
        tar -xzf larceny-X.Y-bin-native-ia32-win32.tar.gz
        tar -xzf larceny-X.Y-bin-petit-stdc-macosx.tar.gz
        tar -xzf larceny-X.Y-src.tar.gz
    

This will create a directory called `larceny` in your current working
directory.  Assuming you have unpacked a binary distribution, that
directory will contain the following files:
    
    
        larceny.bin         Run-time system
        larceny.heap        Heap image with all libraries, FFI, and compiler
        twobit.heap         Heap image with some libraries and compiler
        larceny             Shell script that runs larceny.heap
        twobit              Shell script that runs twobit.heap
        scheme-script       Shell script that runs Scheme scripts
        startup.sch         Pathnames for the require feature
    

If you unpacked the source code there will be many other files and
directories, but `larceny.bin`, `larceny.heap`, and `twobit.heap`
will not be present.  You can reconstruct those files from their
source code, but that process requires a working version of Larceny
or MzScheme; unless you're porting Larceny or Petit Larceny to a
brand new target architecture, it's easier to obtain those three
files from a binary distribution of Larceny.

The scripts and heap images are discussed in the following section. 

You should decide where you want to install Larceny;
let's suppose you want to install it in `/usr/local/bin` and
`/usr/local/lib/larceny`.  Copy `larceny`, `twobit`,
and `scheme-script` to `/usr/local/bin` and edit the definition of
`LARCENY_PATH` at the head of each file to point to the correct
directory:
    
    
        LARCENY_PATH=/usr/local/lib/larceny
    

Then move or copy `larceny.bin`, `larceny.heap`, `twobit.heap`,
`startup.sch`, and the `lib` directory to `/usr/local/lib/larceny`.

You should now be able to run Larceny by typing "`larceny`" at a
Unix prompt.  On Windows, type "`larceny.bat`".

==== Compiling the R6RS standard libraries

Before you can run Larceny in ERR5RS or R6RS modes, you may
have to compile the ERR5RS/R6RS runtime and standard libraries
as described by step 4 of `doc/HOWTO-BUILD`.

This step is definitely required if you are using Petit Larceny,
and is recommended even if you are using a prebuilt distribution
of native Larceny.

==== Twobit

Unless you are doing compiler development, you should use the
"`larceny`" script, not the "`twobit`" script. The difference
is that `larceny` runs the heap image named "larceny.heap"
while `twobit` runs the heap image named "twobit.heap".

Both of these heap images contain the Twobit compiler and the
`compile-file` procedure that is used to compile files of Scheme code,
but they differ in other ways.

In "`larceny.heap`", every expression is compiled before it is
evaluated, but the internals of the Twobit compiler are hidden
(except for compilation switches).

In "`twobit.heap`", some of the libraries that are present in
"`larceny.heap`" are missing, and all internals of Twobit are exposed:
every top-level name in Twobit is bound in the interaction environment
and may be changed interactively, with immediate effect.  Since
compiler development can be a risky business, "`twobit.heap`" uses an
interpreter to evaluate the Scheme code you load and type -- the
interpreter is unaffected by changes to Twobit.

Using "`twobit.heap`" is probably not useful unless you are doing
compiler development, in which case you will need the source code as
well as the binaries.


Running Larceny
---------------

anchor:running[running]

Larceny currently runs in any of four distinct modes:

    R5RS              traditional read/eval/print loop (the default)
    ERR5RS            ERR5RS read/eval/print loop
    R6RS              batch execution of R6RS top-level programs
    Scheme script     batch execution of R6RS Scheme scripts

These modes correspond to the four distinct kinds of Scheme
programs that are described by the current de facto standards
for Scheme.  (IEEE/ANSI Std 1178 is so similar to the R5RS
standard that Larceny implements both languages in R5RS mode.)

R5RS mode
~~~~~~~~~

When you start Larceny in R5RS mode (the default), you
will be presented with a banner message and the
read-eval-print loop's prompt:

------------------------------------------------------------
% larceny
Larceny vX.Y "<version_name>" (MMM DD YYYY HH:MM:SS, ...)
larceny.heap, built ...
        
> 
------------------------------------------------------------

You can enter a Scheme expression at the prompt.
After a complete expression has been read, it will
be evaluated and its results printed.

ERR5RS mode
~~~~~~~~~~~

For the most current information on  Larceny's new
ERR5RS-compatible read/eval/print loop, see `doc/HOWTO-ERR5RS`.

To interact with Larceny's ERR5RS read/eval/print loop,
specify the `-err5rs` option on Larceny's command line:

    % larceny -err5rs
    Larceny v0.95 "First Safety" (...)
    ERR5RS mode (no libraries have been imported)

Since no libraries have been imported, the only forms you
can evaluate are constant literals, variable references
(but no variables have been imported!), procedure calls
(but no procedure values are accessible!), library
definitions, and import forms.  The first thing you'll
want to do is to import some of the pre-loaded libraries,
such as:

    > (import (rnrs base) (rnrs io simple) (err5rs records syntactic))

Once you have imported `(rnrs base)` or a composite library
that includes it, you can evaluate definitions and use
all other syntax and variables you have imported.

==== Dynamic loading

To load nonstandard libraries, top-level programs, or
unadorned R5RS-style code from a file, you must first
import a suitable load procedure:

    > (import (err5rs load))

Loading a library does not automatically import it.
To use the variables and syntax that are exported by a
library, you must first load and then import that library
explicitly:

----------------------------------------------------------------
    > (load "lib/R6RS/benchmarking.sch")
    > (import (larceny benchmarking))
    > (time (vector-for-each + (make-vector 1000000 0)))
    Words allocated: 3095752
    Words reclaimed: 0
    Elapsed time...: 111 ms (User: 104 ms; System: 8 ms)
    Elapsed GC time: 4 ms (CPU: 4 in 8 collections.)
----------------------------------------------------------------

Before you import a library or load a top-level program,
you must first load all of the nonstandard libraries it
imports.

You do not have to import those libraries into the ERR5RS
top level, however, unless you want to use the variables
and syntax exported by those libraries in the expressions
and definitions you evaluate at the top level.

==== Pre-loaded libraries

For your convenience, Larceny pre-loads all of the standard
R6RS libraries and several other libraries besides, so you
can import from those libraries without having to load them
yourself.  The pre-loaded libraries include:

R6RS standard libraries:

    (rnrs base (6))                  ; R6RS chapter 9
    (rnrs unicode (6))               ; R6RS library chapter 1
    (rnrs bytevectors (6))           ; R6RS library chapter 2
    (rnrs lists (6))                 ; R6RS library chapter 3
    (rnrs sorting (6))               ; R6RS library chapter 4
    (rnrs control (6))               ; R6RS library chapter 5
    (rnrs exceptions (6))            ; R6RS library section 7.1
    (rnrs conditions (6))            ; R6RS library sections 7.2 and 7.3
    (rnrs io ports (6))              ; R6RS library sections 8.1 and 8.2
    (rnrs io simple (6))             ; R6RS library sections 8.1 and 8.3
    (rnrs files (6))                 ; R6RS library chapter 9
    (rnrs programs (6))              ; R6RS library chapter 10
    (rnrs arithmetic fixnums (6))    ; R6RS library section 11.2
    (rnrs arithmetic flonums (6))    ; R6RS library section 11.3
    (rnrs arithmetic bitwise (6))    ; R6RS library section 11.4
    (rnrs syntax-case (6))           ; R6RS library chapter 12
    (rnrs hashtables (6))            ; R6RS library chapter 13
    (rnrs enums)                     ; R6RS library chapter 14
    (rnrs (6))                       ; R6RS library chapter 15
    (rnrs eval (6))                  ; R6RS library chapter 16
    (rnrs mutable-pairs (6))         ; R6RS library chapter 17
    (rnrs mutable-strings (6))       ; R6RS library chapter 18
    (rnrs r5rs (6))                  ; R6RS library chapter 19

R6RS standard libraries that are pre-loaded but deprecated in Larceny:

    (rnrs records procedural (6))    ; R6RS library section 6.3 (deprecated)
    (rnrs records inspection (6))    ; R6RS library section 6.4 (deprecated)
    (rnrs records syntactic (6))     ; R6RS library section 6.2 (deprecated)

Other pre-loaded libraries:

    (err5rs records procedural)      ; ERR5RS records (procedural API)
    (err5rs records inspection)      ; ERR5RS records (inspection API)
    (err5rs records syntactic)       ; ERR5RS records (syntactic API)
    (err5rs load)                    ; ERR5RS load procedure
    (rnrs load)                      ; equivalent to (err5rs load)
    (r5rs)                           ; approximates the R5RS top level
    (explicit-renaming)              ; a macro system with explicit renaming

==== Library path

For convenience, future versions of Larceny will automatically
load libraries when they are imported, provided the library is
standard or can be found in the directory specified by the
`-path` option on Larceny's command line using Larceny's
standard translation from library names to file names.

This feature is not implemented in Larceny v0.95 "First Safety".

R6RS mode
~~~~~~~~~

To execute a top-level R6RS program that is contained
within a file named `pgm`, type:

    larceny -r6rs -program pgm

The `-program` option can be omitted, in which case
Larceny will read the top-level program from standard
input:

    larceny -r6rs < pgm

If you omit the `-program` option and do not redirect
standard input, then Larceny will wait patiently
for you to type a complete top-level program into
standard input, terminating it with an end-of-file.

You probably don't want to do that.  Had you wanted
to type R6RS code at Larceny, you'd be using ERR5RS
mode instead.

==== Pre-defined libraries

R6RS top-level programs and Scheme scripts may import
any R6RS standard libraries, and may also import any
of the libraries that are pre-loaded in Larceny's
ERR5RS mode.

==== Defining libraries

The R6RS standard does not specify any way for a
top-level program to define its own libraries.
Portable R6RS programs are therefore limited to
importing a subset of the R6RS standard libraries.

As an extension to the R6RS, Larceny allows a top-level
program or Scheme script to define R6RS libraries within
the file that contains the top-level program or Scheme
script, before the import form that begins the top-level
program.  These libraries must be arranged so that no
library depends upon libraries that come later in the
file.

We emphasize that this extension is non-portable.
It is not supported by Ikarus, which is currently the
only other system that implements a substantial fraction
of the R6RS.

==== Library path

As another extension to the R6RS, future versions of Larceny
will allow top-level programs to import nonstandard libraries
that can be found in the directory specified by the
`-path` option on Larceny's command line using Larceny's
standard translation from library names to file names.

We emphasize that this extension too will be non-portable.
Although Ikarus provides a similar feature, Ikarus's
mapping from library names to file names is incompatible
with Larceny's mapping.

The library path feature is not implemented in Larceny v0.95
"First Safety".

Scheme scripts
~~~~~~~~~~~~~~

On most Unix systems (including MacOS X and Linux), Larceny's
scheme-script will execute Scheme scripts as described in R6RS
non-normative appendix D, with or without the optional script
header.  To make Scheme scripts executable in their own
right, without executing scheme-script directly, add Larceny's
root directory to your path as described in `doc/HOWTO-INSTALL`.

Suppose, for example, that `/home/myself/hello` is an R6RS
Scheme script whose first line is the optional script header
(#!/usr/bin/env scheme-script).  If you do not have execute
permission for this script, or Larceny's root directory is
not in your path, then you can still run the script from
Larceny's root directory as follows:
     
    % ./scheme-script /home/myself/hello

If you have execute permission for the script, and Larceny's
root directory is in your path, then you can also run the
script as follows:

    % /home/myself/hello

If, in addition, the directory that contains the script is
in your path, then you can run the script as follows:

    % hello

[WARNING]
================================================================
Arguments to Scheme scripts are not handled properly in
Larceny v0.95 "First Safety".  This problem can be fixed
by applying a patch that has been posted at Larceny's main
web page.
================================================================


////////////////////////////////////////////////////////////////
FIXME
////////////////////////////////////////////////////////////////

Other scripting
~~~~~~~~~~~~~~~

On Unix systems, the following command line will run the
R5RS code in "myprogram.sch":

    larceny -nobanner -- -e '(load "myprogram.sch")'

To exit after normal termination of the program, change
the Scheme expression above to


    (begin (load "myprogram.sch") (exit))


Pre-compiled programs will load faster.  See compile-file.

==== Dealing with errors

Larceny has a crude debugger. If your program crashes, the point of
error will be saved, and back at the prompt you can start the
debugger:
    
    
        (debug)
    

There is some help available on-line in the debugger. (The debugger is
pretty much a prototype; you don't need to tell us how bad it is.)

==== Performance

By default, the Twobit compiler assumes that Scheme's standard
procedures will not be redefined, which allows the compiler to
generate inline code for many calls to standard procedures. If you
want to be able to redefine standard procedures, then you should
evaluate the expression
    
    
        (integrate-procedures #f)
    

After this expression has been evaluated, the compiler will generate
slower code.

To make the compiler generate faster code, you can promise not to
redefine standard procedures _and_ not to redefine any top-level
procedure while it is running. To make this promise, evaluate
    
    
        (compiler-switches 'fast-safe)

To view the current settings of Twobit's numerous compiler switches,
evaluate
    
    
        (compiler-switches)

All of Twobit's compiler switches are procedures whose setting
can be changed by passing the new value of the switch as an
argument.

// benchmark-block-mode broken for a long time; commenting out below

////////////////////////////////////////////////////////////////////////
To make `compile-file` generate faster code, you can promise that none
of the top-level variables that are defined within a file of Scheme
code are redefined or assigned outside of that file unless they are
redefined or assigned within the file. To make this promise, evaluate
    
    
        (benchmark-block-mode #t)
////////////////////////////////////////////////////////////////////////
    

For more information, evaluate
    
    
        (help)

Some of the help information that will be printed is out of
date or may be irrelevant to the heap image you are using,
but most of it is still true.
For still more information about compiler switches, see the
<<DevelopingSwitches,developer documentation>>.

=== Troubleshooting

==== Error messages when starting Larceny

When attempting to run an R6RS program, you may see
a warning about "loading source in favor of stale
fasl file: .../lib/R6RS/r6rs-standard-libraries.sch",
following by a long series of error messages about
syntactic keywords used as a variable, ending with
the kind of error you'd expect to see when a large
R6RS program is fed to a Scheme compiler that was
expecting to see R5RS-compatible code.  That means
the R6RS runtime and standard libraries were not
installed correctly, or their source files have been
touched or modified since they were last compiled.
To fix the problem, repeat step 4 of doc/HOWTO-BUILD.

The precompiled binary forms of Larceny should run on
most machines with the appropriate processor and operating
system, but the executable program "larceny.bin" may be
incompatible with very old or with very new versions of
the processor or operating system.  If that appears to be
the case, you can use MzScheme v37x to recompile larceny.bin
from source.  First, though, you should report the problem
to us (larceny@ccs.neu.edu).  Please report success stories
as well.

==== Crashes

Please report all crashes with as much information is possible;
a backtrace from a debugger or a core dump is ideal (but please
do not mail the core dump without contacting us first).
Larceny's run-time system is compiled with full debugging
information by default and a debugger like GDB should be able
to provide at least some clues.
