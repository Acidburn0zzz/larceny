Copyright 1998 Lars T Hansen.                -*- Indented-Text -*-

$Id$


			Grand Unified TO-DO List


This is the Grand Unified To-do List for Larceny, and lists all desired
features and fixes I know of, except actual bugs (see the file BUGS) and
large projects (see the file TODO-RAINYDAY).

** = High priority.
 * = Normal priority.
 + = Ultra-low priority.


FFI
 ** Standard-FFI high priority
    - How to load e.g. the file socket-support.o that has unresolved
      external references?
    - Test (better) on SunOS 5.
    - Test on SunOS 4.
    - Write guidelines for compiling C code for use with FFI.
    - Should exit if errors are discovered in the relinking phase.
    - Document!
 ** larceny_call() must deal with stack overflow.
  * Problem with dynamic loader on SunOS 4 -- exits if the file is not found!
  * Callbacks
    - finish implementation
    - call/cc must work right (to handle errors correctly in callbacks)
  * Performance
    - Profile and see if it's worth getting rid of or optimizing some layers.
  * Standard-FFI normal priority
    - Consider changing semantics so that foreign-file loads the file
      immediately -- gives better opportunities for error messages.
    - Setup so that it re-selects the FFI implementation at heap restore
      time; that way, a heap can be OS independent.

Common RTS
  * In-system heap dumper for generational system.
  * In-system heap dumper for conservative system.
  * Garbage collector
    - Features
      - weak cells
      - finalization
    - Policy & performance
      - Use madvise (maybe)
    - Implementation
      - consider building an allocator on top of memalign or mmap (maybe)
  * Factor out larceny_init() from main().
  * Will's new write barrier.
  * Clean up pointer registry in posix-alloc.c (after profiling it).

SPARC RTS
  * dzero should be in globals[].

Macros
  * Integrate macros with top-level environments.

SPARC Assembler
  * More singlestepping fixes:
    - want to preserve labels.
    - does not work well with peephole optimization.
    - want to show load with destination 0.
  * Peephole optimization:
    - might want to use Will's peephole optimizer.
    - in any case get rid of all the internal: primitives and 
      implement a faster strategy.
  * Performance
    - avoid extra pass during peephole optimizations
    - is it possible to do more work before assembly by emitting
      partially-completed instruction streams that are efficiently
      cloned and patched?
  * Better delay slot filling.
  * Maybe instruction scheduling.
  * General cleanup and streamlining.

Interpreter
 ** Use .named-lambda on internal procedures too.
  * Debug support (via *evalhook* or some other mechanism), esp. environment
    display/change, and single-stepping of expressions.

Debugging
 ** Show source code, if available (how to do local procedures?)
 ** Support for variable names and source file name, if available.
  * Support for source code location.
    This is how to do it: install a reader macro for #\(.  This macro
    does exactly what the current reader does, but when the datum has
    been read, it installs a mapping from the datum to the source position
    of the #\( in a map.  (The map can be cleared after every top-level
    expression.)  When the macro expander wants to create documentation,
    it takes its source expression and looks it up in the map to get
    the source position (if any).  Probably an eq-hash table is best,
    especially when doing block compilation.
  * Graph printing and reading could vastly reduce the amount of 
    source code emitted as part of the documentation, where code may now be
    duplicated during writing and reading.  (Not a problem for in-memory
    compilation.)
  * Better trace/break based on advise or similar functionality.
  * Support for interpreted code.
  * More generalized object inspector (a la Chez Scheme).

Library
 ** Top-level environments must also hold syntax definitions.
 ** R5RS compliance
    - Multiple values, for sure.
    - Check everything else.
 ** Move Experimental functionality to Auxlib
     - records (requires cleaning up and documenting records).
     - applyhooks
  * I/O system high priority
    - Extensible I/O system (see Larceny Note).
    - Performance [see fast-read-char.txt for details]
      - peek-char should maybe be coded in MAL, like read-char and write-char.
      - read-char, write-char, and peek-char should be compiler macros that
        call fast-read-char et al and, if that fails, call the 'normal'
        versions
      - the normal versions of read-char, write-char, and peek-char should
        manipulate the port directly rather than calling io/read-char 
        and io/write-char; this avoids extra call overhead.
  * I/O system normal priority
    - Support non-blocking I/O (see Larceny Note).
    - Faster reader [faster read-char and better compiler will help].
    - Faster printer [maybe].
    - Reader and printer should be able to read and print graph structures.
    - Switch from Dragon4 to Dybvig's algorithm.
    - Re-implement transcript I/O in terms of the extensible I/O system.
    - Re-implement string I/O in terms of the extensible I/O system.
    - Read tables (a la Interlisp where the read table can be an argument
      to 'read').
    - Print tables [maybe].
  * Returning from the REPL: Should (exit) just exit from the current level
    of REPL, instead of returning to the OS?
  * 'Abort' and 'abort-handler'?  Makes sense if 'exit' exits the repl,
    not the system.
  * Define "repl-reader" so that the reader can be replaced in the REPL.
  * Define "load-reader" so that a reader that does circular objects
    can be installed?
  * Move _format_ out from Lib -- it's not used there, and should go in 
    Auxlib.  Probably needs to be loaded by compiler.
  * Type tags really should be gotten from the auto-generated stuff.
    As it is, they come from Lib/typetags.sch.
  * Documentation structures should not be required to all be of the same
    length -- the proc-info procedures should deal with different-length
    vectors.
  * Bignums
    - speedup
    - decent test suite
    - remove dependencies on bigit size and endianness
  * Speed up make-compnum (see comments in Lib/flonums.sch).
  * Compnum->string (in num2str.sch) can be made to handle other radices
    than 10 (see comments in Lib/num2str.sch).
  * Separate _loading_ and _linking_.  
    - Requires support for graph reading in the reader, and for graph
      printing in makefasl, at least, because it's useful to perform linking
      without traversing the entire structure, but a link map instead.
      Also, the link map makes 'un-linking' possible.
    - The FASL format will then change, and #^G will go away from the reader.
    - Allows disassembling FASL files.
  * Implement a dump-handler (procedures run before a dump)
  * Implement a restore-handler (procedures run after restore -- partially
    exists already in the form of add-init-procedure!.)
  * Want a system-environment procedure that returns the system name space.  
    That namespace should be disjoint from the others, but it would allow
    wizards much more flexible access than the current system-function
    functionality (which should go away).
  * The millicode support vector (aka 'callouts') should be initialized
    element-by-element using defined constants, not in a huge call to
    'vector' like it is now. (Lib/millicode-support.sch.)

Testing
 ** Regression test suite must be completed (massive undertaking).
 ** GC test suite must be completed.
    - test coverage automation
    - additional tests to provide good coverage :-)

Performance and code generation
  * Speed
    - keep the return address in a register when possible
    - use more HW registers on the SPARC
    - use HW divide in-line
    - use HW divide in millicode [done for quotient]
    - open-code multiplication by simple constant (fixnum/fixnum case).
    - in-line boxing code for bignum boxing in generic.s
    - number? should check for fixnum in-line, ditto other predicates 
      and exact?
    - Function cell
    - Once-only globals checking
  * Space
    - Operation-specific error callouts, to avoid having to set up
      the error code in-line.
    - Pass register mask rather than register contents -- should
      save instructions in most cases.  In particular, if we have no more
      than 17 registers (plus RESULT, SECOND, THIRD) then the following
      method can be used:
       * One or two words of raw data follows the callout to the exception
         handler.  The first word is the first and second argument, the
         second word is the third and fourth (if present).
       * The low half of the word is a bitmap for argument 1 (3), the high
         half is a bitmap for argument 2 (4).
       * If the low half is 0, then the argument is in RESULT (THIRD),
         otherwise it is one of the registers R1..R16.
       * If the high half is 0, then the argument is in SECOND (FOURTH),
         otherwise it is one of the registers R1..R16.
       * If the exception handler needs to return, it can skip over the
         data as required.
      The method can be used for other millicode calls, too, to reduce
      code size, but it increases the number of instructions executed
      because millicode must decode the masks.
  * Possible primops (RTS hooks)
    - sys$bvl-copy-into!
    - sys$bvl-fill!
    - sys$vl-fill!
  * Stack use optimization
    - don't copy the stack during GC.
    - lazy frame initialization.
  * Arithmetic and numbers
    - Support fixnum, flonum, compnum-specific operations.
    - Support flonum, compnum vectors.
  * Improve speed of context switching code.
  * Can we improve the speed of a syscall?
  * Bignum speedups (patience, patience...)
  * Predicates that should be primops but aren't:
    [none currently]
  * Predicates for control that need to be but aren't:
    - representation predicates, especially flonum?, compnum?.
    - port?, because it's used in the primitive I/O procedures.
    - structure?, because it's used in every record operation.
  * Generic I/O performance (see I/O item earlier).

Auxiliary library (directory Auxlib)
  * Pretty printer should support structure printer.
  * Printer/reader that can do circular structures (need eq? hashing).
  + Object pickler

Development system & compiler
  * Extend compile313 to record file name and possibly position.
    (Position requires a custom parser or a read procedure that returns
    two values -- expression and start position.  And that doesn't even
    work for internal definitions.)
  * Change the syntax of MAL files so that _eval_ is not required; 
    hack assembler drivers correspondingly.
  * Generate only as long documentation structures as needed.
  * The definition of PROC_HDR is wrong because the tag bits are all
    set rather than all cleared.
  * Clean up mess around primitives that are rewritten by compiler
    but also coded in millicode (abs, positive?, negative?).
  * Performance
    - Cache global cells and symbols.
  + R5RS macros [new compiler does this]
  + Real implementation of multiple values [new compiler does this]

Documentation
 ** Clean up the concept index.
 ** Clean up compilation etc documentation.
 ** These sections need more or better documentation:
    - auxlib.html
    - debugging.html
    - fixnums.html
    - repl.html

Miscellaneous
 ** Copyright notice on all files.
 ** Finish documenting all extensions.
  * We should perhaps define bytevector-set! so that it chops off 
    high bits; this makes code easier to write and is faster (but is 
    it slower on other kinds of architectures, e.g. Alpha?).

Bootstrap heap dumper (extremely low priority)
  + Speedups:
    - Use hash tables rather than assq everywhere
    - Optimize output procedures like makefasl2

----------------------------------------

Assembler performance.

* Label lookup can be hashed (pass5p1)

* Faster peephole optimizer (one way or another).

* The searching of the not-dsi slot of the assembler-value list may be
  expensive.  During the compilation of pass4p1, it had the following lengths
  at the end of the assembly of each code vector:

(3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 7 9 9 9 9 9 10 11 11 11 11 11 20 21 23 23 23 30 30 31 38 53 61 61 69 73 75 81 89 105 110 112 137 144 151 151 162 186 196 197 198 233 254 306 432)

  Presumably, almost all searches will fail, and there's one search for each
  delay slot. Turning off delay slot filling dropped the time from 4300/3200
  to 3300/2900.  It might be worthwhile optimizing this code.
  (Although: 0.3s CPU time... it's in the tail.)

  Further tests show that delay slot filling (after other optimizations)
  account for only 0.15-0.08s of the CPU time.  It's now _really_ in the tail,
  but on the other hand, 0.1s is 25% (!) of assembly time.

Must look at:

* np-sc-heap.c:  contraction code (currently disabled).
* sc-heap.c: contraction code (currently disabled).
