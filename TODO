Copyright 1998 Lars T Hansen.                -*- Indented-Text -*-

$Id$


			Grand Unified TO-DO List


This is the Grand Unified To-do List for Larceny, and lists all desired
features and fixes I know of, except actual bugs (see the file BUGS) and
large projects (see the file TODO-RAINYDAY).

** = High priority.
 * = Normal priority.
 + = Ultra-low priority.


----------------------------------------------------------------------

Miscellaneous
 - larceny mailing list archive
 - must write a HOWTO-CVS note to go into this directory.
 - Need a better configuration mechanism -- possibly, something based
   on autoconf.  As it is, features are chosen on the basis of dubious
   information.  Fundamentally, though, it may be better to specialize
   "make setup"; don't know.  In any case the configuration depends on
   the target system (petit, native, bytecode), not just the target 
   platform.  Info about the target _system_ can be encoded in the 
   individual make commands, but this is error-prone: better to set it
   up once, then compile for a particular model until it is re-setup.
 - Need to create a heap comparison tool that only compares "significant"
   differences, or, a heap rectification tool that clears insignificant
   bits from a heap image, notably from bytevector structures.  This
   will make heap comparison much easier.
 - Make-development-environment does not compile the .imp.sch file
   for other targets than the current.
 - FASL format: both Petit Larceny and SPARC larceny FASL files have
   type .fasl, but they are of different types.  One way of coping 
   with this (to reduce errors) is to have an initial expression
   in each FASL file:
	(.fasl-type 'sparc)
   or
	(.fasl-type 'standard-c)
   where the definition of .fasl-type could be
	(define (.fasl-type x)
	  (eq? x (cdr (assq 'architecture-name (system-features)))))
   if system-features is fixed to return not a string but a symbol
   for the architecture name.
 - Heap images should contain information about binary format in
   addition to version, eg, PETIT-BE, PETIT-EL, SPARC-NATIVE, ..., and
   should also encode the control transfer method used for Petit Larceny
   -- libpetit.so needs to be built with the appropriate #define.

----------------------------------------------------------------------

Possibly subtle bug: if the standard library uses EVAL internally,
then it must be careful about which macro environment and variable
environment it picks up.

Currently the only internal use of EVAL is in the macro expander and
it simply uses it to convert a transformer expression to a procedure.

----------------------------------------------------------------------

Twobit
  * Need inline procedures and constant folding for fixnum operations.
  * Need inline procedures and constant folding for flonum operations.
  * Should rename `define-inline' as `define-compiler-macro', because
    `define-inline' is much more useful as a proper inline-procedure
    definer.  The current define-inline has the wrong semantics for
    everyday use (it can be made to evaluate its arguments more
    than once, or not at all).
  * Need a way to restrict primitive tables to a given set.

FFI
 ** Standard-FFI high priority
    - How to load e.g. the file socket-support.o that has unresolved
      external references?
        - looks like linking it with the appropriate libraries is OK.
    - Test (better) on SunOS 5.
    - Test on SunOS 4.
    - Write guidelines for compiling C code for use with FFI.
    - Should exit if errors are discovered in the relinking phase.
    - Document!
    - larceny_call() must deal with stack overflow.
    - sample code.
 ** larceny_call() must deal with stack overflow.
  * Problem with dynamic loader on SunOS 4 -- exits if the file is not found!
  * Callbacks
    - finish implementation
    - call/cc must work right (to handle errors correctly in callbacks)
  * Performance
    - Profile and see if it's worth getting rid of or optimizing some layers.
  * Standard-FFI normal priority
    - Consider changing semantics so that foreign-file loads the file
      immediately -- gives better opportunities for error messages.
    - Setup so that it re-selects the FFI implementation at heap restore
      time; that way, a heap can be OS independent.

Common RTS
  * In-system heap dumper for generational system.
  * In-system heap dumper for conservative system.
  * Garbage collector
    - Features
      - weak cells
      - finalization
    - Policy & performance
      - Use madvise (maybe)
    - Implementation
      - consider building an allocator on top of memalign or mmap (maybe)
  * Factor out larceny_init() from main().
  * Will's new write barrier.
  * Clean up pointer registry in posix-alloc.c (after profiling it).
  * For compatibility with the conservative collector and 
    no-interior-pointers, we must fix all code that allocates a single
    block of memory and parititons it up into multiple objects.  The
    places that do this are:
      - argv.c          args vector-of-strings -- not fixed
      - ffi.c           ffi callback arguments -- not fixed
      - stats.c         stats vector -- not fixed; hacked around
      - cglue.c         rest args -- fixed
    The correct way to implement this is to implement a _simple_ handle
    system:
       typedef word *w_handle;
       w_handle gc_make_handle( gc_t gc, word tagged_pointer );
       w_handle gc_copy_handle( gc_t gc, w_handle handle );
       void gc_destroy_handle( gc_t gc, w_handle handle );
    and to use this to avoid premature collection of objects referred to
    from C code only.

SPARC RTS
  * dzero should be in globals[].

Macros
  * Integrate macros with top-level environments.

SPARC Assembler
  * More singlestepping fixes:
    - want to preserve labels.
    - does not work well with peephole optimization.
    - want to show load with destination 0.
  * Peephole optimization:
    - might want to use Will's peephole optimizer.
    - in any case get rid of all the internal: primitives and 
      implement a faster strategy.
  * Performance
    - avoid extra pass during peephole optimizations
    - is it possible to do more work before assembly by emitting
      partially-completed instruction streams that are efficiently
      cloned and patched?
  * Better delay slot filling.
  * Maybe instruction scheduling.
  * General cleanup and streamlining.
  * The code for op2imm generates slow code for some primitives: it emits 
    the constant into SECOND and then does a non-imm operation.  It gets
    + and - right; it would be nice to get =, <, <=, >, >= also, although
    the savings is one (static or dynamic) instruction, and the peephole
    optimizer gets most of the cases -- it's only where the datum is in
    RESULT and the result is being left in RESULT where this optimization
    matters.  Payoffs are slightly better for char=?, etc, since it's 
    costly to generate a character constant (2 instructions).  Still
    I expect most operations to work on operands in register, so the
    peephole optimizer will take care of it.
  * Fixnum-only arithmetic -- see Asm/Sparc/sparcprim-part4.sch.
    Remaining tasks:
      - optimize fx+ and fx- when it's possible to undo.
      - fxquotient, fxremainder
  * Peephole optimization (from in-line expansion of fast path of READ-CHAR):
    - make-cell: with source register and target register
    - vector-like? for control
    - bytevector-like? for control
    - Generally: more primitives for control:
       vector?, string?, bytevector?, flonum?, compnum?, bignum?
    - const + skip -- if the const is an immediate, the setup can go in
      the delay slot.  AND uses this construction.  
    - Generally: we can peephole
           any instruction
           ba target
           nop
      as long as <any instruction> is not in a delay slot.  We can also
      peephole any non-branch instruction from the target of a BA into
      its slot.
    - Generally: Ditto jmpl, call.  This will take care of RETURN.
    - Consider the following code (unsafe expansion of vector-like-ref
      with constant index):
	136	or	%g0, 16, %r5	! 0x10
	140	or	%g0, %r7, %result
	144	add	%result, 1, %tmp0
	148	ld	[ %tmp0+%r5 ], %result
	152	or	%g0, %result, %r5
      The move at #140 is clearly not necessary; #144 could add from r7 
      into tmp0.  Similarly, the move at #152 is not necessary, as the load
      at #148 could load directly into r5.  Finally, the setup of the
      constant at #136 is not necessary, as it could be used directly
      at #148.  The best instruction sequence is a single instruction (!):
	136	ld	[ %r7+17 ], %r5
      The instruction at #136 is due to the bad op2imm implementation;
      the instructions at #140 and at #152 are due to not having implemented
      vector-like-ref with source-register and destination-register.  Both
      are easy to fix.
  * More peephole optimizations
    - Unimplemented peephole operations
        bytevector operations
          bytevector-length
          bytevector-ref          (also op2imm)
          bytevector-set!
          bytevector-like-length
          bytevector-like-ref     (also op2imm)
          bytevector-like-set!
        vector-like operations
          vector-like-length
          vector-like-ref         (also op2imm)
          vector-like-set!
        others
          char->integer
          integer->char
          logand logior logxor lognot sll srl sra
    - Implement const/setreg/skip peephole optimization for simple constants
      and any target register -- allows the delay slot of the branch to be
      filled.
  * Support flonum-specific operations.
  * Fixnum-only arithmetic -- see Asm/Sparc/sparcprim-part4.sch.
    - optimize fx+ and fx- when it's possible to undo.
  * In-line _typetag_ in unsafe mode.

Interpreter
  * Debug support (via *evalhook* or some other mechanism), esp. environment
    display/change, and single-stepping of expressions.

Debugging
 ** Support for variable names and source file name, if available.
  * Support for source code location.
    This is how to do it: install a reader macro for #\(.  This macro
    does exactly what the current reader does, but when the datum has
    been read, it installs a mapping from the datum to the source position
    of the #\( in a map.  (The map can be cleared after every top-level
    expression.)  When the macro expander wants to create documentation,
    it takes its source expression and looks it up in the map to get
    the source position (if any).  Probably an eq-hash table is best,
    especially when doing block compilation.
  * Graph printing and reading could vastly reduce the amount of 
    source code emitted as part of the documentation, where code may now be
    duplicated during writing and reading.  (Not a problem for in-memory
    compilation.)
  * Better trace/break based on advise or similar functionality.
  * Support for interpreted code.
  * More generalized object inspector (a la Chez Scheme).

Library
 ** Top-level environments must also hold syntax definitions.
 ** Move Experimental functionality to Auxlib
     - records (requires cleaning up and documenting records).
     - applyhooks
  * Remove `format' from the standard library and put it in Auxlib.
    Make sure it supports a proper subset of SLIBs `format' so that 
    Larceny code (eg debugger) that uses format can live with the
    substitute.
  * Performance: use define-inline judiciously to see if we can wring
    more speed out of the bignum code, and possibly other code (reader).
  * Arguably the intepreter's wacky notion of legal environment arguments
    should not be the default.  This should be a switch that's called by
    std-heap.sch and otherwise undocumented. Could call it 

       (interpreter/allow-illegal-use-of-environments)

    Better to fix this properly by integrating environments and syntax
    environments the way it "should" be done.
  * I/O system high priority
    - Extensible I/O system (see Larceny Note).
    - Performance [see fast-read-char.txt for details]
      - peek-char should maybe be coded in MAL, like read-char and write-char.
      - read-char, write-char, and peek-char should be compiler macros that
        call fast-read-char et al and, if that fails, call the 'normal'
        versions
      - the normal versions of read-char, write-char, and peek-char should
        manipulate the port directly rather than calling io/read-char 
        and io/write-char; this avoids extra call overhead.
  * I/O system normal priority
    - Support non-blocking I/O (see Larceny Note).
    - Faster reader [faster read-char and better compiler will help].
    - Faster printer [maybe].
    - Reader and printer should be able to read and print graph structures.
    - Switch from Dragon4 to Dybvig's algorithm.
    - Re-implement transcript I/O in terms of the extensible I/O system.
    - Re-implement string I/O in terms of the extensible I/O system.
    - Read tables (a la Interlisp where the read table can be an argument
      to 'read').
    - Print tables [maybe].
  * Returning from the REPL: Should (exit) just exit from the current level
    of REPL, instead of returning to the OS?
  * 'Abort' and 'abort-handler'?  Makes sense if 'exit' exits the repl,
    not the system.
  * Define "repl-reader" so that the reader can be replaced in the REPL.
  * Define "load-reader" so that a reader that does circular objects
    can be installed?
  * Move _format_ out from Lib -- it's not used there, and should go in 
    Auxlib.  Probably needs to be loaded by compiler.
  * Type tags really should be gotten from the auto-generated stuff.
    As it is, they come from Lib/typetags.sch.
  * Documentation structures should not be required to all be of the same
    length -- the proc-info procedures should deal with different-length
    vectors.
  * Bignums
    - speedup
    - decent test suite
    - remove dependencies on bigit size and endianness
  * Speed up make-compnum (see comments in Lib/flonums.sch).
  * Compnum->string (in num2str.sch) can be made to handle other radices
    than 10 (see comments in Lib/num2str.sch).
  * Separate _loading_ and _linking_.  
    - Requires support for graph reading in the reader, and for graph
      printing in makefasl, at least, because it's useful to perform linking
      without traversing the entire structure, but a link map instead.
      Also, the link map makes 'un-linking' possible.
    - The FASL format will then change, and #^G will go away from the reader.
    - Allows disassembling FASL files.
  * Implement a dump-handler (procedures run before a dump)
  * Implement a restore-handler (procedures run after restore -- partially
    exists already in the form of add-init-procedure!.)
  * Want a system-environment procedure that returns the system name space.  
    That namespace should be disjoint from the others, but it would allow
    wizards much more flexible access than the current system-function
    functionality (which should go away).
  * The millicode support vector (aka 'callouts') should be initialized
    element-by-element using defined constants, not in a huge call to
    'vector' like it is now. (Lib/millicode-support.sch.)
  * `Sort' order of arguments is different from Chez and MacScheme, which
    violates the Prime Directive.  On the other hand, it's compatible with
    most other systems!  Here's a survey:
       Chez Scheme 5.0:	predicate, list
       MacScheme 3.0 Student Edition: predicate, list
       Scheme48 0.36: list, predicate
       SLIB 2c4: list, predicate
       Larceny 1.0a1: list, predicate (also vector, predicate)
       MIT Scheme 7.3: list, predicate
       PC Scheme 3.3: list, predicate, where predicate is optional; if 
         predicate is not given, sorts by object type and then by the 
         "obvious" ordering within each type
       MzScheme 53 (?) `quicksort': list, predicate 
       MzScheme 53 (?) `sort': predicate, list
       STk 3.99.3: list, predicate (also vector, predicate)
       Bigloo 1.9: no sort built-in
       Gambit-C 3.0: no sort built-in
       RScheme 0.7.?: manual lists no sort procedure, but manual is incomplete
  * Would be nice to print bit pattern when printing WEIRD OBJECT.

Testing
 ** Regression test suite must be completed.
 ** GC test suite must be completed.
    - test coverage automation
    - additional tests to provide good coverage :-)
  * Create Larceny Note about how to run tests.

Performance and code generation
  * Speed
    - keep the return address in a register when possible
    - use more HW registers on the SPARC
    - use HW divide in-line
    - use HW divide in millicode [done for quotient]
    - open-code multiplication by simple constant (fixnum/fixnum case).
    - in-line boxing code for bignum boxing in generic.s
    - number? should check for fixnum in-line, ditto other predicates 
      and exact?
    - Function cell
    - Once-only globals checking
  * Space
    - Operation-specific error callouts, to avoid having to set up
      the error code in-line.
    - Pass register mask rather than register contents -- should
      save instructions in most cases.  In particular, if we have no more
      than 17 registers (plus RESULT, SECOND, THIRD) then the following
      method can be used:
       * One or two words of raw data follows the callout to the exception
         handler.  The first word is the first and second argument, the
         second word is the third and fourth (if present).
       * The low half of the word is a bitmap for argument 1 (3), the high
         half is a bitmap for argument 2 (4).
       * If the low half is 0, then the argument is in RESULT (THIRD),
         otherwise it is one of the registers R1..R16.
       * If the high half is 0, then the argument is in SECOND (FOURTH),
         otherwise it is one of the registers R1..R16.
       * If the exception handler needs to return, it can skip over the
         data as required.
      The method can be used for other millicode calls, too, to reduce
      code size, but it increases the number of instructions executed
      because millicode must decode the masks.
  * Possible primops (RTS hooks)
    - sys$bvl-copy-into!
    - sys$bvl-fill!
    - sys$vl-fill!
  * Stack use optimization
    - don't copy the stack during GC.
    - lazy frame initialization.
  * Arithmetic and numbers
    - Support fixnum, flonum, compnum-specific operations.
    - Support flonum, compnum vectors.
  * Improve speed of context switching code.
  * Can we improve the speed of a syscall?
  * Bignum speedups (patience, patience...)
  * Predicates that should be primops but aren't:
    [none currently]
  * Predicates for control that need to be but aren't:
    - representation predicates, especially flonum?, compnum?.
    - port?, because it's used in the primitive I/O procedures.
    - structure?, because it's used in every record operation.
  * Generic I/O performance (see I/O item earlier).

Auxiliary library (directory Auxlib)
  * Pretty printer should support structure printer.
  * Printer/reader that can do circular structures (need eq? hashing).
  + Object pickler

Development system & compiler
  * Would be possible to just have one procedure 'make-larceny-heap' that
    would build for the correct target.  This would be a real improvement.
  * Extend compile313 to record file name and possibly position.
  * Change the syntax of MAL files so that _eval_ is not required; 
    hack assembler drivers correspondingly.
  * Generate only as long documentation structures as needed.
  * The definition of PROC_HDR is wrong because the tag bits are all
    set rather than all cleared.
  * Clean up mess around primitives that are rewritten by compiler
    but also coded in millicode (abs, positive?, negative?).
  * Performance
    - Cache global cells and symbols.
  * Lib/makefile.sch:
    - There are still unix-dependent path names; if you use the make 
      facility with a non-Unix OS, there will be problems.  This can
      be fixed w/o too much trouble.
    - We need to use nbuild-files more extensively to set up file lists.
  * Real implementation of multiple values

Documentation
 ** Clean up the concept index.
 ** Clean up compilation etc documentation.
 ** These sections need more or better documentation:
    - auxlib.html
    - debugging.html
    - fixnums.html
    - repl.html

Miscellaneous
  * We should perhaps define bytevector-set! so that it chops off 
    high bits; this makes code easier to write and is faster (but is 
    it slower on other kinds of architectures, e.g. Alpha?).

Bootstrap heap dumper (extremely low priority)
  + Speedups:
    - Use hash tables rather than assq everywhere
    - Optimize output procedures like makefasl2

----------------------------------------

Bytecoded system:.

The Sparc assembler in v0.41 calls 72152 procedures in the assembler
table.  This includes pseudo-ops and duplicate calls for the
long-address reassemblies, but peephole optimization is enabled and not
all of those optimizations are reasonable in a bytecoded system.

Without pseudo-ops, the count is 53572 (including reassemblies).

With peephole optimization turned off, the count is 93946 (including
pseudo-ops).  Since pseudo-ops are rarely affected by peephole
optimization, we can estimate that the number of operations is
93946-(72152-53572) = 75366 instructions (including reassemblies).

So say that maybe 55000 words of object code will be emitted for the
standard library; that's 220KB of code, down from 917KB in the SPARC
image (undumped), a reduction by a factor of more than 4.  Still, in
the SPARC image there's 411KB of data, so a bytecoded image would
still be almost 650KB in size!

Turning off include-variable-names saves only about 40KB.  Shortening
all the documentation vectors where possible would save more space.
Rearranging the vectors (to put arity before source code) would help
some more.  Not including any documentation would help most: it saves
100KB of data.  Turning off generate-global-names saves very little 
more.

Observe that dumping the heap _adds_ 100KB of data -- does this come
from the macro expander's data structures?  Sigh.

In any case, in a bytecode heap, it's data size that's currently the
issue, not code size.

----------------------------------------

Assembler performance.

* Label lookup can be hashed (pass5p1)

* Faster peephole optimizer (one way or another).

* The searching of the not-dsi slot of the assembler-value list may be
  expensive.  During the compilation of pass4p1, it had the following lengths
  at the end of the assembly of each code vector:

(3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 7 9 9 9 9 9 10 11 11 11 11 11 20 21 23 23 23 30 30 31 38 53 61 61 69 73 75 81 89 105 110 112 137 144 151 151 162 186 196 197 198 233 254 306 432)

  Presumably, almost all searches will fail, and there's one search for each
  delay slot. Turning off delay slot filling dropped the time from 4300/3200
  to 3300/2900.  It might be worthwhile optimizing this code.
  (Although: 0.3s CPU time... it's in the tail.)

  Further tests show that delay slot filling (after other optimizations)
  account for only 0.15-0.08s of the CPU time.  It's now _really_ in the tail,
  but on the other hand, 0.1s is 25% (!) of assembly time.

  This problem does however slow down the assembler significantly during
  large (block) compiles -- so we must fix it.
