Building with Petite Chez Scheme 6.0 under Windows 2000.
2001-11-16 / lth

Most operations have been stuffed into a large Scheme script in
Util/win32.sch for general convenience (DOS isn't much of a command
processor).  It sometimes invokes external programs.

Start Petite Chez Scheme.  Then:
	
	> (current-directory "c:/source/larceny/src")
	> (load "Util/win32.sch")
	> (setup-directory-structure)     ; only once
	> (build-config-files)            ; whenever Rts/*.cfg change
	> (load-compiler)
	> (make-petit-heap)
	> (build-runtime-system)
	> (build-executable)

The last step usually results in linking warnings; ignore them (see
section on linking, below).

Other useful things:

	> (remove-heap-objects)           ; removes all generated files (LAP, LOP, C, OBJ)
	> (remove-rts-objects)            ; removes all .OBJ files in the RTS


Status.

Currently compiles, loads and runs, and seems to work OK:
 - can load scheme files and run them
 - passes Aubrey Jaffer's R4RS test suite
 - self-hosting works: have rebuilt entire system from within 
   the interpreter.

I've tested both with the longjmp jump discipline (which doesn't work
well, see below) and the trampoline technique (which works fine).


TODO.

~/petit.c is not generated by the above build process, but needs
to be?

Need to work on supporting more advanced Twobit settings -- don't yet
know what's required.  In any case, some typed primitives are
currently mapped back onto untyped ones but must be implemented
directly.

Must add call-with-binary-input-file and call-with-binary-output-file
to the compatibility packages?  These are now used by the twobit
drivers and the heap dumper.

Must clean up dumpheap-unix.sch so that it is usable; the rest of the
system may have diverged (again).

FIXMEs in the Win32 support code; nothing serious for the moment.

Synchronous interrupts are disabled because longjmp out of signal
handler does not work on WinNT or Win2K; it would be nice to fix
this (or some blocking syscalls will not be interruptible).


Performance.

Performance is generally iffy: interpreted fib(25) is a factor of 10
slower than in Petite Chez Scheme.  In Petite Chez Scheme, compiling
and assembling the basic heap image takes a few minutes; in Petit
Larceny it takes 35 minutes.  The bulk of the time is spent running
Twobit; just assembling the LAP and compiling the C code and building
heap takes a few minutes.

The generated code is not at all good in the MSVC++ Standard Edition
("cheap") compiler: the code contains many redundant loads, and stack
slots are not reused, so stack frames are huge.  At a guess there is
no global optimization in this compiler.  (I've tried /O2.
Optimization switches are not documented in the compiler help
message.)

Metrowerks CodeWarrior 6.0 generates much better code, and just
recompiling Interpreter\interp.c and Interpreter\inter-prim.c with
that compiler on full optimization cuts the running time of fib(25) in
half.  It also cuts generated code size in half, on those two files.

(General performance hint: it may be important for truly good code
generation to generate completely dense switches for dispatch in a
procedure -- no gap between the start label 0 and normal label, and no
dead labels.)


Codewarrior issues.

Can't compile at least lib/common/ehandler.c with '-opt full'; the
optimizer runs out of memory (about 300MB).  This is a problem also on
the Mac.  Might consider rewriting the Scheme code to accomodate the C
compiler.  Even so, some other files may cause problems (reader.sch,
memstats.sch, toplevel.sch).  The change in optimization switches may
matter: the interpreter compiled with '-opt on' seems to be slower
than when compiled with '-opt full' as measured by fib(25).

Just compiling with '-opt on' takes a looooong time on some files.


Jump discipline issues.

The MSVC++ 6.0 Standard Edition compiler is not very good.  In
particular it does does not reuse stack slots.  As a result, the
generated code is not good, and the stack frames are enormous: in the
reader procedure, admittedly an outlier, the stack frame is 3.5KB.

Therefore, a longjmp control discipline only works if the stack is
really huge, and I have not been able to specify a large enough stack
for this to work reliably.  (The largest stack I've been able to set
up is about 1MB; the OS requires a set stack size, apparently.)  In
practice, this discipline is not a good choice with this compiler.


Linking problems.

It is painful to link with /Zi to get (rudimentary) debug information
for compiled scheme code.  The problem seems to be that the debug info
database is always called vc60.pdb and is co-located with the library,
*and* the library must be compiled with a lib-path that indicates the
location of the pdb (it seems).  For the time being, I compile the
compiled scheme code with /Zd and then delete the resulting pdb before
linking; this gives full debug info for the RTS but very little for
the compiled scheme code (enough for the moment).


Debugging in Visual Studio.

To run under debugger, start MSVC and select 'File | Open workspace'
and then open petit.exe as the workspace; then run.  Breakpoints can
be set; variables in the RTS can be inspected (full debug info).
