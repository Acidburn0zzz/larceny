% -*- TeX -*-
% $Id: 2:exceptions.tex,v 1.2 1992/02/17 18:27:50 lth Exp lth $
%
% Conventions for exception handling in Larceny

\input{larceny.sty}

\title{Larceny Note \#2: \\
       Exception Handling -- Request for Comment}
\author{Lars Thomas Hansen}
\date{January 24, 1992}

\begin{document}
\maketitle

\begin{abstract}
This document attempts to summarize some basic ideas about exception
handling: what it is; different approaches to what exception handling
should be; which classes of exceptions there are; how various
strategies could be implemented; and so on. It is intended as a basis
for further discussion about exception handling, with the ultimate
goal of having a design for a coherent, low-overhead, and versatile
exception system.

It also turns out that the mechanisms discussed here apply more generally to
the system than only to the exception handling; the last section discusses
this.
\end{abstract}

\section{Types of Exception Handling}

In my limited experience, I have seen several classes of exception handlers
in various programming systems. These can be summarized as follows:

\begin{enumerate}

\item 
Simply abort to the top level (or to the OS) on an error, typically with
some error message. Chez Scheme version 3 and Turbo Pascal are systems
using this strategy. Some are slightly more sophisticated, printing a
backtrace of the stack before aborting; programming systems under VAX/VMS
provide this.

\item
Abort to the top level but allow the user to inspect the state of the
program at the time of the error (but do not let him start execution
in the core image). Chez Scheme version 4 provides this service by
capturing the continuation at the point of error and making its internals
inspectable; source-level debuggers under UNIX let the programmer look
at the core dump of the program after a failure.

\item
Allow the programmer to restart the failed computation at the
granularity of the procedure call. When the code being debugged has
not been optimized, this granularity corresponds fairly well to the
granularity of an expression in Scheme, and this is acceptable. In
optimized\footnote{``Optimized'' meaning at least that tail calls have been
converted to branches and that a large number of primitives have been
inlined.} code, however, this may be of very limited utility.

\item
Allow the programmer to restart the failed computation at the level
of the expression, even in optimized code.

\end{enumerate}

While the first option is reasonable for a first-cut system, we would
like to provide a more general mechanism, whereby we can later
approach the ``ideal'' solution of the fourth option. Much of the
remainder of the document tries to classify exceptions and sketch
mechanisms which are sufficient for this most advanced level of
restartability.

It should also be clear that the last type of exception handling does not
hinder the use of any of the three first types, and in fact, the second
type can be very useful and should be facilitated.

\section{Classes of Exceptions}

We will be considering optimized code only, as system primitives in
unoptimized code are implemented as calls to optimized scheme procedures.
In Larceny, we have the following types of exceptional conditions

\begin{itemize}

\item 
Type exceptions which are detected directly in the in-line code (wrong
type supplied to a primitive operation like ``car'', ``vector-ref'', or ``+'',
but not including calls to non-procedures).

\item
Type exceptions of the above kind which are detected in the millicode.

\item
Type exceptions which are detected in call-outs from millicode to Scheme
code, like non-numeric operands detected in ``contagion'' or similar routines.

\item
Attempted calls to non-procedures. This is always caught in the in-line code.

\item
Reference to undefined global variable.\footnote{The assembler has a switch
which, when set, makes it generate checks for the value \verb+\#!unspecified+
when it generates code for referencing a global variable. This has a certain
utility during debugging.}

\item
Software timer expired; this is always caught in the in-line code.

\item
Wrong number of arguments detected at procedure entry but in the procedure
itself.

\item
Wrong number of arguments detected in the {\sc m\_varargs} millicode.

\item
Caught keyboard interrupt (control-C).

\item
Caught breakpoint trap instruction.

\item
Caught call to the ``break'' primitive procedure.

\item
Calls from user code to the ``error'' procedure.

\item
System panics, e.g. when an unrecoverable heap overflow is detected.
\end{itemize}

Other exceptions are possible as the system is made more sophisticated;
errors in referencing user-defined types and errors related to multiple
return values come to mind. I'll ignore these for now.

With a bit of thought, we can classify the exceptions in five classes:

\begin{enumerate}
\item Type exceptions.
\item Argument count exceptions.
\item Procedure call exceptions (call to non-procedure).
\item Global variable reference exceptions.
\item Simple restartable exceptions (everything else).
\end{enumerate}

The basis for this classification is the information needed by each class to
complete the operation (when fixed) and return to the point following the 
point of the exception. The next sections present the information needed
and the mechanism with which an operation from each class can recover from the
exception.

\section{Type Exceptions}

These exceptions are raised as the result of an argument of the wrong
type being passed to a primitive operation. In order to recover, the
exception handler needs to know which operation failed and what its
arguments were.  The operation which failed can be passed an argument
to the exception handler, as can the arguments to the primitive
itself. The exception handler can dispatch on the code to a procedure
which handles the particular operation or class of operations. For
example, in the case of ``car'', the exception handler must be
presented with the code for the ``car'' operation in some fashion; it
will also know that ``car'' takes an implicit argument in the
\reg{result} register. The following code for ``car'' results:

\begin{minipage}{\linewidth}
\begin{verbatim}
        and     %RESULT, TAG_MASK, %TMP0
        cmp     %TMP0, PAIR_TAG
        be,a    L1
        ld      [ %RESULT - PAIR_TAG ], %RESULT
        jmpl    %MILLICODE + M_TYPE_EXCEPTION, %o7
        mov     EX_CAR, %TMP0
L1:
\end{verbatim}
\end{minipage}

The exception code is passed in a temporary register since, in
general, the millicode argument registers may be used by actual
arguments. In the above example, the exception handler would complete
the operation and then return to L1.\footnote{In general, it is
necessary to adjust the return address. In the case of ``car'',
however, the return address computed by ``jmpl'' does not need to be
adjusted since the load can go in the delay slot.} In practice, this
means that when the exception handler is executed, it interacts with
the user to repair the error (or to let the user abort the
computation); when the user has supplied a valid argument, the
exception handler passes it on to the ``car'' procedure, setting up a
return continuation to L1. When ``car'' returns, it returns with the car
of the valid pair in \reg{result}, and the computation can continue.

\section{Argument Count Exceptions}

These exceptions are raised as the result of a wrong number of
arguments being passed to a procedure, and are detected at procedure
entry.  When the error is detected, the current procedure is pointed
to by \reg{reg0}, and in principle, all the procedure has to do is to
jump to the exception handler with an error code. To retry the
operation, the exception handler can simply call the procedure again.
However, if a procedure has multiple entry points (where entry points
not at the beginning of the procedure also check the number of
arguments), the exception handler needs to be supplied with the
address of the entry point as well. This is straightforward when the
error is detected in the procedure itself (as for a fixed number of
arguments); less so for a variable number of argument, when the error
is detected in millicode. One solution is to pass the entry point
address to the {\sc m\_varargs} millicode; another is to perform the
argument range check in the procedure body before going into
millicode. Both approaches have minimal overhead.

\section{Procedure Exceptions}

A procedure exception (attempted call to a non-procedure) is detected
after the arguments have been evaluated and moved into registers. The
current code generated for an invocation has not moved the procedure
into \reg{reg0} nor has it moved the argument count into \reg{result}
when this error is detected, and we'll assume that in the following
discussion, noting that it makes no difference, as long as we decide
on which way to do it. Since all the exception handler has to do when
this exception is raised is to supply a new procedure to the given
arguments, all the information needed to resume is the number of
argument which were supplied in the original call. This can be passed
in an \reg{argreg}, for example, since these are unused in a procedure call:

\begin{minipage}{\linewidth}
\begin{verbatim}
        ...
        cmp     %RESULT, PROC_TAG
        be,a    L2
        ld      [ %RESULT + CODEVECTOR_OFFSET - PROC_TAG ], %TMP0
        jmp     %MILLICODE + M_PROC_EXCEPTION, %o7
        mov     ARGCOUNT, %ARGREG2
    L2:
        mov     %RESULT, %REG0
        jmp     %TMP0 + 4 - BVEC_TAG
        mov     ARGCOUNT, %RESULT
\end{verbatim}
\end{minipage}

Notice that no exception code is used, as there is a separate
millicode procedure for a procedure exception.\footnote{Whether there
should be a separate one, or whether they should all be the same,
could be debated.}

Since the return address already exists in the topmost stack frame,
none need to be provided to the exception handler, but \%o7 is set
up anyway -- the information can be potentially useful for debugging.

\section{Global Variable Reference Exceptions}

When a global variable is loaded into a register, its value is checked
to see if it is \verb+\#!unspecified+.\footnote{The code to do this checking
is generated only if the proper magic flag is given to the assembler.}
If so, an exception is raised, signalling an undefined global variable.

A global variable is currently a pair, where the car of the pair is used
to store the value of the variable. The cdr of the pair is initialized by
the heap dumper to hold either a unique fixnum or a pointer to the symbol
naming the variable (based on a magic flag; the former is the default).
Hence, when the value of a global variable is unspecified, its name is
available for inspection. Such an exception could therefore be raised
thusly:

\begin{minipage}{\linewidth}
\begin{verbatim}
        ld      [ %REG0 + CONSTVECTOR_OFFSET - PROC_TAG ], %TMP0
        ld      [ %TMP0 + SOME_OFFSET - VECTOR_TAG ], %TMP0
        ld      [ %TMP0 - PAIR_TAG ], %RESULT
        cmp     %RESULT, UNSPECIFIED_CONST
        bne,a   L1
        nop
        jmpl    %MILLICODE + M_GLOBAL_EXCEPTION
        mov     %TMP0, %ARGREG2
    L1:
        ...
\end{verbatim}
\end{minipage}

Again, the return address of the exception will be L1. If the exception is
fixed and execution continued, \reg{result} will have the appropriate
value when L1 is reached.

\section{Simple Exceptions}

These exceptions are characterized by needing only the return value to
the exception-causing code to resume execution. Timer traps and
breakpoint traps will most likely be forwarded to appropriate Scheme
procedures, which will return as normal (through the
Scheme-to-scheme-through-millicode calling interface, described in
Larceny Note \#1) to the exception-causing procedure. A keyboard
interrupt can be handled exactly as a breakpoint trap.

\section{Miscellaneous Notes}

The mechanisms sketched in the above have other applications as well.
In particular, the mechanism used to fix type errors is similar to the
intended mechanism for dealing with generic arithmetic which has to go
through ``contagion'': this procedure takes three arguments, namely
the original (presumed numeric) arguments as well as a scheme
procedure to complete the operation, for example ``+''. When the
continuations are set up right, contagion does not jump back to the
original code to retry it, but rather pushes forward into the generic
routine, which then returns the appropriate result to the original
caller at the correct point.

\end{document}
