; -*- Text -*-
; $Id: conventions.txt,v 1.9 91/07/22 15:21:59 lth Exp Locker: lth $

	    Calling Conventions and Register Usage (SPARC)
				   
			    --------------


0. Scope of this Document
-------------------------
This document discusses the mapping of virtual-to physical registers
on the Sparc, the use of non-mapped Sparc registers, the use of stacks
for Scheme and C, the calling conventions for Scheme and C procedures
on the Sparc, the layout of continuations (both in the stack and on the
heap), and the layout of procedures (closures). Finally, we discuss the
calling conventions for millicode procedures and the calling conventions
for inter-language (C to Scheme and Scheme to C) calls.


1. Register usage and mapping
--------------------------
The mapping of virtual to physical registers is defined in the header
file "registers.s.h", and is also summarized below. The following
discussion highlights some of the trade-offs.

The Sparc manual is unclear about which of the global registers
%g1-%g7 we can use. %g1 is clearly available.  If we don't care about
Sparc ABI compliance, we can use all.  Franz Allegro Common Lisp uses
all the global registers. Currently, we use only %g1, and there is no
immediate need for using any of the others, although at some level of
optimization, more registers will clearly be beneficial.

The "call" instruction uses %o7 to store the return address; we cannot
in general use this instruction for calling out-of-line library
procedures, but it is convenient to simulate a "call" using the "jmpl"
instruction, because calling the millicode becomes cheaper that way
(this is discussed in some detail below).  Therefore, we should
reserve %o7 for this use.

Likewise, we will want two stacks: one for C and one for Scheme. This
choice lets us tailor the Scheme calling conventions without having to
worry about interrupts and related messes, which reqire a specific
stack layout. The C stack follows the conventions necessary to deal
with asynchronous events. Since the C stack pointer must at all times
be in register %o6, we cannot use this register for Scheme.

Since the operating system window overflow trap handler uses the stack
pointers of previous windows (i.e. the %i6 after a save), the %i6
register cannot be used by Scheme, either.  

Although %i7 holds the return address of the previous procedure in the
C calling conventions, we can simply save it somewhere (typically on
the C stack), so %i7 is available.

Hence we are left with 22 registers available to Scheme: %g1, %i0-%i5, %i7,
%l0-%l7, and %o0-%o5. We have the following virtual and work register
classes to map onto those registers (their function is elaborated on
later):

REG0 ... REGn, for some n. 
  These are the general-purpose virtual registers. A subset must be
  mapped to physical registers, and the rest will be in memory.
  Rootable.

RESULT
  The register in which we return a value and pass argument counts. Also used
  to pass the first argument to millicode procedures. Rootable.

ARGREG2
  Second argument to a millicode procedure. Rootable.

ARGREG3
  Third argument to a millicode procedure. Also suggested as the register in
  which to pass a procedure return address. Rootable (the return address 
  always looks like a fixnum on a SPARC).

STKP
  Scheme stack pointer. Nonrootable.

E_TOP, E_LIMIT, and others (perhaps STK_LIMIT)
  Heap pointers. Nonrootable.

GLOBALS
  A register pointing to an array of global variables. Nonrootable.

MILLICODE
  A register pointing to a vector of pointers to millicode procedures. 
  Nonrootable.

TIMER
  The countdown timer register. Nonrootable.

TMP0 ... TMPm, for some m
  Temporary registers. Nonrootable.

It is convenient for the purposes of code generation to have
even-numbered general-purpose registers mapped to even-numbered
machine registers, as this saves instructions and cycles in some cases
when a "store double" instruction can be used. This also requires that
the Scheme stack pointer always be double-word aligned.

The number of temporary registers needed is unclear; the more the
better is a good rule, but there is clearly a limit. Again, the more
sophisticated the compiler, the more temps are probably needed. For
reasons which will become clear later, %g1 should be mapped to a TMP
register. Also, some two of the temporaries should be allocated so
that they can be used as a register pair, since this allows certain
tweaks.

Here is the current mapping:

   REG0 ... REG7   -->  l0 ... l7
   RESULT          -->  o0
   ARGREG2         -->  o1
   ARGREG3         -->  o2
   STKP            -->  o3
   E_TOP           -->  o4
   E_LIMIT         -->  o5
   GLOBALS         -->  i7
   MILLICODE       -->  i5
   TIMER           -->  i4
   TMP0            -->  g1
   TMP1            -->  i0
   TMP2            -->  i1

Note that %g1 is a temporary, and %TMP1/%TMP2 is a temporary-register
pair.

The names SAVED_RESULT, SAVED_ARGREG2, SAVED_ARGREG3, and SAVED_STKP
can be used to access the RESULT, ARGREG2, ARGREG3, and STKP registers
after a "save" instruction has been executed.


2. Continuations
----------------
There are two continuation layouts: in the stack and on the heap. Heap
continuations are never manipulated directly by compiled Scheme code;
instead, they are created on stack overflow or on the capture of a
continuation, and restored into the stack on a stack underflow or the
reinstatement of a continuation.

Stack frames have the following layout (memory addresses increasing
going down the figure):

%STKP --> pppp pppp pppp pppp pppp pppp pppp pp00   return address slot
          ssss ssss ssss ssss ssss ssss ssss ss00   continuation size (bytes)
          pppp pppp pppp pppp pppp pppp pppp p111   procedure (saved REG0)
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   argument  (saved REG1)
          ....
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   temporary (initially 0)
          ....

The frame size is the number of bytes used by the frame,
including the return address and size fields.  A frame
should always be an even number of words, but the size field should
indicate the number of actually used words, i.e. less any padding
words. This doubleword alignment of the stack lets us save some
instructions as outlined below. The unused word of the frame
should always be the highest word in the frame, and it may remain
uninitialized, if desired: the stack flushing routine deals with it in
a coherent way.

As a special case the procedure word may be all 0's, in which case the
return address will not be adjusted when the stack frame is flushed to
the heap. This allows the creation of frames which correspond to
nonrelocatable code.

When the stack cache is flushed into the heap, each frame is made into
a vector structure with the following layout:

      --> 0sss ssss ssss ssss ssss ss00 101x xx10   vector header word
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   dynamic link or #f
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xx00   return offset
          pppp pppp pppp pppp pppp pppp pppp p111   procedure (saved REG0)
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   argument  (saved REG1)
          ....
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   temporary (initially 0)
          ....

The return offset is the offset into the code vector of the saved
procedure to which point the return address pointed before the frame
was flushed to the heap. The code vector is a byte vector; the offset
is from the start of the first byte of the bytevector, i.e. it is a
bytevector index.  Note that all words in the heap continuation frame
must be valid scheme objects; hence, if there is a chance that a frame
is flushed before all temporaries are used, then the temporaries must
be initialized by the procedure entry code.

The tags of the headers which distinguish continuations from other
vector types are defined in the file "datatypes.txt".


3. Procedures (Preliminary, not very interesting, and probably wrong)
---------------------------------------------------------------------
A procedure looks much like a vector (although it has a distinguished
header):

     --> 0sss ssss ssss ssss ssss ssss 1111 1110    header
         pppp pppp pppp pppp pppp pppp pppp p101    bytevector ptr (to code)
         xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx    data slot
         ....

It is up to the compiler to deal with the contents of the data slots.


4. Calling conventions -- some prelimiaries
-------------------------------------------
The discussion of procedure calls separates into several parts:
Procedure entry; setting up for a call; doing a tail call; doing a
non-tail call; and returning from a procedure. Each has several
variations.

One operation which is used quite a bit is the equivalent of the "lea"
(load effective address) instruction on the mc68000. It calculates the
effective address of some location based on the current PC.  However,
the Sparc has no "lea" instruction, nor is the PC available to other
instructions than the "call" instruction. On the other hand, since the
"call" instruction is PC-relative, we can use it to extract the PC and
calculate an effective address from there. So assume we want to say

	lea	L2, %TMP0		! compute effective address into %TMP0

then we really say

	call	.+8			! "." means "current pc"
	add	%o7, (L2-(.-4)), %TMP0

This setup is reasonable as long as %o7 is not used in compiled Scheme
code, which it isn't. (One of the reasons why %o7 should not be used
for the return address is because it is needed as a work register for
"lea".)  The above construct is also fast -- a call completes in 1
cycle, so the entire operation takes only 2 cycles and 2 instructions.
Furthermore, by manipulating the branch address of the call, we can do
a branch and "lea" all-in-one.

It is worth noting that all exceptions cause a millicode procedure to be
called. The millicode calling conventions are discussed in a subsequent
section; for now, assume that calling a millicode routine consists
of loading the return address into register %o7, getting the millicode
address from the millicode table, and branching to that code. This simple
protocol suffices for exception handling within the procedure prologue
and the call. (This is the second reason why %o7 should not be used for
return addresses -- it is used for the millicode return address.)


5. Procedure entry
------------------ 

The code for procedure entry (the "prologue") must in general save the
passed stack pointer, allocate a stack frame (flushing the stack if it
overflows), initialize temporaries which will not be initialized by
the code before the frame may be flushed to the heap, copy arguments
from registers to slots in the frame, and initialize the book-keeping
information in the frame (the size, at least: it is at the moment
unclear whether the return value slot should be initialized).

The most general procedure entry code looks like this (explanations
are in-line and follow the code):

! Assume frame size FSIZE (in bytes, rounded up to nearest 8)
! and argument count ACOUNT (encoded as a fixnum).
!
! Allocate stack frame, checking for overflow. The stack overflow
! exception causes return to the next instruction, as it is not
! an error per se.

    st      %ARGREG3, [ %STKP ]                ! store r.addr in caller's frame
    ld      [ %GLOBALS+SP_LIMIT_OFFSET ], %g1  ! Get stack limit
    cmp     %STKP, %g1                         ! check stack pointer
    bgt,a   L1                                 ! Skip if no overflow
    sub     %STKP, A_FSIZE, %STKP              ! Allocate frame (in delay slot)
    ld      [ %MILLICODE+M_STKOFLOW ], %g1     ! Stack overflow code
    jmpl    %g1, %o7
    nop
    sub     %STKP, A_FSIZE, %STKP              ! Alloc frame (after trap)

! We now have a frame. Now must set it up. For arguments passed in the
! machine-mapped registers, do a "store double" (std) for each
! pair. For arguments in memory-mapped registers, do a "load double"
! (ldd) into a temporary register pair (like TMP2,TMP3) and then
! do a std into the frame.

L1:
    std     %REG0, [ %STKP+8 ]                 ! save proc and arg 1 in frame
    std     %REG2, [ %STKP+16 ]                ! save args 2 and 3
      :
    ldd     [ %GLOBALS+REG8_OFFSET ], %TMP2    ! fetch memory-mapped args
    std     %TMP2, [ %STKP+40 ]                ! save args 8 and 9
      :
    cmp     %RESULT, ACOUNT                    ! check for 1 argument
    mov     FSIZE, %g1                         ! real frame size
    beq     L2                                 ! correct args?
    std     %g0, [ %STKP+0 ]                   ! save retaddr and frame size
    call    Lexception                         ! invoke exception handler
    add     %o7, (L1-(.-4))-8, %o7             ! return to L1
L2:

The code for the exception handler is this:

Lexception:
    ld      [ %MILLICODE + M_EXCEPTION ], %TMP0
    jmp     %TMP0
    nop

The exception handler can deal with timer expirations, wrong argument
counts, and non-procedure applications without being given explicit
information. Details are given in a later section.

The "adjusted frame size" A_FSIZE is the real frame size rounded up to
a doubleword.

Notice the adjustment of "-8" on the effective address calculations.
The adjustment is necessary because a standard return jumps to the
instruction at (return address + 8).  Since there is no sense in
using both adjusted and unadjusted returns, and since we cannot get
rid of the adjusted ones easily, we will use them everywhere.

The number of dynamic instructions in the procedure entry code, with n
arguments, assuming no stack overflow, is given by the formula:

    9 + ceiling( n+1 / 2 ) + max( 0, ceiling( n-7 / 2 ) )

where the first term accounts for various setup instructions, the
second for the argument storing instructions, and the third for extra
loads from memory-mapped registers. Initializing slots for temporary
variables come in addition to this, with 1 instruction per 2
temporaries initialized to 0 plus some overhead:

    mov     %g0, %g1
    std     %g0, [ %STKP+n ]
    std     %g0, [ %STKP+n+8 ]

etc. This assumes that the first temporary is doubleword aligned. If
that is not the case, then a single store will have to be used at some
point; similarly if the last temporary is the first in a doubleword.

The number of instructions is of little actual interest because the time
is dominated totally by the memory accesses, even with a small frame.

Note that because %g1 is known to be a temporary, we can use it to
tweak the code some; the register pair %g0/%g1 can be used as the
source of some doubleword stores to initialize temporaries and
book-keeping information.

For leaf procedures, the stack setup and return address save can both
be omitted, resulting in the somewhat simpler code:

L0:
    cmp     %RESULT, 4                            ! 1 argument?
    bne     L1                                    ! skip if ok
    nop
    call    Lexception                            ! exception handler
    add     %o7, (L0-(.-4))-8, %o7
L1:


6. Calling a procedure
---------------------- 
Tail calls and non-tail calls are very similar; the only difference is
that while the tail call deallocates the current stack frame, the
non-tail call must setup the return address. The bulk of the call
looks the same for both cases.

Setting up the call involves computing the parameters and moving them
to the correct parameter registers. Then the argument count must be
set up, the procedure must be checked to make sure it is a procedure,
and then the call must be performed. In addition the timer must be
decremented; if the timer reaches 0, then a timer interrupt must be
handled. 

Now, assuming arguments are set up with the presumed procedure in %REG0,
a tail call looks like the following:

    and	     %REG0, TAGMASK, %TMP1              ! get procedure tag
    cmp      %TMP1, PROCTAG                     ! really procedure?
    beq,a    L3                                 ! skip if procedure
    deccc    %TIMER                             ! Count down timer, set CC

! Non-procedure exception. L1 is any convenient return point
! within this procedure for a non-procedure error (perhaps
! just before the procedure position of the call was evaluated?)

    call     Lexception
    add      %o7, (L1-(.-4))-8, %o7

L3:
    bne      L4                                  ! Timer zero?
    mov      4, %RESULT                          ! setup arg count (1 arg)

! Timer expired exception. We later return to L4 since
! argument count is already set up.

    call     Lexception
    nop                                          ! no reason for an LEA here

L4:
    ld       [ %REG0+A_CODEVECTOR ], %TMP0       ! get code vector
    jmp      %TMP0+A_CODEOFFSET                  ! invoke procedure
    add      %SP, 16, %SP                        ! deallocate frame

(A_CODEVECTOR and A_CODEOFFSET are offsets into the procedure and
bytevector structures, respectively, which adjust for tags. Defined in
"layouts.s.h".)

After seeing all this, non-tail calls are not much different; in fact,
only the last basic block changes.

L4:
    ld       [ %REG0+A_CODEVECTOR ], %TMP0       ! Get code vector
    call     .+8                                 ! Get PC into %o7
    add      %o7, (L5-(.-4))-8, %ARGREG3         ! Return address
    jmp      %TMP0+A_CODEOFFSET                  ! Invoke procedure
    nop                                          ! can usually be filled
L5:

A trivial optimization is to note that if we return to the instruction
after the jump's branch delay slot (like here), we can do rather better:

L4:
   ld        [ %REG0 + A_CODEVECTOR ], %TMP0
   jmpl      %TMP0 + A_CODEOFFSET, %ARGREG3
   nop
L5:


7. Returning from a procedure
-----------------------------
In general, to return from a procedure, we must deallocate the stack
frame, get the return address in the previous continuation, and then
jump to that address. There is also the sticky issue of stack
underflow -- i.e. we've reached a point where a frame must be restored
from the heap. Rather than checking for this all the time, it is
reasonable to have a dummy continuation on the bottom of the stack
which, when returned through, will restore a continuation frame from
the heap and return to the correct procedure. (The millicode routine
M_STKUFLOW does exactly this; see "memory.txt" for details. The dummy
continuation is set up and maintained by the procedure "init_mem()" in
"memsupport.c"; the compiled code should *never* have to worry about
it.)

Assuming the existence of such a procedure, then, we get the following
code for the return, assuming that the return value has been stored
into the RESULT register:

    ld      [ %STKP + A_FSIZE ], %TMP0 ! get return address of previous frame
    jmp     %TMP0+8                    ! return
    add     %STKP, A_FSIZE, %STKP      ! deallocate frame

The running time of this code can be improved somewhat if an
instruction can be inserted between the load and the jump, since there
is a dependency between the two resulting in a stall.

In a leaf procedure the return address is usually kept in a register, and
so returning is simpler:

    jmp     %ARGREG3+8
    nop

where the slot typically can be filled with something useful like setting up
the return value.


8. Calling millicode
--------------------
All millicode procedures are called indirectly through the global
array "millicode", a pointer to which is in the register %MILLICODE.
The offsets into the table are defined in the file "millicode.h"
for both C and assembly language.

Millicode procedures take 0, 1, 2, or 3 arguments. If there are
arguments, they are passed in the registers RESULT, ARGREG2, and
ARGREG3, in left-to-right order. All results are returned in the
RESULT register.  If there are no results, as in the case of e.g.
"setcar()", then RESULT is set to fixum( 0 ). ARGREG2 and ARGREG3 are
preserved across millicode calls and may hence be used as rootable
temporaries. [This guarantee is here because the memory management
millicode upholds it; if other millicode cannot, then we'll remove the
guarantee. The compiler will have to be somewhat sophisticated,
anyway, to use the argument registers as temps.]

Every millicode procedure requires that the return address is set up
in register %o7 when the procedure is entered, and that %REG0 has a
pointer to the procedure that called the millicode procedure.  [It
would be unreasonable for the millicode to require the return address
to be stored in the continuation, because the continuation may not
exist.]

To call a millicode procedure, then, we have the following code
snippets. First, assuming we're returning to the instruction
following the call:

    ld      [ %MILLICODE + M_<something> ], %TMP0
    jmpl    %TMP0, %o7
    nop

Second, assuming we're returning to some other place (within the same
code vector!), in this case "L2":

    ld      [ %MILLICODE + M_<something> ], %TMP0
    call    .+8
    add     %o7, (L2-(.-4))-8, %o7
    jmp     %TMP0
    nop

The unfilled delay slots can usually be used for setting up a millicode
argument; in the worst case the "load" can go in the call's slot and
the "add" can go in the jump's slot.


9. Calling Scheme procedures from C (preliminary)
-------------------------------------------------

Inter-language calls are relatively "heavy", as there is a significant
amount of protocol that has to be taken care of in the call. The steps can
be summarized thusly:

        1) saving the current C context
        2) setting up a Scheme context
        3) setting up arguments for the Scheme code
        4) calling the Scheme code
        5) saving the new Scheme context
        6) setting up the C return value
        7) restoring the C context
        8) returning to the C code

Calling an assembly language millicode procedure from C is typically
equivalent to calling a Scheme procedure, as the millicode procedures
assume that the machine is in a Scheme state.

The mechanism described in the following is believed to be general enough
to support C calling Scheme calling C calling Scheme, and so on. It has
not been shown rigorously, however, that the generality really exists.

Typically, the eight steps are carried out by some conversion routine
written in assembly language. Examples are given below.


1) Saving the current C context

The C calling conventions and the SunOS window trap handlers require a
specific stack layout on the C stack (pointed to by %o6, also known as
%sp, in every window). The layout consists of two general areas: one
area for spilling register windows into (64 bytes), and one area for
spilling and passing arguments in (typically 32 bytes). The stack
pointer of the previous window (%i6, also known as %fp) always points
to end of the highest-addressed word in this frame, and is used by
the trap handler to locate the memory in which to spill the previous
window, if necessary. Hence:

  %fp  -->    +--------------------+     (high address)
              |      Argument      |
              |        area        |
              |     (32 bytes)     |
              +--------------------+
              |                    |
              |       Window       |
              |      overflow      |
              |        area        |
              |     (64 bytes)     |
              |                    |
  %sp  -->    +--------------------+     (low address)

One important point is that the argument save area set up by a particular
procedure is not for use by that procedure itself, but rather by the
procedures called by that procedure. Hence, a procedure saves its arguments
in the previous frame, at a positive offset from %fp.

To save the current C context and allocate space, one must allocate a
new window and stack space, and save whatever critical values that are
in the %i (and %g, if any) registers after the allocation. If there
was one argument passed, then the code may look like this:

        save    %sp, -96, %sp                   ! allocate 24 words
        st      %i0, [ %fp+0x40 ]               ! save the argument
        st      %i7, [ %fp+0x44 ]               ! save the return address

Saving the return address is vital, as the Scheme code uses register %i7.
Note that at the time of the "save", %sp must point to an even-addressed
word, otherwise an alignment error will occur. This is automatically true
if all stack frames have an even number of words.


2) Setting up the Scheme context

Before the Scheme procedure can be called, the virtual machine must be
initialized. The values that need to be restored to virtual machine
registers are all in the "globals" array. Of course, the registers
%GLOBALS and %MILLICODE also need to be set up.  The procedure
"_restore_scheme_context", defined in "memory.s", does exactly these
tasks. It should simply be called, either directly (from non-relocatable
code) or indirectly, through the millicode table. In the former case
it is simple:

        call    _restore_scheme_context
        nop

If we need to jump though the millicode table, remember that the %MILLICODE
register is not yet set up! Therefore, we need to use the global variable
directly:

        set     _millicode, %g1
        ld      [ %g1 + M_RESTORE_CONTEXT ], %g1
        jmpl    %g1, %o7
        nop

When that procedure returns, the virtual machine has been initialized, and
the CPU registers are in "Scheme mode".


3) Setting up arguments for the Scheme code

Typically, this involves copying arguments from the argument save area which
was set up in part (1), above, to the Scheme argument registers. In the case
of our 1-argument procedure, we have something like

        ld      [ %fp+0x40 ], %REG1


4) Calling the Scheme code

This has been covered in the preceding sections; since the machine is
now in Scheme mode, we simply use the standard Scheme calling
conventions: set up a continuation (with the calling procedure being
set to 0 if it is non-relocatable), set up the argument count, save the
return address in a registers, and jump to the callee.


5) Saving the new Scheme context

When the Scheme procedure returns, the virtual machine state must be saved
again in the "globals" array. The procedure "_save_scheme_context" in
"memory.s" does this; it is called just like "_restore_scheme_context" was
called (above).


6) Setting up the C return value

The C return value goes into register %i0 (before a "restore" is
performed, or into register %o0 after the "restore"). In the case of a
single return value from the Scheme program, we can either move it
from the %RESULT register to the C return register (since %RESULT is
still available, this being before the "restore), or we can move it
from the "globals" table. The latter technique is more general, since
it allows us to use the machine registers without having to know the
Scheme register mappings. In the latter case, we will have something
like:

        set     _globals, %g1
        ld      [ %g1 + RESULT_OFFSET ], %i0


7) Restoring the C context

We usually do not want to restore the saved arguments from the argument
save area. We will need to restore the return address, however, and whatever
global registers were used for global register variables. So typically,
we'll have this:

        ld      [ %fp+0x44 ], %i7


8) Returning to the C code

Since we're now back in C mode, returning to the C caller is like returning
from a C procedure:

        jmp     %i7+8                ! This is the 'ret' pseudo-instruction
        restore


10. Calling C procedures from Scheme (preliminary)
--------------------------------------------------
A C procedure cannot be called directly from a Scheme procedure because 
the latter may be moved by the garbage collector before the C procedure
returns (in the general case). The call therefore has to go via a
piece of non-relocatable code. Assume, therefore, that there is a 
millicode procedure

    void C_call( void (*func)() )

which performs the call for some C procedure "func". The rest of this
section describes what C_call() has to look like. [If func() takes
arguments, we must find some way of passing them; the millicode
procedure could take a list of arguments as its second argument.]

These are the steps that C_call() must go trough:

1) set up continuation frame; save return address in this frame
2) save scheme context
3) setup C continuation
4) call C procedure
5) pop C continuation
6) restore scheme context
7) restore return address; pop the continuation frame
8) If the caller's continuation frame has been flushed to the heap, it
   must be restored.
9) return to caller

If we were guaranteed that the caller sets up a frame (and we can
probably force this to be true) then it would be rather simpler:

1) save return address in caller's frame
2) save Scheme context
3) setup C continuation
4) call C procedure
5) pop C continuation
6) restore Scheme context
7) restore return address
8) return to caller

The last step will automagically bring the caller's frame into the
stack, if necessary.

I won't cover these steps in detail (yet).
