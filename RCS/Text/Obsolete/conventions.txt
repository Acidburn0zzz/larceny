; -*- Text -*-
; $Id: conventions.txt,v 1.5 91/06/25 21:33:27 lth Exp Locker: lth $

		Calling Conventions and Register Usage
				   
			    --------------


0. Scope of this Document
-------------------------
This document discusses the mapping of virtual-to physical registers
on the Sparc, the use of non-mapped Sparc registers, the use of stacks
for Scheme and C, the calling conventions for Scheme and C procedures
on the Sparc, the layout of continuation (both in the stack and on the
heap), and the layout of procedures (closures). Finally, we discuss the
calling conventions for millicode procedures.


1. Register usage and mapping
--------------------------
The mapping of virtual to physical registers is defined in the header
file "registers.s.h", and is also summarized below. The following
discussion highlights some of the trade-offs.

The Sparc manual is unclear about which of the global registers
%g1-%g7 we can use. %g1 is clearly available.  If we don't care about
Sparc ABI compliance, we can use all.  Franz Allegro Common Lisp uses
all the global registers. Currently, we use only %g1, and there is no
immediate need for using any of the others, although at some level of
optimization, more registers will clearly be beneficial.

The "call" instruction uses %o7 to store the return address; we cannot
in general use this instruction for calling out-of-line library
procedures, but it is convenient to simulate a "call" using the "jmpl"
instruction, because calling the millicode becomes cheaper that way
(this is discussed in some detail below).  Therefore, we should
reserve %o7 for this use.

Likewise, we will want two stacks: one for C and one for Scheme. This
choice lets us tailor the Scheme calling conventions without having to
worry about interrupts and related messes, which reqire a specific
stack layout. The C stack follows these conventions. Since the C stack
pointer must at all times be in register %o6, we cannot use
this register for Scheme.

Hence we are left with 23 registers available to Scheme: %g1, %i0-%i7,
%l0-%l7, and %o0-%o5. We have the following virtual and work register
classes to map onto those registers (their function is elaborated on
later):

REG0 ... REGn, for some n. 
  These are the general-purpose virtual registers. A subset must be
  mapped to physical registers, and the rest will be in memory.
  Rootable.

RESULT
  The register in which we return a value. Rootable.

ARGREG2
  Second argument to a millicode call. Rootable.

ARGREG3
  Third argument to a millicode call. Rootable.

STKP
  Scheme stack pointer. Nonrootable.

E_TOP, E_LIMIT, and others
  Heap pointers. Nonrootable.

GLOBALS
  A register pointing to a set of global variables. Nonrootable.

MILLICODE
  A register pointing to a set of millicode procedure addresses. 
  Nonrootable. (?)

TIMER
  The countdown timer register. Nonrootable.

TMP0 ... TMPm, for some m
  Temporary registers. Nonrootable, I think. [Or a mixture of rootable
  an nonrootable. The current memory management millicode assumes that
  TMP0, TMP1, and TMP2 are nonrootable, but it does not take much to
  change that.]

It is convenient for the purposes of code generation to have
even-numbered general-purpose registers mapped to even-numbered
machine registers, as this saves instructions and cycles in some cases
when a "store double" instruction can be used. This also requires that
the Scheme stack pointer always be double-word aligned.

The number of temporary registers needed is unclear; the more the
better is a good rule, but there is clearly a limit. Again, the more
sophisticated the compiler, the more temps are probably needed. For
reasons which will become clear later, %g1 should be mapped to a TMP
register. Also, some two of the temporaries should be allocated so
that they can be used as a register pair, since this allows certain
tweaks.

Here is the current mapping:

   REG0 ... REG7   -->  i0 ... i7
   RESULT          -->  o3
   ARGREG2         -->  o4
   ARGREG3         -->  o5
   STKP            -->  o2
   E_TOP           -->  o0
   E_LIMIT         -->  o1
   GLOBALS         -->  l7
   MILLICODE       -->  l6
   TIMER           -->  l0
   TMP0            -->  g1
   TMP1 ... TMP5   -->  l1 ... l5

Note that %g1 is a temporary, and %TMP2/%TMP3 (among others) is a
temporary-register pair.


2. Continuations
----------------
There are two continuation layouts: in the stack and on the heap. Heap
continuations are never manipulated directly by compiled Scheme code;
instead, they are created on stack overflow or on the capture of a
continuation, and restored into the stack on a stack underflow or the
application of a continuation.

Stack continuations have the following layout (memory addresses
increasing going down the figure):

%STKP --> pppp pppp pppp pppp pppp pppp pppp pppp   return address
          ssss ssss ssss ssss ssss ssss ssss ss00   continuation size
          pppp pppp pppp pppp pppp pppp pppp p111   procedure (saved REG0)
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   argument  (saved REG1)
          ....
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   temporary (initially 0)
          ....

The continuation size is the number of bytes used by the continuation
including the return address and the size field.  A continuation
should always be an even number of words, but the size field should
indicate the number of used actually words, i.e. less any padding
words. This doubleword alignment of the stack lets us save some
instructions as outlined below. The unused word of the continuation
should always be the highest word in the frame, and it may remain
uninitialized, if desired: the stack flushing routine deals with it in
a coherent way.

As a special case the procedure word may be all 0's, in which case the
return address will not be adjusted when the stack frame is flushed to
the heap. This allows the creation of frames which correspond to
nonrelocatable code. [Whether such frames will be necessary is another
question, but at some point it seemed that they might. The current version
of "schemestart.s" creates such a continuation.]

When the stack cache is flushed into the heap, each frame is made into
a vector-like structure with the following structure:

      --> 0sss ssss ssss ssss ssss ss00 101x xx10   vector header word
          llll llll llll llll llll llll llll llll   dynamic link or #f
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xx00   return offset
          pppp pppp pppp pppp pppp pppp pppp p111   procedure (saved REG0)
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   argument  (saved REG1)
          ....
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   temporary (initially 0)
          ....

The return offset is the offset into the code vector of the saved
procedure to which point the return address pointed before the frame
was flushed to the heap. The code vector is a byte vector; the offset
is from the start of the bytevector header, not from the start of the
first instuction. Note that all words in the heap continuation frame
must be valid scheme objects; hence, if there is a chance that a frame
is flushed before all temporaries are used, then the temporaries must
be initialized by the procedure entry code.

The tags of the headers which distinguish continuations from other
vector types are defined in the file "datatypes.txt".


3. Procedures (Preliminary)
---------------------------
A procedure looks much like a vector (although it has a distinguished
header):

     --> 0sss ssss ssss ssss ssss ssss 1111 1110    header
         pppp pppp pppp pppp pppp pppp pppp p101    bytevector ptr (to code)
         pppp pppp pppp pppp pppp pppp pppp p111    proc ptr (static link)
         pppp pppp pppp pppp pppp pppp pppp p011    vector ptr (to constants)
         xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx    data slot
         ....

This layout has the advantage of letting several closures share a
constant vector; however, it means a double dereference to get at a
constant. An alternative is to put all constants in the procedure
vector itself.

Also, what goes into the data slots? Shold they hold the values of the
local variables, or should they hold the values of the parent
procedure (the one in which the closure is created) or should they
simply hold pointers to all free variables in the code of the closure?

[Since these decisions have little bearing on the discussion of the
calling conventions, they will not be answered now.]


4. Calling conventions -- some prelimiaries
-------------------------------------------
The discussion of procedure calls separates into several parts:
Procedure entry; setting up for a call; doing a tail call; doing a
non-tail call; and returning from a procedure. Each has several
variations, but for now we'll treat the most general case for each.

One operation which is used quite a bit is the equivalent of the "lea"
(load effective address) instruction on the mc68000. It calculates the
effective address of some location based on the current PC.  However,
the Sparc has no "lea" instruction, nor is the PC available to other
instructions than the "call" instruction. On the other hand, since the
"call" instruction is PC-relative, we can use it to extract the PC and
calculate an effective address from there! So assume we want to say

	lea	L2, %TMP0		! compute effective address into %TMP0

then we really say

	call	.+8			! "." means "current pc"
	add	%o7, (L2-(.-4)), %TMP0

This setup is reasonable as long as %o7 is not used in compiled Scheme
code, which it isn't. It is also fast -- a call completes in 1 cycle,
so the entire operation takes only 2 cycles and 2 instructions.
Furthermore, by manipulating the branch address of the call, we can do
a branch and "lea" all-in-one. [I admit that I'm a little proud of
this construction.]

It is worth noting that all exceptions cause a millicode procedure to be
called. The millicode calling conventions are discussed in a subsequent
section; for now, assume that calling a millicode routine consists
of loading the return address into register %o7, getting the millicode
address from the millicode table, and branching to that code. This simple
protocol suffices for exception handling within the procedure prologue
and the call.


5. Procedure entry
------------------
The code for procedure entry (the "prologue") must allocate a stack
frame (flushing the stack if it overflows), initialize temporaries,
copy arguments to slots in the frame, and initialize the book-keeping
information in the frame (the size and the return value).

The procedure entry code looks like this (explanations are in-line and
follow the code):

! Assume frame size FSIZE (in bytes, rounded up to nearest 8)
! and argument count ACOUNT (encoded as a fixnum).
!
! Allocate stack frame, checking for overflow. The stack overflow
! exception causes return to the next instruction, as it is not
! an error per se.

    ld      [ %GLOBALS+SP_LIMIT_OFFSET ], %g1  ! Get stack limit
    cmp     %STKP, %g1
    bgt,a   L1                                 ! Skip if no overflow
    sub     %STKP, FSIZE, %STKP                ! Allocate frame (in slot)
    ld      [ %MILLICODE+M_STKOFLOW ], %g1     ! Stack overflow code
    jmpl    %g1, %o7
    nop
    sub     %STKP, FSIZE, %STKP                ! Alloc frame (after trap)

! We now have a frame. Now must set it up. For arguments passed in the
! machine-mapped registers, do a "store double" (std) for each
! pair. For arguments in memory-mapped registers, do a "load double"
! (ldd) into a temporary register pair (like TMP2,TMP3) and then
! do a std into the frame.

L1:
    std     %REG0, [ %STKP+8 ]                 ! save proc and arg 1 in frame
    std     %REG2, [ %STKP+16 ]                ! save args 2 and 3
      :
    ldd     [ %GLOBALS+REG8_OFFSET ], %TMP2    ! fetch memory-mapped args
    std     %TMP2, [ %STKP+40 ]                ! save args 8 and 9
      :
    cmp     %RESULT, ACOUNT                    ! check for 1 argument
    mov     FSIZE, %g1                         ! frame size
    beq     L2                                 ! correct args?
    std     %g0, [ %STKP+0 ]                   ! save retaddr and frame size
    call    Lexception                         ! invoke exception handler
    add     %o7, (L1-(.-4))-8, %o7             ! return to L1
L2:

The code for the exception handler is this:

Lexception:
    ld      [ %MILLICODE + M_EXCEPTION ], %TMP0
    jmp     %TMP0
    nop

The exception handler can deal with timer expirations, wrong argument
counts, and non-procedure applications without being given explicit
information. Details are given in a later section.

Notice the adjustment of "-8" on the effective address calculations.
The adjustment is necessary because a standard return jumps to the
instruction at (return address + 8).  Since there is no sense in
using both adjusted and unadjusted returns, and since we cannot get
rid of the adjusted ones easily, we will use them everywhere.

The number of dynamic instructions in the procedure entry code, with n
arguments, assuming no stack overflow, is given by the formula:

    8 + ceiling( n+1 / 2 ) + max( 0, ceiling( n-7 / 2 ) )

where the first term accounts for various setup instructions, the
second for the argument storing instructions, and the third for extra
loads from memory-mapped registers. Initializing slots for temporary
variables come in addition to this, with 1 instruction per 2
temporaries initialized to 0 plus some overhead:

    mov     %g0, %g1
    std     %g0, [ %STKP+n ]
    std     %g0, [ %STKP+n+8 ]

etc. This assumes that the first temporary is doubleword aligned. If
that is not the case, then a single store will have to be used at some
point; similarly if the last temporary is the first in a doubleword.

Note that because %g1 is known to be a temporary, we can use it to
tweak the code some; the register pair %g0/%g1 can be used as the
source of some doubleword stores to initialize temporaries and
book-keeping information.


6. Calling a procedure
---------------------- 
Tail calls and non-tail calls are very similar; the only difference is
that while the tail call deallocates the current stack frame, the
non-tail call must setup the return address. The bulk of the call
looks the same for both cases.

Setting up the call involves computing the parameters and moving them
to the correct parameter registers. Then the argument count must be
set up, the procedure must be checked to make sure it is a procedure,
and then the call must be performed. In addition the timer must be
decremented; if the timer reaches 0, then a timer interrupt must be
handled. 

[It turns out that decrementing and testing the timer is nearly free;
if we were to use the UNIX interval timer it would be rather more
expensive, since the interrupt handler for the timer would not have
access to the register in which we keep the timer, and we'd have to do
a load. On the other hand, if there are other interrupts to handle
(can't offhand think of any, at least under UNIX), we'd have to fall
back on the set-and-test-a-variable strategy.]

Now, assuming arguments are set up with the presumed procedure in %REG0,
a tail call looks like the following:

    and	     %REG0, TAGMASK, %TMP1              ! get procedure tag
    cmp      %TMP1, PROCTAG                     ! really procedure?
    beq,a    L3                                 ! skip if procedure
    deccc    %TIMER                             ! Count down timer, set CC

! Non-procedure exception. L1 is a convenient return point
! within this procedure for a non-procedure error (perhaps
! just before the procedure position of the call was evaluated?)

    call     Lexception
    add      %o7, (L1-(.-4))-8, %o7

L3:
    bne      L4                                  ! Timer zero?
    mov      4, %RESULT                          ! setup arg count

! Timer expired exception. We later return to L4 since
! argument count is already set up.

    call     Lexception
    add      %o7, (L4-(.-4))-8, %o7

L4:
    ld       [ %REG0+CODEVECTOR ], %TMP0         ! get code vector
    jmp      %TMP0+CODEOFFSET                    ! invoke procedure
    add      %SP, 16, %SP                        ! deallocate frame


After seeing all this, non-tail calls are not much different; in fact,
only the last basic block changes. (In the code below the delay slot
in the call has been used for the load, thereby avoiding a dependency
between the load and the jump, saving a cycle; this means that we must
adjust somewhat the constants in the add that calculates the effective
address.)

L4:
    call     .+8                                 ! Get PC into %o7
    ld       [ %REG0+CODEVECTOR ], %TMP0         ! Get code vector
    add      %o7, (.+4-L4), %o7                  ! Calculate address of "jmp"
    jmp      %TMP0+CODEOFFSET                    ! Invoke procedure
    st       %o7, [ %STKP ]                      ! Save return address


7. Returning from a procedure
-----------------------------
In general, to return from a procedure, we must deallocate the stack
frame, get the return address in the previous continuation, and then
jump to that address. There is also the sticky issue of stack
underflow -- i.e. we've reached a point where a frame must be restored
from the heap. Rather than checking for this all the time, it is
reasonable to have a dummy continuation on the bottom of the stack
which, when returned through, will restore a continuation frame from
the heap and return to the correct procedure. (The millicode routine
M_STKUFLOW does exactly this; see "memory.txt" for details. The dummy
continuation is set up and maintained by the procedure "init_mem()" in
"memsupport.c"; the compiled code should *never* have to worry about
it.)

Assuming the existence of such a procedure, then, we get the following
code for the return, assuming that the return value has been stored
into the RESULT register:

    ld      [ %STKP + FSIZE ], %TMP0   ! get return address of previous frame
    jmp     %TMP0+8                    ! return
    add     %STKP, FSIZE, %STKP        ! deallocate frame

The running time of this code can be improved somewhat if an
instruction can be inserted between the load and the jump, since there
is a dependency between the two resulting in a stall.


8. Calling millicode
--------------------
All millicode procedures are called indirectly through the global
array "millicode", a pointer to which is in the register %MILLICODE.
The offsets into the table are defined in the file "millicode.h"
for both C and assembly language.

Millicode procedures take 0, 1, 2, or 3 arguments. If there are
arguments, they are passed in the registers RESULT, ARGREG2, and
ARGREG3, in left-to-right order. All results are returned in the
RESULT register.  If there are no results, as in the case of e.g.
"setcar()", then RESULT is set to fixum( 0 ). ARGREG2 and ARGREG3 are
preserved across millicode calls and may hence be used as rootable
temporaries. [This guarantee is here because the memory management
millicode upholds it; if other millicode cannot, then we'll remove the
guarantee. The compiler will have to be somewhat sophisticated,
anyway, to use the argument registers as temps.]

Every millicode procedure requires that the return address is set up
in register %o7 when the procedure is entered, and that REG0 has a
pointer to the procedure that called the millicode procedure.  [It
would be unreasonable for the millicode to require the return address
to be stored in the continuation, because the continuation may not
exist.]

To call a millicode procedure, then, we have the following code
snippets. First, assumeing we're returning the the instruction
following the call:

    ld      [ %MILLICODE + M_<something> ], %TMP0
    jmpl    %TMP0, %o7
    nop

Second, assuming we're returning to some other place (within the same
code vector!), in this case "L2":

    call    .+8
    ld      [ %MILLICODE + M_<something> ], %TMP0
    add     %o7, (L2-(.-8)), %o7
    jmp     %TMP0
    nop

The unfilled delay slots can usually be used for setting up a millicode
argument.


9. Calling C procedures (preliminary)
-------------------------------------
The procedures in "memory.s" show some examples of inter-language
calling, both in limited cases (like '_stkuflow' calling
'_restore_frame') and in the most general case ('gcstart' calling
'_gcstart2'). The mechanism used in 'gcstart' can (and should) be
factored out to be useable by other procedures as well.
