; -*- Text -*-
; $Id: memory.txt,v 1.7 91/07/16 13:23:59 lth Exp Locker: lth $

                 Memory Manager Interface Definition

                       --------------------


0. Scope of this Document
-------------------------
This document discusses the interface between the memory management system
and the compiled Scheme application. Rules for the interaction are set
forth and some examples are presented. 

Section 1 discusses the application interface to the memory manager
allocation, mutation, and management procedures.  Section 2 discusses
the application interface to the memory manager initialization
procedures.  Section 3 shows some examples for the SPARC. Section 4
discusses the SPARC implementation.


1. The application interface to the memory manager
-------------------------------------------------- 
Of all memory management procedures in the run-time system, the
compiled code should call only the procedures exported from
"memory.s", all of which are listed below, and which from now on will
be collectively referred to as "the memory management millicode
procedures", abbreviated "the MMMPs". All MMMPs except "stkuflow()",
"restore_continuation()", "save_scheme_context()", and
"restore_scheme_context()" may invoke the garbage collector.

MMMPs follow millicode calling conventions as outlined in
"conventions.txt".

The procedures exported from "memory.s" are the following, shown using
C declaration syntax. The names in brackets are the symbolic names for
the procedures' offsets within the "millicode" array.

word *alloc( word n )                       [ M_ALLOC ]
  Allocates n uninitialized words on the heap and returns an untagged
  pointer to the first (lowest-addressed) word. Since the words are not
  initialized, they must be initialized by the caller of alloc() before
  any other procedure which might invoke the garbage collector is
  called. If n is odd, it will be rounded upward to an even number; the 
  caller need not initialize the resulting padding word.

word *alloci( word i, word v )              [ M_ALLOCI ]
  Allocates n words on the heap and initializes each to the value v,
  returning an untagged pointer to the first (lowest-addressed) word.
  If n is odd, it is rounded upward to an even number; the resulting
  padding word may or may not be initialized by alloci(), and the caller
  should not depend on any particular behavior in this respect.

void setcar( word p, word v )               [ M_SETCAR ]
  If p is a tagged pointer to a pair, then the 'car' field of the pair is
  set to the value v. The value of RESULT is undefined after a call to 
  setcar(), but is guaranteed to be a valid Scheme object. If p is not
  a tagged pointer to a pair, then the effect of calling setcar() is 
  undefined.

void setcdr( word p, word v )               [ M_SETCDR ]
  Like setcar(), only the 'cdr' field is affected rather than the 'car' field.

void vectorset( word p, word i, word v )    [ M_VECTORSET ]
  If p is a tagged pointer to a vector, and i is a valid index into the 
  vector, then the i'th element of the vector is set to the value v. The 
  value of RESULT is undefined after a call to vectorset(), but is guaranteed 
  to be a valid Scheme object. If p is not a tagged pointer to a vector, or
  if i is not a valid index into the vector pointed to by p, then the effect
  of calling vectorset() is undefined. The argument i must be a fixnum.

word *gcstart( word n )                     [ M_GCSTART ]
  If n is the fixnum representing -1, then the garbage collector is
  invoked to do a tenuring collection, and the value of RESULT is
  unchanged (modulo address updates). Otherwise, the garbage collector
  is invoked to collect the ephemeral area, a block of n words is
  allocated as for alloc(), above, and RESULT is set to an untagged
  pointer to the allocated memory. A tenuring collection may be invoked
  even if n is not -1, depending on the internal state of the collector.
  The parameter n must be a fixnum.

void stkuflow( void )                       [ M_STKUFLOW ]
  'Stkuflow 'retrieves a continuation frame from the heap and puts it at
  the top of the stack cache (growing down). Typically, there will be a
  dummy continuation at the top of the stack cache. This continuation
  contains a return address which points to 'stkuflow'; when underflow
  occurs, 'stkuflow' is invoked and handles the underflow, returning to
  the return address in the newly-fetched stack frame. A stack underflow
  will never cause a garbage collection.

void stkoflow( void )                       [ M_STKOFLOW ]
  'Stkoflow' should be invoked from the compiled application to flush the
  stack cache. The flush may cause a garbage collection.

void save_scheme_context( void )            [ M_SAVE_CONTEXT ]
  'Save_scheme_context' saves the hardware-mapped part of the virtual machine
  state into the "globals" array. If the virtual machine has not been
  previously initialized, then the results are undefined. This procedure
  is useful for inter-language calls.

void restore_scheme_context( void )         [ M_RESTORE_CONTEXT ]
  'Restore_scheme_context' sets up the hardware-mapped part of the virtual
  machine state from the saved values in the "globals" array. If "globals"
  has not been properly initialized, then the results are undefined. This
  procedure is useful for inter-language calls.

word capture_continuation( void )           [ M_CAPTURE ]
  'Capture_continuation' returns a tagged pointer to a structure which
  represents the current continuation at the time the capture procedure was
  called.

void restore_continuation( word c )         [ M_RESTORE ]
  'Restore_continuation takes a tagged pointer to a continuation structure
  as returned from 'capture_continuation' and reinstates that continuation.
  The continuation which was current at the time 'restore_continuation' was
  called is simply discarded.


2. Initializing the memory manager
----------------------------------
The memory manager is initialized with a call to the procedure "init_mem()",
which is defined in the file "memsupport.c". It is typically called from
the initialization code in "main.c", and should be called before any other
initialization code which may use memory is called. It takes five parameters:

- 'e_size' is the requested size of the ephemeral area, in bytes;
- 't_size' is the requested (initial) size of the tenured area, in bytes;
- 's_size' is the requested size of the static area, in bytes;
- 'stk_size' is the requested size of the stack cache area, in bytes; and
- 'e_lim' is the requested offset, in bytes from the bottom of the
  ephemeral area, of the ephemeral watermark. If the live data in the
  ephemeral area after an ephemeral collection overflows past the
  watermark, then the next collection will be a tenuring collection.

The "init_mem()" procedure will initialize the garbage collector and then
set up the values at global table offsets E_LIMIT and STK_LIMIT. It will
also setup a dummy continuation at the bottom (high addresses) of the
stack cache to catch stack underflows, which may occur after stack flushes.


3. Examples of use of the memory manager
----------------------------------------

! Generic CONS using alloc()
!
! Assume values to cons are in REG1 and REG2 and that pointer to new 
! cell is to be left in RESULT. (If the arguments were in an even/odd 
! register pair, we would use 'std' rather than 'st'.)
!
! The following code can be improved by moving the 'or' between the stores
! and using an adjusted offset in the second store.

    ld      [ %MILLICODE + M_ALLOC ], %TMP0    
    jmpl    %TMP0, %o7                        ! allocate it
    mov     fixnum( 2 ), %RESULT
    st      %REG1, [ %RESULT+CAR_OFFSET ]
    st      %REG2, [ %RESULT+CDR_OFFSET ]
    or      %RESULT, PAIR_TAG, %RESULT        ! set tag

! Open-coded CONS, same assumptions as above.
!
! This code uses 11 cycles in the general case, but can be made to use
! only 10 (effectively) if another instruction can be scheduled between
! the stores. In general, if a store double can be used (even/odd register
! pair) then that will be beneficial.
!
! This code depends on there being a small heap overflow area which can
! validly be written into as long as the values written into it can be
! forgotten. This condition is guaranteed (and should be documented).
!
! [As an aside, 11 cycles is only 2 more than the "optimal" 9 which is
!  possible if one does not check for heap overflow and rather takes a 
!  SIGSEGV when the pair is initialized, a la SML/NJ.]

L0: st      %R1, [ %E_TOP ]
    add     %E_TOP, 8, %E_TOP                     ! allocate optimistically
    cmp     %E_TOP, %E_LIMIT                      ! overflow?
    st      %R2, [ %E_TOP-4 ]
    blt,a   L1                                    ! jump if not
    add     %E_TOP, -8+PAIR_TAG, %RESULT
    call    Lcollect
    add     %o7, (L0-(.-4))-8, %o7
L1:


! Lcollect is shown below; it can be shared for the entire procedure.
! The entry point 'Lcollect' is used for open-coded cons calls (requests
! 0 bytes); the entry point 'Lcollect1' is used for procedures setting
! up their own requests.

Lcollect:
    mov     0, %RESULT
Lcollect1:
    ld      [ %MILLICODE + M_GCSTART ], %TMP0
    jmp     %TMP0
    nop


4. The SPARC Implementation
---------------------------
The SPARC implementation of the MMPS is unspectacular. The highlights
are the (arguably sick, vile, and unnatural) internal calling
conventions, and the internal subroutines for garbage collection and
transaction management. In addition, some strategy decisions will be
discussed.

You will want to look at a source listing of "memory.s" before you
read too much of the following.


4.1 Internal calling conventions
--------------------------------
Whenever a millicode procedure is called, its return address (to
Scheme code) must be in %o7. This value is known as the ERA or
"external return address". In the case of a garbage collection, it is
expected to change, and must hence be dealt with in that respect.
However, MMMPs are never moved, and hence if an MMMP calls another,
the millicode return address (known as the MRA) can be saved anywhere.
Currently, if such a call happens (i.e. _alloc calls gcstart), the ERA
is saved in %TMP0, where gcstart expects to find it, and the MRA (into
_alloc) is saved in %o7 by the "call" instruction. Only one level of
millicode calls is possible using this convention, since there is no
provision for millicode to stuff an MRA anywhere but in %o7, which of
course can hold only one. So far the MMMPs have needed only one level
of non-tail calls internally, but a much better solution would be to
have an internal stack on which to push MRAs. It is somewhat unclear
whether this would be a problem for reentrancy; the MMMPs are never
entered more than once, so this is not an issue here.

Since some MMMPs (like _stkoflow and _stkuflow) may not change the
%RESULT register, and since at least the overflow procedure may
trigger a garbage collection, and since gcstart changes %RESULT, then
these MMMPs must save %RESULT for later restoring it. The place of
choice for this save is in globals[ SAVED_RESULT_OFFSET ], which is
for this use. It is a rootable location. Currently, _stkoflow,
_stkuflow, _setcar, _setcdr, and _vectorset save %RESULT across calls
to internal millicode procedures.


4.2 Internal Subroutines
------------------------
There are two internal subroutines: gcstart (not to be confused with
the publicly available _gcstart), and addtrans. The former initiates a
garbage collection and has the same semantics as _gctrans (see above);
the latter adds a transaction to the transaction list if possible and
triggers a collection (by calling gcstart) if not possible (due to tenured
heap overflow).


4.3 Strategy
------------
The big question in this section is what kind of collections to
trigger on various kinds of heap overflows. For some situations (e.g.
if _alloc overflows the heap) the answer is obvious; for others (e.g.
if _stkoflow overflows the heap), it is not. This section summarizes
the current decisions and comments on their appropriateness.

If _alloc or _alloci find that memory cannot be allocated because the
ephemeral heap is full, they call gcstart with an argument corresponding
to the number of words to allocate, forcing gcstart to trigger an
ephemeral collection.

If _stkoflow fills up the ephemeral heap, it calls gcstart with an argument
of fixnum( -1 ), which triggers a tenuring collection. The reason why
it does not instead trigger an ephemeral collection is that heap overflow
due to stack spills is most likely a sign of deep recursion, meaning
in turn that a lot of data will be retained. If this is indeed the case,
then the ephemeral collection will simply have to be followed by a tenuring
collection. It is possible that we should investigate the options here
somewhat better before committing to the current choice.

If addtrans discovers that the tenured heap is full, it triggers a full
collection. A more refined approach would be to try to compact the transaction
list, and only when that fails, do a tenuring collection.
