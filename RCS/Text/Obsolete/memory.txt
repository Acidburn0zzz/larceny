; -*- Text -*-
; $Id: memory.txt,v 1.6 91/07/05 15:20:06 lth Exp Locker: lth $

                 Memory Manager Interface Definition

                       --------------------


0. Scope of this Document
-------------------------
This document discusses the interface between the memory management system
and the compiled Scheme application. Rules for the interaction are set
forth and some examples are presented. 

Section 1 discusses the application interface to the memory manager
allocation, mutation, and management procedures.  Section 2 discusses
the application interface to the memory manager initialization
procedures.  Section 3 shows some examples.


1. The application interface to the memory manager
-------------------------------------------------- 
Of all memory management procedures in the run-time system, the
compiled code should call only the procedures exported from
"memory.s", all of which are listed below, and which from now on will
be collectively referred to as "the memory management millicode
procedures", abbreviated "the MMMPs". All MMMPs except "stkuflow()",
"restore_continuation()", "save_scheme_context()", and
"restore_scheme_context()" may invoke the garbage collector.

MMMPs follow millicode calling conventions as outlined in
"conventions.txt".

The procedures exported from "memory.s" are the following, shown using
C declaration syntax. The names in brackets are the symbolic names for
the procedures' offsets within the "millicode" array.

word *alloc( word n )                       [ M_ALLOC ]
  Allocates n uninitialized words on the heap and returns an untagged
  pointer to the first (lowest-addressed) word. Since the words are not
  initialized, they must be initialized by the caller of alloc() before
  any other procedure which might invoke the garbage collector is
  called. If n is odd, it will be rounded upward to an even number; the 
  caller need not initialize the resulting padding word.

word *alloci( word i, word v )              [ M_ALLOCI ]
  Allocates n words on the heap and initializes each to the value v,
  returning an untagged pointer to the first (lowest-addressed) word.
  If n is odd, it is rounded upward to an even number; the resulting
  padding word may or may not be initialized by alloci(), and the caller
  should not depend on any particular behavior in this respect.

void setcar( word p, word v )               [ M_SETCAR ]
  If p is a tagged pointer to a pair, then the 'car' field of the pair is
  set to the value v. The value of RESULT is undefined after a call to 
  setcar(), but is guaranteed to be a valid Scheme object. If p is not
  a tagged pointer to a pair, then the effect of calling setcar() is 
  undefined.

void setcdr( word p, word v )               [ M_SETCDR ]
  Like setcar(), only the 'cdr' field is affected rather than the 'car' field.

void vectorset( word p, word i, word v )    [ M_VECTORSET ]
  If p is a tagged pointer to a vector, and i is a valid index into the 
  vector, then the i'th element of the vector is set to the value v. The 
  value of RESULT is undefined after a call to vectorset(), but is guaranteed 
  to be a valid Scheme object. If p is not a tagged pointer to a vector, or
  if i is not a valid index into the vector pointed to by p, then the effect
  of calling vectorset() is undefined. The argument i must be a fixnum.

word *gcstart( word n )                     [ M_GCSTART ]
  If n is the fixnum representing -1, then the garbage collector is
  invoked to do a tenuring collection, and the value of RESULT is
  unchanged (modulo address updates). Otherwise, the garbage collector
  is invoked to collect the ephemeral area, a block of n words is
  allocated as for alloc(), above, and RESULT is set to an untagged
  pointer to the allocated memory. A tenuring collection may be invoked
  even if n is not -1, depending on the internal state of the collector.
  The parameter n must be a fixnum.

void stkuflow( void )                       [ M_STKUFLOW ]
  'Stkuflow 'retrieves a continuation frame from the heap and puts it at
  the top of the stack cache (growing down). Typically, there will be a
  dummy continuation at the top of the stack cache. This continuation
  contains a return address which points to 'stkuflow'; when underflow
  occurs, 'stkuflow' is invoked and handles the underflow, returning to
  the return address in the newly-fetched stack frame. A stack underflow
  will never cause a garbage collection.

void stkoflow( void )                       [ M_STKOFLOW ]
  'Stkoflow' should be invoked from the compiled application to flush the
  stack cache. The flush may cause a garbage collection.

void save_scheme_context( void )            [ M_SAVE_CONTEXT ]
  'Save_scheme_context' saves the hardware-mapped part of the virtual machine
  state into the "globals" array. If the virtual machine has not been
  previously initialized, then the results are undefined. This procedure
  is useful for inter-language calls.

void restore_scheme_context( void )         [ M_RESTORE_CONTEXT ]
  'Restore_scheme_context' sets up the hardware-mapped part of the virtual
  machine state from the saved values in the "globals" array. If "globals"
  has not been properly initialized, then the results are undefined. This
  procedure is useful for inter-language calls.

word capture_continuation( void )           [ M_CAPTURE ]
  'Capture_continuation' returns a tagged pointer to a structure which
  represents the current continuation at the time the capture procedure was
  called.

void restore_continuation( word c )         [ M_RESTORE ]
  'Restore_continuation takes a tagged pointer to a continuation structure
  as returned from 'capture_continuation' and reinstates that continuation.
  The continuation which was current at the time 'restore_continuation' was
  called is simply discarded.


2. Initializing the memory manager
----------------------------------
The memory manager is initialized with a call to the procedure "init_mem()",
which is defined in the file "memsupport.c". It is typically called from
the initialization code in "main.c", and should be called before any other
initialization code which may use memory is called. It takes five parameters:

- 'e_size' is the requested size of the ephemeral area, in bytes;
- 't_size' is the requested (initial) size of the tenured area, in bytes;
- 's_size' is the requested size of the static area, in bytes;
- 'stk_size' is the requested size of the stack cache area, in bytes; and
- 'e_lim' is the requested offset, in bytes from the bottom of the
  ephemeral area, of the ephemeral watermark. If the live data in the
  ephemeral area after an ephemeral collection overflows past the
  watermark, then the next collection will be a tenuring collection.

The "init_mem()" procedure will initialize the garbage collector and then
set up the values at global table offsets E_LIMIT and STK_LIMIT. It will
also setup a dummy continuation at the bottom (high addresses) of the
stack cache to catch stack underflows, which may occur after stack flushes.


3. Examples of use of the memory manager
----------------------------------------

! Generic CONS using alloc()
!
! Assume values to cons are in REG1 and REG2 and that pointer to new 
! cell is to be left in RESULT. (If the arguments were in an even/odd 
! register pair, we would use 'std' rather than 'st'.)
!
! The following code can be improved by moving the 'or' between the stores
! and using an adjusted offset in the second store.

    ld      [ %MILLICODE + M_ALLOC ], %TMP0    
    jmpl    %TMP0, %o7                        ! allocate it
    mov     fixnum( 2 ), %RESULT
    st      %REG1, [ %RESULT+CAR_OFFSET ]
    st      %REG2, [ %RESULT+CDR_OFFSET ]
    or      %RESULT, PAIR_TAG, %RESULT        ! set tag

! Open-coded CONS, same assumptions as above.
!
! This code uses 11 cycles in the general case, but can be made to use
! only 10 (effectively) if another instruction can be scheduled between
! the stores. In general, if a store double can be used (even/odd register
! pair) then that will be beneficial.
!
! This code depends on there being a small heap overflow area which can
! validly be written into as long as the values written into it can be
! forgotten. This condition is guaranteed (and should be documented).
!
! [As an aside, 11 cycles is only 2 more than the "optimal" 9 which is
!  possible if one does not check for heap overflow and rather takes a 
!  SIGSEGV when the pair is initialized, a la SML/NJ.]

L0: st      %R1, [ %E_TOP ]
    add     %E_TOP, 8, %E_TOP                     ! allocate optimistically
    cmp     %E_TOP, %E_LIMIT                      ! overflow?
    st      %R2, [ %E_TOP-4 ]
    blt,a   L1                                    ! jump if not
    add     %E_TOP, -8+PAIR_TAG, %RESULT
    call    Lcollect
    add     %o7, (L0-(.-4))-8, %o7
L1:


! Lcollect is shown below; it can be shared for the entire procedure.
! The entry point 'Lcollect' is used for open-coded cons calls (requests
! 0 bytes); the entry point 'Lcollect1' is used for procedures setting
! up their own requests.

Lcollect:
    mov     0, %RESULT
Lcollect1:
    ld      [ %MILLICODE + M_GCSTART ], %TMP0
    jmp     %TMP0
    nop
