; -*- Text -*-
; $Id: gcinterface.txt,v 1.4 91/07/01 12:49:10 lth Exp Locker: lth $

		  Garbage Collector Interface Definition

		       (Garbage collector version 3)

			   --------------------


0. Scope of this Document
-------------------------
This document describes the conventions that must be followed by an
application using the garbage collector (henceforth called "the
mutator").  There are specifications for collector initialization,
space allocation, data formats, and invariants that must be upheld by
the mutator.

For the compiler writer, the only really interesting sections are the
ones dealing with data formats, memory layout, and memory allocation.
(Sections 2, 3, 5, and 6.)

This document does not describe the internal workings of the garbage 
collector.

Other relevant documents are "memory.txt", which describes the
higher-level interface to the memory management system, and "gc.txt",
which describes the implementation of the garbage collector.


1. General Conventions
----------------------
All global variables defined by the collector are kept in the "globals"
table. They must have their correct values when the "collect()" procedure
is called.  However, the mutator may keep these variables in registers
between calls to the collector.

Algorithms for allocation are described in C but will in practice be coded
in assembly language if the mutator runs compiled code that uses processor
registers for virtual machine registers.


2. Data Formats
---------------
A pointer has a 2 or 3 bit type tag in the low order bits. Structures on
the heap (except pairs) have a type tag in the first word. All heap
structures must be aligned on an 8-byte boundary.

The following are the tagged pointer formats.

  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xx00   fixnum
  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xx10   immediate
  pppp pppp  pppp pppp  pppp pppp  pppp p001   pointer to pair 
  pppp pppp  pppp pppp  pppp pppp  pppp p011   pointer to vector struct
  pppp pppp  pppp pppp  pppp pppp  pppp p101   pointer to bytevector struct
  pppp pppp  pppp pppp  pppp pppp  pppp p111   pointer to procedure struct

The following are the immediate formats.

  0000 0000  0000 0000  0000 0000  0000 0010   #f
  0000 0000  0000 0000  0000 0000  0000 0110   #t
  0000 0000  0000 0000  0000 0000  0000 1010   empty list
  xxxx xxxx  xxxx xxxx  xxxx xxxx  0001 0110   miscellaneous
  0000 0000  cccc cccc  0000 0000  0010 0110   character
  0sss ssss  ssss ssss  ssss ssss  100x xx10   reserved header
  0sss ssss  ssss ssss  ssss ssss  101x xx10   vector-like header
  0sss ssss  ssss ssss  ssss ssss  110x xx10   bytevector-like header
  0sss ssss  ssss ssss  ssss ssss  1111 1110   procedure header

The "xxx" bits in the low byte of a header can be used by the mutator to
distinguish between different subtypes of structures; they are neither
used nor examined by the collector.

The "s" bits must contain the size of the data structure in bytes, not
including the header word, and not including padding (see below). The
collector will correctly round "bytevector" and "reserved" lengths up
to a word boundary. Hence, for these structures, the "s" bits give the
correct length of the datum, like the length of a string. For vectors
and procedures the s field must be evenly divisible by 4 (low two bits
are 0).

Since all pointers are doubleword-aligned, some vectors, bytevectors,
and procedures will have to be padded out to an even number of words.
The mutator must allocate the extra word but may choose to leave it
uninitialized; the collector will take the size of the vector into
account and skip the padding. If the word is initialized, it may or
may not be copied along with the structure during a collection.

The structure layouts are these:

  - Pairs: A pair has two words, the car (low word) and the cdr (high word).
    The pair pointer points to the car of the pair.

  - A vector-like structure has the header word in the low position, followed
    by tagged pointers in all locations of the vector. The vector pointer
    points to the header word.

  - A bytevector-like structure has the header word in the low position,
    followed by untagged bytes in all locations of the vector. The bytevector
    pointer points to the header word.

  - A procedure structure has the header word in the low position, followed
    by tagged pointers in all locations of the procedure structure. To the
    collector, and with the exception of the tag, a procedure looks just like
    a vector-like structure. The interpretation of each word of the procedure
    structure is up to the mutator. The procedure pointer points to the
    header word.

  - There is a "reserved" header but currently no "reserved" data layout; the
    collector does not know about the "reserved" header.


3. The Collector's World View
-----------------------------
There are four areas of memory, denoted the Static, Ephemeral, Tenured, and
Stack areas. There is also a set of Root Pointers.

- The Static area has no out-pointers and will not be used for roots
  during a collection, nor will pointers into the Static area be traversed
  during a collection. The collector allocates this area as requested
  but never references it.

- The Ephemeral area is used for data structure creation; all memory 
  allocation is performed in the ephemeral area.

- The Tenured area is used for keeping data structures that are assumed
  to have an extended life. No memory is ever allocated directly in
  the Tenured area; data structures are created here only when they are
  moved from the Ephemeral area. The Tenured area also holds the 
  "transaction list", which is a set of pointers to data structures in 
  the Tenured area which might have pointers to data structures in the
  Ephemeral area.

- The Stack area has no in-pointers and is used only by the mutator; the
  collector allocates this area but never references it. If there are
  out pointers from the Stack area into the Tenured or Ephemeral areas,
  these pointers must also exist in data structures in those areas or
  in the root pointer set.

- The root pointers are those elements of the global table "globals"
  (which is not defined by the collector module) between the indices
  FIRST_ROOT and LAST_ROOT, both of which are constants which must be
  defined in the file "offsets.h". The "globals" table must be an array
  of the data type "word", which is defined in the file "gcinterface.h".

The collector defines the following variables in the "globals" table
(the names used are the symbolic names of the offsets into the table,
as defined in the file "offsets.h"):

E_BASE_OFFSET   A pointer pointing to the first word of the current
                Ephemeral space.
E_TOP_OFFSET    A pointer pointing to the first unallocated word of the
                current Ephemeral space.
E_MAX_OFFSET    A pointer to the last word of the current Ephemeral 
                space.
E_NEW_BASE_OFFSET
E_NEW_MAX_OFFSET
		Ditto for the ephemeral newspace. The mutator should *never*
		use these values.
E_MARK_OFFSET   A byte offset from the bottom of the Ephemeral area. If, after
		a collection of the ephemeral area, the data in the Ephemeral
                area goes past this mark, then the next collection will be a
		tenuring collection. The mutator may change the value of this
		variable at will.

T_BASE_OFFSET   A pointer to the first word of the current Tenured
                space.
T_TOP_OFFSET    A pointer to the first unallocated word of the current
                Tenured space.
T_TRANS_OFFSET  A pointer to the last word of the current Tenured space
                before the transaction area; the transactions are allocated
                towards low memory.
T_MAX_OFFSET    A pointer to the last word of the current Tenured area.
                The words between T_MAX_OFFSET (inclusive) and 
                T_TRANS_OFFSET (exclusive) make up the transaction list.
T_NEW_BASE_OFFSET
T_NEW_MAX_OFFSET
		Ditto for the tenured newspace.

S_BASE_OFFSET   A pointer to the first word of the Static space.
S_MAX_OFFSET    A pointer to the last word of the Static space.

STK_BASE_OFFSET A pointer to the first word of the Stack space.
STK_MAX_OFFSET  A pointer to the last word of the Stack space.

LOMEM_OFFSET    A pointer to the first word used by the collector. Obsolete.
HIMEM_OFFSET    A pointer to the last word used by the collector. Obsolete.

The mutator may only change T_TRANS_OFFSET, T_TOP_OFFSET, E_MARK_OFFSET,
and E_TOP_OFFSET; all other values are to be considered read-only to the
mutator. All Tenured and Ephemeral pointers are subject to change after a
collection. [T_TOP_OFFSET is not normally changed, but if we load a heap
into the tenured area, it will have to be. Also, if we want to be able to
allocate an object larger than the Ephemeral area, it will have to be
allocated directly in the Tenured area, and in that case T_TOP_OFFSET must
change.]

All pointers into all spaces are comparable. The Ephemeral area pointers
always compare less than the Tenured area pointers. The relations of and to
the other areas is implementation-defined, and may indeed change at run-time.


4. Initializing the collector
-----------------------------
The collector is initialized with a call to 'init_collector()':

  init_collector( s_size, t_size, e_size, stack_size );

where 's_size', 't_size', and 'e_size', and 'stack_size' are the sizes (in
bytes) of the Static, Tenured, Ephemeral, and Stack areas, respectively.

Upon initialization, the collector will honor the given sizes insofar as
they do not violate the constraints set forth in the header file "gc.h".
The collector will change unreasonable values into reasonable ones.

The file "gc.h" and its contents are described in section 10.


5. Memory Allocation
--------------------
For the purposes of the following discussions, we will assume that there
is a variable E_LIMIT_OFFSET which the mutator will use as the allocation
limit for the Ephemeral area. One cannot use E_MAX_OFFSET for this, for the
following reason: When the Ephemeral area is full, and the collector
must be invoked, the Stack will need to be copied into the Ephemeral area.
Hence we must guarantee that there is room between E_LIMIT_OFFSET and
E_MAX_OFFSET to spill the stack in. E_LIMIT_OFFSET is not used by the
collector, and it is the responisbility of the mutator to calculate
its value based on E_MAX_OFFSET after a collection.

To allocate 'n' words from the ephemeral area, the procedure would be this:

   word *alloc( int n )
   {
     word *p;

     p = globals[ E_TOP_OFFSET ];

     /* Allocate the requested memory; round number of words to even */
     globals[ E_TOP_OFFSET ] += n + (n & 0x01);

     /* Check for ephemeral area overflow */
     if (globals[ E_TOP_OFFSET ] >= globals[ E_LIMIT_OFFSET ]) 
       p = gc( n );

     return p;
   }

where the 'gc()' procedure performs a collection, allocates 'n' words, and
returns a pointer to the newly-allocated space; a possible implementation
is shown below.

The first two statements allocate memory (notice that we must allocate an
even number of words always, even if an odd number was requested). If the
allocation moves 'E_TOP_OFFSET' beyond 'E_LIMIT_OFFSET', the collector is
invoked.  Otherwise, a pointer to the structure is returned.

Note that in the case of a collection, the 'gc()' procedure is made to
allocate the requested space. This is so that we can conveniently have
out-of-line checks for whether 'E_TOP_OFFSET' >= 'E_LIMIT_OFFSET' 
after the allocation; this may in fact happen.


6. The Transaction List
-----------------------
Memory for the 'transaction list' -- the list of pointers to data
structures in the Tenured space which contain pointers into the Ephemeral
space -- is allocated in the Tenured area.

Whenever the mutator side-effects a data structure in the tenured area
(using e.g. 'set-car!', 'set-cdr!', or 'vector-set!') with a value that is
a tagged pointer into the Ephemeral area, then a transaction should be
added to the transaction list. The transaction should be a tagged pointer
not to the new object but to the header of the data structure in the
Tenured area that was changed.

The value stored into the Tenured-area data structure does not strictly
speaking have to be a pointer into the Ephemeral area, but it is necessary
to store a transaction on the transaction list when the stored value is
such a pointer.  The collector deals with entries on the transaction list
which are not pointers into the tenured area in a reasonable way.

To allocate a transaction on the tranaction list, put the transaction in
the location pointed to by the pointer T_TRANS_OFFSET, and then decrement
this pointer. Then change the value in the data structure in the Tenured
space.  Entries are allocated from the top of the tenured area with the
initial value of T_TRANS_OFFSET being T_LIMIT_OFFSET.

If, before allocating space for the entry, T_TRANS_OFFSET < T_TOP_OFFSET,
then the tenured area has overflowed, and must be collected. The mutator
must check this.

We provide some example code for 'set-car!':

   void set_car( word objp, word val )
   {
     /* Check if we're storing into a Tenured object */
     if (ptrof( objp ) >= globals[ T_BASE_OFFSET ]) {
       if (globals[ T_TRANS_OFFSET ] < globals[ T_TOP_OFFSET ]) {
         /* at this point do a tenuring collection */
       }
       *globals[ T_TRANS_OFFSET ]-- = objp;
     }
     *ptrof( objp ) = val;
   }


7. Calling the Garbage Collector
--------------------------------
The garbage collector traces all objects reachable from the set of root
objects, as outlined in section 3.  It is the duty of the storage
allocating procedures (like 'alloc()' above) to store all root objects in
the 'globals' table before the collector is invoked. In the case of
'alloc()' it calls the procedure 'gc()', which could look something like
this:

   gc( int n )
   {
     word *p;

     globals[ RO_OFFSET ] = R0;
     globals[ R1_OFFSET ] = R1;
       :
     globals[ Rn_OFFSET ] = Rn;

     flush_stack_cache();
     flush_instruction_cache();

     collect( EPHEMERAL_COLLECTION );

     R0 = globals[ R0_OFFSET ];
     R1 = globals[ R1_OFFSET ];
       :
     Rn = globals[ Rn_OFFSET ];

     calculate_e_limit();

     p = globals[ E_TOP_OFFSET ];
     globals[ E_TOP_OFFSET ] += n + (n & 0x01);
     if (globals[ E_TOP_OFFSET ] >= globals[ E_LIMIT_OFFSET ]) {
       /* at this point either do major GC or just give up. */
     }
     return p;
   }

[This code assumes that we have two stacks: one for Scheme, and one for C.
 If that is not the case, we will need to implement stack switching here
 as well.]

First all rootable registers (R0 through Rn) are stored.  There might be
other registers as well, depending on the implementation.  

Then the stack cache is flushed. This code is not shown here, as it depends
on the details of the stack layout, which in turn is irrelevant in the
context of this document.

Flushing the instruction cache is a system-dependent procedure; some
systems will not need it. A selective flush is probably best; I think (but
haven't decided yet) that it is always best to selectively flush oldspace,
which is why the icache flush comes before the collection. It is probably
equivalent to flush newspace (after the collection); and don't forget that
we must flush the icache after a 'define' (I think...).

The collector is then called. The entry point of the collector is the
'collect()' procedure; the constants EPHEMERAL_COLLECTION,
TENURING_COLLECTION, and FULL_COLLECTION are defined in the file
"gcinterface.h"

Finally, when the collector has finished, each element of the 'globals'
array is copied out to where they came from (they may all have changed).  A
new E_LIMIT_OFFSET is computed, and space is allocated. (If we fail again,
there is one more hope: to do a tenuring collection. The code for this has
not been shown.)


8. Memory statistics
--------------------
The garbage collector keeps track of how much space is allocated and
collected from the heap. These statistics are available in variables
in the 'globals' array with the following names/offsets:

E_COLLECTIONS_OFFSET    The number of ephemeral garbage collections.
T_COLLECTIONS_OFFSET    The number of tenuring garbage collections.
F_COLLECTIONS_OFFSET    The number of full garbage collections.
WCOLLECTED_OFFSET       The number of words collected (total).
WALLOCATED_OFFSET       The number of words allocated (total).
WCOPIED_OFFSET          The number of words copied (total).

The number of words allocated is derived from the difference in the
values of E_TOP_OFFSET just after a collection and just before the next
one. Hence, if E_TOP_OFFSET has an invalid value (as it may legally have
when the collector is called), then this statistic may be thrown off.
(If 'alloc()' and 'gc()' are implemented like it was suggested earlier,
a quick fix is for 'gc()' to subtract its argument from E_TOP_OFFSET.)


9. Requirements
---------------
The garbage collector requires the availability of the following 
procedures:

   malloc()  Standard C library memory allocation procedure
   panic()   Must be provided by the mutator. It takes one
             argument (a string), and displays this string
             before terminating the program. Panic() will
             be called in the case of an unrecoverable error,
             and should not return to its caller.

It also requires the following variable:

   extern word globals[]

which is the 'globals' table that has been mentioned above.
The procedures and the variable should all be declared in "gc.h".

Furthermore, "gc.h" must define all the offsets into the 'globals' table.


10. Setting the Limits
----------------------
The file "gc.h" contains a number of #definitions of limits on the various
memory area. The collector use these definitions as sanity checks on the
arguments to 'init_collector()'. The utility of this facility is to remove
the chore of sanity checking from the mutator.  However, the programmer
needs to come up with values to use. The comments in the header file should
adequately explain the restrictions.


11. Interface
-------------
The collector module exports three names: 'collect()', 'init_collector()',
and 'gc_trap()', all of which are procedures. 

'collect()' takes a single argument, which must be an integer. The values
EPHEMERAL_COLLECTION, TENURING_COLLECTION, and FULL_COLLECTION are defined
in "gcinterface.h". Other valued cause a panic().

'init_collector()' takes four arguments, all unsigned integers, as outlined
above.

'gc_trap()' takes one argument, an integer. 

- If the argument is EPHEMERAL_TRAP, it means that the ephemeral area 
  overflowed. Typically this happens if one tries to allocate a data 
  structure larger than the ephemeral area. 

- If the argument is TENURED_TRAP, it means that the tenured area overflowed.
  This could happen if there are too many tenured objects (i.e.
  during a collection).

If 'gc_trap()' returns to its caller, the caller is to repeat the failed
operation, hoping that 'gc_trap()' solved the problem by allocating more
memory.

It should be noted that 'gc_trap()' currently calls 'panic()' with some
appropriate error message, and that its interface to the surrounding
world may be too simple for realistic cases. It may therefore be considered
"experimental".

The symbolic arguments to "gc_trap()" are defined in "gcinterface.h".


12. Notes
---------
- HIMEM and LOMEM are obsolete.

- The initialization routine will eventually take an additional argument
  which is the alignment to use in allocating memory for the spaces. On many
  systems, the alignment will be on a page boundary; this is interesting
  because we have to set access privileges on some of the spaces.
