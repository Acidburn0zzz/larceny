% -*- TeX -*-
% $Id: conventions.txt,v 1.10 91/08/12 12:33:03 lth Exp Locker: lth $

\input{larceny.sty}

\title{Larceny Note \#1: \\
       Register Usage, Continuation Layout, and Calling Conventions \\
       {\tenrm (draft)}}
\author{Lars Thomas Hansen}

\begin{document}
\maketitle

\begin{abstract}
This document discusses the mapping of virtual-to-physical registers
on the Sparc, the use of non-mapped Sparc registers, the use of stacks
for Scheme and C, the calling conventions for Scheme and C procedures
on the Sparc, the layout of continuations (both in the stack and on
the heap), and the layout of procedures (closures). There is also a
discussion of the calling conventions for millicode procedures and the
calling conventions for inter-language (C to Scheme, Scheme to C, and
Scheme to Scheme via millicode) calls.
\end{abstract}

\section{Register Usage}

The mapping of virtual to physical registers is defined in the header
file \verb+"registers.s.h+, and is also summarized below. That file
also define symbolic names for registers for use by assembly language
procedures.  The following discussion highlights some of the
trade-offs.

The Sparc version 8 manual states that in order to maintain Sparc ABI
compliance, only the global registers \%g1-\%g4 are available, while
\%g5-\%g7 are reserved for systems use. It is unclear what constitutes
``systems use'', and it appears that if we don't care about Sparc ABI
compliance, we can use all the global registers. Since our register
model already violates the Sparc ABI spec, there is little point in
staying away from the global registers.

The ``call'' instruction uses \%o7 to store the return address; we
cannot in general use the ``call'' instruction for calling out-of-line
library procedures, but it is convenient to simulate a ``call'' using
the ``jmpl'' instruction, because calling the millicode becomes
cheaper that way (this is discussed in some detail below).  Therefore,
we should reserve \%o7 for miscellaneous operations involving a return
address.

Likewise, we will want two stacks: one for C and one for Scheme. This
choice lets us tailor the Scheme calling conventions without having to
worry about interrupts and related problems, which reqire a specific
stack layout. The C stack follows the conventions necessary to deal
with asynchronous events. Since the C stack pointer must at all times
be in register \%o6, we cannot use this register for Scheme.

Since the operating system window overflow trap handler uses the stack
pointers of previous windows (i.e. \%i6 after a save), the \%i6
register cannot be used by Scheme, either.

Although \%i7 holds the return address of the previous procedure in the
C calling conventions, we can simply save it somewhere (typically on
the C stack), so \%i7 is available.

Hence we are left with 28 registers available to Scheme: \%g1-\%g7,
\%i0-\%i5, \%i7, \%l0-\%l7, and \%o0-\%o5. We have the following virtual 
and work register classes to map onto those registers (their function
is elaborated on later):

\begin{description}

\item {\bf REG0 ... REGn, for some n}

These are the general-purpose virtual registers. A subset must be
mapped to physical registers, and the rest will be in memory.
Rootable.

\item {\bf RESULT}

The register in which we return a value and pass argument counts. Also used
to pass the first argument to millicode procedures. Rootable.

\item {\bf ARGREG2}

Second argument to a millicode procedure. Rootable.

\item {\bf ARGREG3}

Third argument to a millicode procedure. Rootable.

\item {\bf STKP}

Scheme stack pointer. Nonrootable.

\item {\bf E\_TOP, E\_LIMIT, and others (perhaps STK\_LIMIT)}

Heap pointers. Nonrootable.

\item {\bf GLOBALS}

A register pointing to an array of global variables. Nonrootable.

\item {\bf MILLICODE}

A register pointing to a vector of pointers to millicode procedures. 
Nonrootable. This register could be the same register as GLOBALS; in the
current implementation they are different registers.

\item {\bf TIMER}

The countdown timer register. Nonrootable.

\item {\bf TMP0 \ldots TMPm, for some m}

Temporary registers. Nonrootable.
\end{description}

It is convenient for the purposes of code generation to have
even-numbered general-purpose registers mapped to even-numbered
machine registers, as this saves instructions and cycles in some cases
when a "store double" instruction can be used. This also requires that
the Scheme stack pointer always be double-word aligned.

The number of temporary registers needed is unclear; the more the
better is a good rule, but there is clearly a limit. Again, the more
sophisticated the compiler, the more temps are probably needed. For
reasons which will become clear later, %g1 should be mapped to a TMP
register. Also, some two of the temporaries should be allocated so
that they can be used as a register pair, since this allows certain
tweaks.

The current register mapping is shown in table \ref{mappings}.

\begin{table}[hbt]
\begin{center}
\begin{tabular}{|l|l|} \hline
   REG0 ... REG7 &  l0 ... l7  \\
   RESULT        &  o0 \\
   ARGREG2       &  o1 \\
   ARGREG3       &  o2 \\
   STKP          &  o3 \\
   E\_TOP         &  o4 \\
   E\_LIMIT       &  o5 \\
   GLOBALS       &  i7 \\
   MILLICODE     &  i5 \\
   TIMER         &  i4 \\
   TMP0          &  g1 \\
   TMP1          &  i0 \\
   TMP2          &  i1 \\ \hline
\end{tabular}
\end{center}
\caption{Virtual-to-physical register mapping}
\label{mappings}
\end{table}

Note that \%g1 is a temporary, and that \%TMP1/\%TMP2 is a temporary-register
pair.

The symbolic names SAVED\_RESULT, SAVED\_ARGREG2, SAVED\_ARGREG3, and
SAVED\_STKP can be used to access the RESULT, ARGREG2, ARGREG3, and
STKP registers after a ``save'' instruction has been executed.


\section{Continuations}

There are two continuation layouts: in the stack and on the heap. Heap
continuations are never manipulated directly by compiled Scheme code;
instead, they are created on stack overflow or on the capture of a
continuation, and restored into the stack on a stack underflow or the
reinstatement of a continuation.

Stack frames have the following layout (memory addresses increasing
going down the figure):

\begin{verbatim}
%STKP --> pppp pppp pppp pppp pppp pppp pppp pp00   return address slot
          ssss ssss ssss ssss ssss ssss ssss ss00   frame size (bytes)
          pppp pppp pppp pppp pppp pppp pppp p111   procedure (saved REG0)
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   argument  (saved REG1)
          ....
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   temporary (initially 0)
          ....
\end{verbatim}

The frame size is the number of bytes used by the frame, including the
return address and size fields.  A frame should always be an even
number of words, but the size field should indicate the number of
actually used words, i.e. less any padding words. This doubleword
alignment of the stack lets us save some instructions as outlined
below. The unused word of the frame should always be the highest word
in the frame, and it may remain uninitialized, if desired: the stack
flushing routine deals with it in a coherent way.

As a special case the procedure word may be all 0's, in which case the
return address will not be adjusted when the stack frame is flushed to
the heap. This allows the creation of frames which correspond to
nonrelocatable code.

When the stack cache is flushed into the heap, each frame is made into
a vector structure with the following layout:

\begin{verbatim}
      --> 0sss ssss ssss ssss ssss ss00 101t tt10   vector header word
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   dynamic link or #f
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xx00   return offset
          pppp pppp pppp pppp pppp pppp pppp p111   procedure (saved REG0)
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   argument  (saved REG1)
          ....
          xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx   temporary (initially 0)
          ....
\end{verbatim}

The return offset is the offset into the code vector of the saved
procedure to which point the return address pointed before the frame
was flushed to the heap. The code vector is a byte vector; the offset
is from the start of the first data byte of the bytevector, i.e. it is
a valid bytevector index.  Note that all words in the heap
continuation frame must be valid scheme objects; hence, if there is a
chance that a frame is flushed before all temporaries are used, then
the temporaries must have been initialized.

The tag of a continuation frame is an ordinary vector tag.

\section{Procedure layout}

A procedure looks much like a vector (although it has a distinguished
header and is pointed to by a distinguished pointer):

\begin{verbatim}
     --> 0sss ssss ssss ssss ssss ssss 1111 1110    header
         pppp pppp pppp pppp pppp pppp pppp p101    bytevector ptr (to code)
         vvvv vvvv vvvv vvvv vvvv vvvv vvvv v011    vector ptr (to constants)
         llll llll llll llll llll llll llll llll    static link
         xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx    data slot
         ....
\end{verbatim}

The data slots contain the contents of variables which were closed
over at run time, and the static link points to another procedure
structure. Top-level procedures do not have static links nor data slots.


\section{Calling conventions}

The discussion of procedure calls separates into several parts:
Procedure entry; setting up for a call; doing a tail call; doing a
non-tail call; and returning from a call. 

One operation which is used quite a bit is the equivalent of the ``lea''
(load effective address) instruction on the mc68000. It calculates the
effective address of some location based on the current PC.  However,
the Sparc has no ``lea'' instruction, nor is the PC available to other
instructions than the ``call'' instruction. On the other hand, since the
``call'' instruction is PC-relative, we can use it to extract the PC and
calculate an effective address from there. So assume we want to say

\begin{verbatim}
        lea     L2, %TMP0               ! compute effective address into %TMP0
\end{verbatim}

then we really say

\begin{verbatim}
        call    .+8                     ! "." means "current pc"
        add     %o7, (L2-(.-4)), %TMP0
\end{verbatim}

This setup is reasonable as long as \%o7 is not used in compiled Scheme
code, which it isn't. (One of the reasons why \%o7 should not be used
for the return address is because it is needed as a work register for
``lea''.)  The above construct is also fast -- a call completes in 1
cycle, so the entire operation takes only 2 cycles and 2 instructions.
Furthermore, by manipulating the branch address of the call, we can do
a branch and ``lea'' all-in-one.

\section{Procedure entry}

We have a caller-saves dicipline, so the callee must do very little at
procedure entry time. Typically all that is done is to check the number
of arguments, and even doing so is not mandated by the calling conventions,
but is rather a compiler issue.

In the case of a fixed number of arguments, the check is straightforward
(ARG\_COUNT is the number of expected arguments):

\begin{verbatim}
L0:
     cmp   %RESULT, ARG_COUNT
     be,a  L1
     nop
     jmpl  %MILLICODE + M_ARG_EXCEPTION
     add   %o7, L0-(.-4))-8, %o7
L1:
\end{verbatim}

The return address given to the exception handler is that of the procedure
entry point. Exception handler semantics is covered in detail in another
section.

Notice the adjustment of "-8" on the effective address calculations.
The adjustment is necessary because a standard return jumps to the
instruction at (return address + 8).  Since there is no sense in using
both adjusted and unadjusted returns, and since we cannot get rid of
the adjusted ones easily, we will use them everywhere.

In the case of a variable number of arguments, the check is a lot more 
complicated because excess arguments must be copied into a list and so
on; the entire process has been encapsulated in the millicode procedure
M\_VARARGS, and checking for a variable number of arguments involves
calling this procedure with an extra argument expressing the number of
fixed parameters (FIXED\_ARGS):

\begin{verbatim}
     jmpl   %MILLICODE + M_VARARGS, %o7
     mov    FIXED_ARGS, %ARGREG2
\end{verbatim}

\section{Stack Frame Creation}

For non-tail calls (and at some other times), the compiler will save
the live registers in a stack frame before the arguments to the call
are evaluated and the callee is invoked. The code for this involves
allocating the stack frame (cheking for overflow in the process), and
then saving the necessary registers and a return address in the new
frame. The code is straightforward, if somewhat wordy; assume that
A\_FSIZE is the adjusted (up to a doubleword boundary) size of the
frame being allocated (in bytes), and FSIZE is the real size of the
frame:

\begin{verbatim}
    ld      [ %GLOBALS+SP_LIMIT_OFFSET ], %g1  ! Get stack limit
    cmp     %STKP, %g1                         ! check stack pointer
    bgt,a   L1                                 ! Skip if no overflow
    sub     %STKP, A_FSIZE, %STKP              ! Allocate frame (delayed)
    jmpl    %MILLICODE + M_STKOFLOW, %o7
    nop
    sub     %STKP, A_FSIZE, %STKP              ! Alloc frame (after trap)
L1:
    st      %REG0, [ %STKP+8 ]                 ! save REG0
    st      %REG1, [ %STKP+12 ]                ! save REG1
      :
    ld      [ %GLOBALS + REG8_OFFSET ], %TMP0  ! fetch memory-mapped reg
    st      %TMP0, [ %STKP+40 ]                ! save REG8
      :
    call    .+8
    add     %o7, (L2-(.-4))-8, %o7             ! return to some L2
    st      %o7, [ %STKP+0 ] 
    mov     FSIZE, %g1                         ! real frame size
    std     %g1, [ %STKP+4 ]                   ! save retaddr and frame size
\end{verbatim}

Some of this code can be tweaked by using doubleword loads and stores in
several cases, but this is in general what a ``save'' looks like.

\section{Procedure Call}

Calling a procedure is fairly straightforward. The caller must decrement
the software timer (and take an exception if it has reached 0), then check
to see that the callee is indeed a procedure (and take an exception if it
is not), and finally it must set up the argument count register and branch
to the code for the callee.

Notice that the code for a tail call and the code for a non-tail call are
the same, as a stack frame (with a return address) is created separately
from the invocation of the callee.

\begin{verbatim}
L0:
     subcc  %TIMER, 1, %TIMER
     bne,a  L1
     and    %RESULT, TAG_MASK, %TMP0
     jmpl   %MILLICODE + M_TIMER_EXCEPTION, %o7
     add    %o7, L0-(.-4)-8, %o7
L1:
     cmp    %RESULT, PROC_TAG
     be,a   L2
     ld     [ %RESULT + CODEVECTOR_OFFSET - PROC_TAG ], %TMP0
     jmpl   %MILLICODE + M_PROC_EXCEPTION
     add    %o7, L1-(.-4)-8, %o7
L2:
     mov    %RESULT, %REG0
     jmp    %TMP0 + 4 - BVEC_TAG
     mov    ARGCOUNT, %RESULT
\end{verbatim}

(The bit about moving \%RESULT into \%REG0 is due to the MacScheme assembly
language calling conventions.) A call without exceptions then takes 10
clocks if the load hits the cache.

\section{Returning From a Call}

Returning from a call is almost trivial. The return address is in the
return address slot of the topmost stack frame, and all we have to do
is to get it out of there and jump to the indicated address. The result
will already have been stored in the RESULT register.

Sometimes the stack cache will underflow. To handle this, there is a dummy
continuation at the bottom of the stack which contains a return address to
the stack underflow handler. Hence, a procedure will normally return to its
caller, but sometimes it will be thrown into the underflow handler. The code
in the handler will restore a stack frame from the heap and jump to the
return address in the new frame. Neither caller nor callee will notice that
this has happened.

We therefore get the following code for the return operation:

\begin{verbatim}
    ld      [ %STKP + 0 ], %TMP0
    jmp     %TMP0+8
    nop
\end{verbatim}

Occasionally the delay slot can be filled; it is also advantageous to
try to move an instruction between the load and the jump to remove some
of the latency due to the load.

\section{Calling Millicode From Scheme}

All millicode procedures are called indirectly through the global
array "millicode", a pointer to which is in the register %MILLICODE.
The offsets into the table are defined in the file "millicode.h"
for both C and assembly language.

Millicode procedures take 0, 1, 2, or 3 arguments. If there are
arguments, they are passed in the registers RESULT, ARGREG2, and
ARGREG3, in left-to-right order. All results are returned in the
RESULT register.  If there are no results, as in the case of e.g.
"setcar()", then RESULT is set to fixum( 0 ). ARGREG2 and ARGREG3 are
preserved across millicode calls and may hence be used as rootable
temporaries. [This guarantee is here because the memory management
millicode upholds it; if other millicode cannot, then we'll remove the
guarantee. The compiler will have to be somewhat sophisticated,
anyway, to use the argument registers as temps.]

Every millicode procedure requires that the return address is set up
in register %o7 when the procedure is entered, and that %REG0 has a
pointer to the procedure that called the millicode procedure.  [It
would be unreasonable for the millicode to require the return address
to be stored in the continuation, because the continuation may not
exist.]

To call a millicode procedure, then, we have the following code
snippets. First, assuming we're returning to the instruction
following the call:

\begin{verbatim}
    ld      [ %MILLICODE + M_<something> ], %TMP0
    jmpl    %TMP0, %o7
    nop
\end{verbatim}

Second, assuming we're returning to some other place (within the same
code vector!), in this case "L2":

\begin{verbatim}
    ld      [ %MILLICODE + M_<something> ], %TMP0
    call    .+8
    add     %o7, (L2-(.-4))-8, %o7
    jmp     %TMP0
    nop
\end{verbatim}

The unfilled delay slots can usually be used for setting up a millicode
argument; in the worst case the "load" can go in the call's slot and
the "add" can go in the jump's slot.

\section{Calling Scheme procedures from C}

Inter-language calls are relatively "heavy", as there is a significant
amount of protocol that has to be taken care of in the call. The steps can
be summarized thusly:

\begin{enumerate}
\item saving the current C context
\item setting up a Scheme context
\item setting up arguments for the Scheme code
\item calling the Scheme code
\item saving the new Scheme context
\item setting up the C return value
\item restoring the C context
\item returning to the C code
\end{enumerate}

Calling an assembly language millicode procedure from C is typically
equivalent to calling a Scheme procedure, as the millicode procedures
assume that the machine is in a Scheme state.

The mechanism described in the following is believed to be general enough
to support C calling Scheme calling C calling Scheme, and so on. It has
not been shown rigorously, however, that the generality really exists.

Typically, the eight steps are carried out by some conversion routine
written in assembly language. Examples are given below.

\subsection{Saving the current C context}

The C calling conventions and the SunOS window trap handlers require a
specific stack layout on the C stack (pointed to by \%o6, also known as
\%sp, in every window). The layout consists of two general areas: one
area for spilling register windows into (64 bytes), and one area for
spilling and passing arguments in (typically 32 bytes). The stack
pointer of the previous window (\%i6, also known as \%fp) always points
to end of the highest-addressed word in this frame, and is used by
the trap handler to locate the memory in which to spill the previous
window, if necessary. Hence figure \ref{c-args}.

\begin{figure}[hbt]
\begin{verbatim}
  %fp  -->    +--------------------+     (high address)
              |      Argument      |
              |        area        |
              |     (32 bytes)     |
              +--------------------+
              |                    |
              |       Window       |
              |      overflow      |
              |        area        |
              |     (64 bytes)     |
              |                    |
  %sp  -->    +--------------------+     (low address)
\end{verbatim}
\caption{The C stack frame layout}
\label{c-args}
\end{figure}

One important point is that the argument save area set up by a particular
procedure is not for use by that procedure itself, but rather by the
procedures called by that procedure. Hence, a procedure saves its arguments
in the previous frame, at a positive offset from \%fp.

To save the current C context and allocate space, one must allocate a
new window and stack space, and save whatever critical values that are
in the \%i (and \%g, if any) registers after the allocation. If there
was one argument passed, then the code may look like this:

\begin{verbatim}
        save    %sp, -96, %sp                   ! allocate 24 words
        st      %i0, [ %fp+0x40 ]               ! save the argument
        st      %i7, [ %fp+0x44 ]               ! save the return address
\end{verbatim}

Saving the return address is vital, as the Scheme code uses register \%i7.
Note that at the time of the ``save'', \%sp must point to an even-addressed
word, otherwise an alignment error will occur. This is automatically true
if all stack frames have an even number of words.


\subsection{Setting up the Scheme context}

Before the Scheme procedure can be called, the virtual machine must be
initialized. The values that need to be restored to virtual machine
registers are all in the ``globals'' array. Of course, the registers
\%GLOBALS and \%MILLICODE also need to be set up.  The procedure
``\_restore\_scheme\_context'', defined in \verb+"Sparc/memory.s"+,
does exactly these tasks. It should simply be called, either directly
(from non-relocatable code) or indirectly, through the millicode
table. In the former case it is simple:

\begin{verbatim}
        call    _restore_scheme_context
        nop
\end{verbatim}

If we need to jump though the millicode table, remember that the \%MILLICODE
register is not yet set up! Therefore, we need to use the global variable
directly:

\begin{verbatim}
        set     _millicode, %g1
        ld      [ %g1 + M_RESTORE_CONTEXT ], %g1
        jmpl    %g1, %o7
        nop
\end{verbatim}

When that procedure returns, the virtual machine has been initialized, and
the CPU registers are in "Scheme mode".

\subsection{Setting up arguments for the Scheme code}

Typically, this involves copying arguments from the argument save area which
was set up in part (1), above, to the Scheme argument registers. In the case
of our 1-argument procedure, we have something like

\begin{verbatim}
        ld      [ %fp+0x40 ], %REG1
\end{verbatim}

\subsection{Calling the Scheme code}

This has been covered in the preceding sections; since the machine is
now in Scheme mode, we simply use the standard Scheme calling
conventions: set up a continuation (with the calling procedure being
set to 0 if it is non-relocatable), set up the argument count, save the
return address in a registers, and jump to the callee.

\subsection{Saving the new Scheme context}

When the Scheme procedure returns, the virtual machine state must be
saved again in the ``globals'' array. The procedure
``\_save\_scheme\_context'' in \verb+"Sparc/memory.s"+ does this; it
is called just like ``\_restore\_scheme\_context'' was called (above).

\subsection{Setting up the C return value}

The C return value goes into register \%i0 (before a ``restore'' is
performed, or into register \%o0 after the ``restore''). In the case of a
single return value from the Scheme program, we can either move it
from the \%RESULT register to the C return register (since \%RESULT is
still available, this being before the ``restore''), or we can move it
from the ``globals'' table. The latter technique is more general, since
it allows us to use the machine registers without having to know the
Scheme register mappings. In the latter case, we will have something
like:

\begin{verbatim}
        set     _globals, %g1
        ld      [ %g1 + RESULT_OFFSET ], %i0
\end{verbatim}

\subsection{Restoring the C context}

We usually do not want to restore the saved arguments from the argument
save area. We will need to restore the return address, however, and whatever
global registers were used for global register variables. So typically,
we'll have this:

\begin{verbatim}
        ld      [ %fp+0x44 ], %i7
\end{verbatim}

\subsection{Returning to the C code}

Since we're now back in C mode, returning to the C caller is like returning
from a C procedure:

\begin{verbatim}
        jmp     %i7+8
        restore
\end{verbatim}

\section{Calling C procedures from Scheme}

A C procedure cannot be called directly from a Scheme procedure because 
the latter may be moved by the garbage collector before the C procedure
returns (in the general case). The call therefore has to go via a
piece of non-relocatable code. Assume, therefore, that there is a 
millicode procedure

\begin{verbatim}
    void C_call( void (*func)() )
\end{verbatim}

which performs the call for some C procedure ``func''. The rest of this
section describes what C\_call() has to look like. [If func() takes
arguments, we must find some way of passing them; the millicode
procedure could take a list of arguments as its second argument.]

These are the steps that C\_call() must go trough:

\begin{enumerate}
\item set up continuation frame; save return address in this frame
\item save scheme context
\item setup C continuation
\item call C procedure
\item pop C continuation
\item restore scheme context
\item restore return address; pop the continuation frame
\item If the caller's continuation frame has been flushed to the heap, it
   must be restored.
\item return to caller
\end{enumerate}

If we were guaranteed that the caller sets up a frame (and we can
probably force this to be true) then it would be rather simpler:

\begin{enumerate}
\item save return address in caller's frame
\item save Scheme context
\item setup C continuation
\item call C procedure
\item pop C continuation
\item restore Scheme context
\item restore return address
\item return to caller
\end{enumerate}

The last step will automagically bring the caller's frame into the
stack, if necessary.

(More explanation here)

\section{Calling Scheme from Scheme via Millicode}

In the file \verb+"Sparc/glue.s"+ there is a procedure called 
``\_scheme\_call'' which implements the mechanism with which millicode 
procedures can call Scheme procedures. This is sometimes necessary; for
example, much of the heavy generic arithmetic is implemented in Scheme, 
but typically the millicode procedures for generic arithmetic have to
make the decision to call out to Scheme. There is a bit of hair
associated with making the following protocol work, and more gory
detail is given in the comments for the procedures implementing this
mechanism.

All Scheme procedures which are to be called from millicode have to be
registered in the millicode support vector.  It is a Scheme (heap
based) vector, and the pointer to it is located in the global variable
\verb+millicode-support+; this global cell is also pointed to by the 
``globals'' element \verb+MILLICODE_SUPPORT+. The vector is
initialized by the Scheme procedure \verb+install-millicode-support+
(in \verb+Lib/millicode-support.sch+). 

The arguments to ``\_scheme\_call'' are these:

\begin{itemize}
\parskip 0in
\item Arguments are passed in \%RESULT, \%ARGREG2, and \%ARGREG3.
\item The return value (to the original Scheme caller) is in \%o7.
\item The argument count is passed in \%TMP0.
\item The vector index into the millicode support vector is passed in \%TMP1.
\end{itemize}

When called, ``\_scheme\_call'' creates two stack frames. The top frame is
a minimal frame; its return address and procedure pointer indicate the start
of the helper procedure ``scheme2scheme-helper'', defined in 
\verb+"Lib/Sparc/glue.sch"+. The bottom frame has all the saved registers
of the calling Scheme procedure and a return value into that procedure.
So to the procedure being called from millicode (and more importantly to
the rest of the runtime system), it looks like a normal chain of calls.
However, when the callee returns to ``scheme2scheme-helper'', the latter will
pop both frames and restore the original caller's registers, and then do a
simple return to the original caller. This is necessary because the original
caller did not save any registers as it was calling millicode.

\end{document}
