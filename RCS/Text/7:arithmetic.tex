% -*- TeX -*-
% $Id$
%
% Generic Arithmetic in Larceny.

\input{larceny.sty}
\title{Larceny Note \#7: \\
       The Generic Arithmetic Implementation \\
       {\tenrm (draft)}}
\author{Lars Thomas Hansen}

\begin{document}
\maketitle

\section{Motivation}

The implementation of generic arithmetic has been governed by the principle
that above all,

\begin{itemize}
\item Fixnum/fixnum arithmetic should be very fast.
\item Flonum/flonum arithmetic should be very fast.
\item Compnum/compnum arithmetic should be very fast.
\item Other same-representation arithmetic should be reasonably fast.
\end{itemize}

The definition of ``arithmetic'' includes most common predicates and
some coercion procedures like \verb+inexact->exact+, as well as accessors
like \verb+real-part+.
Mixed-representation arithmetic and arithmetic on bignums, ratnums,
and rectnums is of less importance in the current system: the system
is intended as a testbed for fast generic arithmetic and type and
representation inference, and the mentioned numeric types are the most
interesting in real applications.

\section{Fixnum Arithmetic}

Addition, subtraction, shifting and comparison of fixnums is done
in-line.  Since the representation of a fixnum is the representation
desired by the tagged-arithmetic instructions on the SPARC, these
instructions are used. If both operands are not fixnums, or if an
overflow occurs, the overflow bit is set, and we fall into millicode:

\begin{minipage}{\linewidth}
\begin{verbatim}
        taddcc  %RESULT, %REG3, %TMP0
        bvc,a   L1
        mov	%TM0, %RESULT
        jmpl    %MILLICODE + M_GENERIC_ADD, %o7
        mov     %REG3, %ARGREG2
   L1:
\end{verbatim}
\end{minipage}

Hence the time for a tagged add or subtract is 3 clocks.  Exceptions
are handled in entirety within the millicode and its scheme support
routines.

The code for a comparison (using for example the Scheme predicate
``='') is slightly more complicated, because there are two decisions
involved: whether the types compared were fixnums, and whether the
branch should go one way or another:

\begin{minipage}{\linewidth}
\begin{verbatim}
        tsubcc    %RESULT, %REG3, %g0
        bvc,a     L1
        nop
        jmpl      %MILLICODE + M_GENERIC_EQUALP, %o7
        mov       %REG3, %ARGREG2
        cmp       %RESULT, TRUE_CONST
    L1:
        be,a      L2
        nop
    !   false case
        ...
    L2:
    !   true case
        ...
\end{verbatim}
\end{minipage}

The last slot can often be filled, but the first cannot; in particular,
the Sparc architecture manual (version 8) prohibits an idiom found in
some compilers in which the first delay slot is filled with the second
branch (although this does work on current Sun Sparcstation class machines).

Again, exceptions are handled within the millicode.

We could save one instruction in the non-fixnum case by relying on the
condition code bits rather than returning an explicit result which is then
tested, but it is not clear that this is a win, and it also complicates the
millicode needlessly.

Other fixnum operations are done entirely in millicode. The in-line code
for multiplication, for example is this:

\begin{minipage}{\linewidth}
\begin{verbatim}
        jmpl    %MILLICODE + M_GENERIC_MULTIPLY, %o7
        mov     %REG3, %ARGREG2
\end{verbatim}
\end{minipage}

\section{Generic Arithmetic Millicode}

If the fixnum arithmetic failed, or if the operation performed was too
heavyweight to perform in-line, the generic arithmetic system resorts
to its millicode to execute the operation. All generic arithmetic
assembly code is in the file ``Sparc/generic.s'', and there are entry
points for a number of operations. Operations for which there are no
entry points (like logarithms and the exponent function) are
performed entirely in Scheme, using normal calling conventions.

The generic arithmetic millicode tries to determine as efficiently as
possible whether the operands are of the same representation and, if so,
whether they are flonums, fixnums, or compnums. If the operands are
not both of one of these types, the millicode calls on Scheme to resolve
the types and perform the arithmetic. An exception to this rule is that if one operand is a flonum
and the other is a compnum with a zero imaginary part, then the
operation is done in millicode.

Som numeric exceptions (like type errors) are caught in the millicode, and
some are not; the latter are caught by the generic arithmetic Scheme
code.

The method used to efficiently dispatch on critical types is one of a chain
of comparisons. This can be illustrated as shown in figure \ref{chain}.

The procedures ``bignum+'', ``ratnum+'', ``rectnum+'', and
``contagion'', as well as the procedure ``+'', are all implemented in
Scheme. The case of fixnum overflow is handled directly in the
millicode, however.

The details of exception handling are described in Larceny Note \#2;
we pass the exception handler the failed operation and the operands and
let it sort out what went wrong. The exception handler is written in
Scheme.

\begin{figure}[hbt]
\begin{verbatim}
    (define (generic+ a b)
      (cond ((flonum? a)
             (cond ((flonum? b) 
                    (flonum+ a b))
                   ((and (compnum? b) (zero? (imag-part b)))
                    (flonum+ a (real-part b)))
                   (else
                    (contagion a b +))))
            ((compnum? a)
             (cond ((compnum? b)
                    (compnum+ a b))
                   ((and (flonum? b) (zero? (imag-part a)))
                    (flonum+ (real-part a) b))
                   (else
                    (contagion a b +))))
            ((fixnum? a)
             (if (fixnum? b)
                 (fixnum->bignum+ a b)
                 (contagion a b +)))
            ((bignum? a)
             (if (bignum? b)
                 (bignum+ a b)
                 (contagion a b +)))
            ((ratnum? a)
             (if (ratnum? b)
                 (ratnum+ a b)
                 (contagion a b +)))
            ((rectnum? a)
             (if (rectnum? b)
                 (rectnum+ a b)
                 (contagion a b +)))
            (else
             (arithmetic-exception '+ a b))))
\end{verbatim}
\caption{Decision Chain for Generic Arithmetic}
\label{chain}
\end{figure}

The procedure ``contagion'' implements a type-promoting algorithm
which resolves type conflicts and promotes both arguments to the
correct common type before performing the desired operation on them.
``Contagion'' for arithmetic is straightforward; however, the
corresponding procedure for comparison is not as simple, due to the
IEEE standard's requirement that predicates be transitive. This is
discussed in detail below.

The corresponding procedure for the ``='' predicate is called
``econtagion'', and the one for other predicates is called
``pcontagion''. They are separate because of the above-mentioned fact:
general comparison has complicated semantics.

\section{The Contagion Procedures}

``Contagion'', ``pcontagion'', and ``econtagion'' all take three arguments:
two operands (presumed, but not required, to be numbers) and a procedure of
two arguments. The operands are coerced to a common type, and the procedure
is called with the new numbers as arguments. The result of the operation is
returned to the caller of ``contagion''.

The coercion is described by the matrices in figures \ref{contagion},
\ref{pcontagion}, and \ref{econtagion}.

\begin{figure}[hbt]
\begin{center}
\begin{tabular}{|l||l|l|l|l|l|l|} \hline
        & fixnum  & bignum  & ratnum  & flonum  & compnum & rectnum\\ \hline \hline
fixnum  & bignum  & bignum  & ratnum  & flonum  & compnum & rectnum \\ \hline
bignum  & bignum  & N/A     & ratnum  & flonum  & compnum & rectnum \\ \hline
ratnum  & ratnum  & ratnum  & N/A     & flonum  & compnum & rectnum \\ \hline
flonum  & flonum  & flonum  & flonum  & N/A     & compnum & compnum \\ \hline
compnum & compnum & compnum & compnum & compnum & N/A     & compnum \\ \hline
rectnum & rectnum & rectnum & rectnum & compnum & compnum & N/A     \\ \hline
\end{tabular}
\end{center}
\caption{The coercion matrix for ``contagion''.}
\label{contagion}
\end{figure}

\begin{figure}[hbt]
\begin{center}
\begin{tabular}{|l||l|l|l|l|l|l|} \hline
        & fixnum  & bignum  & ratnum  & flonum  & compnum & rectnum\\ \hline \hline
fixnum  & N/A     & bignum  & ratnum  & flonum  & compnum & ILLEGAL \\ \hline
bignum  & bignum  & N/A     & ratnum  & WEIRD   & WEIRD   & ILLEGAL   \\ \hline
ratnum  & ratnum  & ratnum  & N/A     & flonum  & compnum & ILLEGAL \\ \hline
flonum  & flonum  & WEIRD   & flonum  & N/A     & compnum & ILLEGAL \\ \hline
compnum & compnum & WEIRD   & compnum & compnum & N/A     & ILLEGAL \\ \hline
rectnum & ILLEGAL & ILLEGAL & ILLEGAL & ILLEGAL & ILLEGAL & ILLEGAL \\ \hline
\end{tabular}
\end{center}
\caption{The coercion matrix for ``pcontagion''.}
\label{pcontagion}
\end{figure}

In the case of ``pcontagion'', the entry for ``compnum'' makes sense
only when the imaginary part of the compnum is 0; otherwise, the
comparison is illegal. However, this error is caught by millicode, so we
can just coerce as shown in the table and then retry the operation.

The entry ``WEIRD'' indicates that a more complex comparison of the operands
is necessary before the resulting representation can be determined; the
algorithm for determining the new representation is given below.

\begin{figure}[hbt]
\begin{center}
\begin{tabular}{|l||l|l|l|l|l|l|} \hline
        & fixnum  & bignum  & ratnum  & flonum  & compnum & rectnum\\ \hline \hline
fixnum  & N/A     & bignum  & ratnum  & flonum  & compnum & rectnum \\ \hline
bignum  & bignum  & N/A     & ratnum  & WEIRD   & WEIRD   & rectnum \\ \hline
ratnum  & ratnum  & ratnum  & N/A     & flonum  & compnum & rectnum \\ \hline
flonum  & flonum  & WEIRD   & flonum  & N/A     & compnum & compnum \\ \hline
compnum & compnum & WEIRD   & compnum & compnum & N/A     & compnum \\ \hline
rectnum & rectnum & rectnum & rectnum & compnum & compnum & N/A     \\ \hline
\end{tabular}
\end{center}
\caption{The coercion matrix for ``econtagion''.}
\label{econtagion}
\end{figure}

\section{The Special Case}

In the matrices for the contagion procedures, the ``WEIRD'' entry is a
place holder for the following algorithm (figure \ref{weird}), which
is necessary to ensure that the transitivity of comparison operators
is upheld. ``A'' and ``b'' are the numbers to be converted to a common
type; ``default'' is a procedure to invoke if the algorithm does not
apply (if, for example, the compnum has non-zero imaginary part); and
``bcontinue'' and ``fcontinue'' are the continuation procedures to
apply with the converted numbers in the case of bignums and flonums,
respectively.

\begin{figure}[hbt]
\begin{verbatim}
      (define (weird a b default bcontinue fcontinue)

        (define (doit flonum bignum)
          (if (integer? flonum)
              (bcontinue (flonum->bignum flonum) bignum)
              (fcontinue flonum (bignum->flonum bignum))))
      
        (let ((a (if (bignum? a) b a))        ; a is now flonum or compnum
              (b (if (bignum? a) a b)))       ; b is now bignum
          (if (compnum? a)
              (if (not (zero? (imag-part a)))
                  (default a b)
                  (doit (real-part a) b))
              (doit a b))))
\end{verbatim}
\caption{The algorithm for the special case.}
\label{weird}
\end{figure}

\section{Generic Arithmetic Scheme Code}

(Blurb about Bignum implementation; White paper, etc.)

(Rest is mostly Remy's stuff.)

\end{document}
