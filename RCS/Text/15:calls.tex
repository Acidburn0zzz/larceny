% -*- TeX -*-
% $Id: conventions.tex,v 1.2 92/02/17 18:27:47 lth Exp $

\input{larceny.sty}

\title{Larceny Note \#15: \\
       Calling Conventions for C/Scheme and Scheme/millicode/Scheme \\
       {\tenrm (draft!)}}
\author{Lars Thomas Hansen}

\begin{document}
\maketitle

\section{Calling Scheme procedures from C}

Inter-language calls are relatively "heavy", as there is a significant
amount of protocol that has to be taken care of in the call. The steps can
be summarized thusly:

\begin{enumerate}
\item saving the current C context
\item setting up a Scheme context
\item setting up arguments for the Scheme code
\item calling the Scheme code
\item saving the new Scheme context
\item setting up the C return value
\item restoring the C context
\item returning to the C code
\end{enumerate}

Calling an assembly language millicode procedure from C is typically
equivalent to calling a Scheme procedure, as the millicode procedures
assume that the machine is in a Scheme state.

The mechanism described in the following is believed to be general enough
to support C calling Scheme calling C calling Scheme, and so on. It has
not been shown rigorously, however, that the generality really exists.

Typically, the eight steps are carried out by some conversion routine
written in assembly language. Examples are given below.

\subsection{Saving the current C context}

The C calling conventions and the SunOS window trap handlers require a
specific stack layout on the C stack (pointed to by \%o6, also known as
\%sp, in every window). The layout consists of two general areas: one
area for spilling register windows into (64 bytes), and one area for
spilling and passing arguments in (typically 32 bytes). The stack
pointer of the previous window (\%i6, also known as \%fp) always points
to end of the highest-addressed word in this frame, and is used by
the trap handler to locate the memory in which to spill the previous
window, if necessary. Hence figure \ref{c-args}.

\begin{figure}[hbt]
\begin{verbatim}
  %fp  -->    +--------------------+     (high address)
              |      Argument      |
              |        area        |
              |     (32 bytes)     |
              +--------------------+
              |                    |
              |       Window       |
              |      overflow      |
              |        area        |
              |     (64 bytes)     |
              |                    |
  %sp  -->    +--------------------+     (low address)
\end{verbatim}
\caption{The C stack frame layout}
\label{c-args}
\end{figure}

One important point is that the argument save area set up by a particular
procedure is not for use by that procedure itself, but rather by the
procedures called by that procedure. Hence, a procedure saves its arguments
in the previous frame, at a positive offset from \%fp.

To save the current C context and allocate space, one must allocate a
new window and stack space, and save whatever critical values that are
in the \%i (and \%g, if any) registers after the allocation. If there
was one argument passed, then the code may look like this:

\begin{verbatim}
        save    %sp, -96, %sp                   ! allocate 24 words
        st      %i0, [ %fp+0x40 ]               ! save the argument
        st      %i7, [ %fp+0x44 ]               ! save the return address
\end{verbatim}

Saving the return address is vital, as the Scheme code uses register \%i7.
Note that at the time of the ``save'', \%sp must point to an even-addressed
word, otherwise an alignment error will occur. This is automatically true
if all stack frames have an even number of words.


\subsection{Setting up the Scheme context}

Before the Scheme procedure can be called, the virtual machine must be
initialized. The values that need to be restored to virtual machine
registers are all in the ``globals'' array. Of course, the registers
\%GLOBALS and \%MILLICODE also need to be set up.  The procedure
``\_restore\_scheme\_context'', defined in \verb+"Sparc/memory.s"+,
does exactly these tasks. It should simply be called, either directly
(from non-relocatable code) or indirectly, through the millicode
table. In the former case it is simple:

\begin{verbatim}
        call    _restore_scheme_context
        nop
\end{verbatim}

If we need to jump though the millicode table, remember that the \%MILLICODE
register is not yet set up! Therefore, we need to use the global variable
directly:

\begin{verbatim}
        set     _millicode, %g1
        ld      [ %g1 + M_RESTORE_CONTEXT ], %g1
        jmpl    %g1, %o7
        nop
\end{verbatim}

When that procedure returns, the virtual machine has been initialized, and
the CPU registers are in "Scheme mode".

\subsection{Setting up arguments for the Scheme code}

Typically, this involves copying arguments from the argument save area which
was set up in part (1), above, to the Scheme argument registers. In the case
of our 1-argument procedure, we have something like

\begin{verbatim}
        ld      [ %fp+0x40 ], %REG1
\end{verbatim}

\subsection{Calling the Scheme code}

This has been covered in the preceding sections; since the machine is
now in Scheme mode, we simply use the standard Scheme calling
conventions: set up a continuation (with the calling procedure being
set to 0 if it is non-relocatable), set up the argument count, save the
return address in a registers, and jump to the callee.

\subsection{Saving the new Scheme context}

When the Scheme procedure returns, the virtual machine state must be
saved again in the ``globals'' array. The procedure
``\_save\_scheme\_context'' in \verb+"Sparc/memory.s"+ does this; it
is called just like ``\_restore\_scheme\_context'' was called (above).

\subsection{Setting up the C return value}

The C return value goes into register \%i0 (before a ``restore'' is
performed, or into register \%o0 after the ``restore''). In the case of a
single return value from the Scheme program, we can either move it
from the \%RESULT register to the C return register (since \%RESULT is
still available, this being before the ``restore''), or we can move it
from the ``globals'' table. The latter technique is more general, since
it allows us to use the machine registers without having to know the
Scheme register mappings. In the latter case, we will have something
like:

\begin{verbatim}
        set     _globals, %g1
        ld      [ %g1 + RESULT_OFFSET ], %i0
\end{verbatim}

\subsection{Restoring the C context}

We usually do not want to restore the saved arguments from the argument
save area. We will need to restore the return address, however, and whatever
global registers were used for global register variables. So typically,
we'll have this:

\begin{verbatim}
        ld      [ %fp+0x44 ], %i7
\end{verbatim}

\subsection{Returning to the C code}

Since we're now back in C mode, returning to the C caller is like returning
from a C procedure:

\begin{verbatim}
        jmp     %i7+8
        restore
\end{verbatim}

\section{Calling C procedures from Scheme}

A C procedure cannot be called directly from a Scheme procedure because 
the latter may be moved by the garbage collector before the C procedure
returns (in the general case). The call therefore has to go via a
piece of non-relocatable code. Assume, therefore, that there is a 
millicode procedure

\begin{verbatim}
    void C_call( void (*func)() )
\end{verbatim}

which performs the call for some C procedure ``func''. The rest of this
section describes what C\_call() has to look like. [If func() takes
arguments, we must find some way of passing them; the millicode
procedure could take a list of arguments as its second argument.]

These are the steps that C\_call() must go trough:

\begin{enumerate}
\item set up continuation frame; save return address in this frame
\item save scheme context
\item setup C continuation
\item call C procedure
\item pop C continuation
\item restore scheme context
\item restore return address; pop the continuation frame
\item If the caller's continuation frame has been flushed to the heap, it
   must be restored.
\item return to caller
\end{enumerate}

If we were guaranteed that the caller sets up a frame (and we can
probably force this to be true) then it would be rather simpler:

\begin{enumerate}
\item save return address in caller's frame
\item save Scheme context
\item setup C continuation
\item call C procedure
\item pop C continuation
\item restore Scheme context
\item restore return address
\item return to caller
\end{enumerate}

The last step will automagically bring the caller's frame into the
stack, if necessary.

(More explanation here)

\section{Calling Scheme from Scheme via Millicode}

In the file \verb+"Sparc/glue.s"+ there is a procedure called 
``\_scheme\_call'' which implements the mechanism with which millicode 
procedures can call Scheme procedures. This is sometimes necessary; for
example, much of the heavy generic arithmetic is implemented in Scheme, 
but typically the millicode procedures for generic arithmetic have to
make the decision to call out to Scheme. There is a bit of hair
associated with making the following protocol work, and more gory
detail is given in the comments for the procedures implementing this
mechanism.

All Scheme procedures which are to be called from millicode have to be
registered in the millicode support vector.  It is a Scheme (heap
based) vector, and the pointer to it is located in the global variable
\verb+millicode-support+; this global cell is also pointed to by the 
``globals'' element \verb+MILLICODE_SUPPORT+. The vector is
initialized by the Scheme procedure \verb+install-millicode-support+
(in \verb+Lib/millicode-support.sch+). 

The arguments to ``\_scheme\_call'' are these:

\begin{itemize}
\parskip 0in
\item Arguments are passed in \%RESULT, \%ARGREG2, and \%ARGREG3.
\item The return value (to the original Scheme caller) is in \%o7.
\item The argument count is passed in \%TMP0.
\item The vector index into the millicode support vector is passed in \%TMP1.
\end{itemize}

When called, ``\_scheme\_call'' creates two stack frames. The top frame is
a minimal frame; its return address and procedure pointer indicate the start
of the helper procedure ``scheme2scheme-helper'', defined in 
\verb+"Lib/Sparc/glue.sch"+. The bottom frame has all the saved registers
of the calling Scheme procedure and a return value into that procedure.
So to the procedure being called from millicode (and more importantly to
the rest of the runtime system), it looks like a normal chain of calls.
However, when the callee returns to ``scheme2scheme-helper'', the latter will
pop both frames and restore the original caller's registers, and then do a
simple return to the original caller. This is necessary because the original
caller did not save any registers as it was calling millicode.

\end{document}
