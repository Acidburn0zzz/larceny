% -*- TeX -*-
% $Id: 3:memory.tex,v 1.2 1992/02/17 18:27:55 lth Exp lth $

\input{larceny.sty}

\title{Larceny Note \#3: \\
       The Memory Management Millicode Interface}
\author{Lars Thomas Hansen}

\begin{document}
\maketitle
\begin{abstract}
This document discusses the interface between the memory management
millicode and the compiled Scheme application. Rules for the
interaction are set forth and some examples are presented.

Section 1 discusses the application interface to the millicode
procedures for allocation, mutation, and memory management management.
Section 2 shows some examples for the SPARC. Section 3 discusses the
SPARC implementation.
\end{abstract}

\section{The application interface to the memory manager}

Of all memory management procedures in the run-time system, the compiled
Scheme code should call only the procedures exported from
``Sparc/memory.s'', all of which are listed below, and which from now on
will be collectively referred to as ``the memory management millicode
procedures'', abbreviated ``the MMMPs''. All MMMPs except ``stkuflow()'',
``restore\_continuation()'', ``save\_scheme\_context()'', and
``restore\_scheme\_context()'' may invoke the garbage collector.

MMMPs follow millicode calling conventions as described in
``conventions.txt''.

The procedures exported from ``Sparc/memory.s'' are the following,
shown using C declaration syntax. The names in brackets are the
symbolic names for the procedures' offsets within the ``millicode''
array.

\begin{description}

\item {{\tt word *alloc( word n )} \hfill [ {\sc m\_alloc} ]}

Allocates ``n'' uninitialized words on the heap and returns an untagged
pointer to the first (lowest-addressed) word. Since the words are not
initialized, they must be initialized by the caller of alloc() before
any other procedure which might invoke the garbage collector is
called. If ``n'' is odd, it will be rounded upward to an even number; the 
caller need not initialize the resulting padding word.

\item {{\tt word *alloci( word i, word v )} \hfill [ {\sc m\_alloci} ] }

Allocates ``n'' words on the heap and initializes each to the value ``v'',
returning an untagged pointer to the first (lowest-addressed) word.
If ``n'' is odd, it is rounded upward to an even number; the resulting
padding word may or may not be initialized by alloci(), and the caller
should not depend on any particular behavior in this respect.

\item {{\tt void setcar( word p, word v )} \hfill [ {\sc m\_setcar} ] }

If ``p'' is a tagged pointer to a pair, then the ``car'' field of the pair is
set to the value ``v''. The value of \reg{result} is undefined after a call to 
setcar(), but is guaranteed to be a valid Scheme object. If ``p'' is not
a tagged pointer to a pair, then the effect of calling setcar() is 
undefined.

\item {{\tt void setcdr( word p, word v )} \hfill [ {\sc m\_setcdr} ] }

Like setcar(), only the ``cdr'' field is affected rather than the
``car'' field.

\item {{\tt void vectorset( word p, word i, word v )} \hfill [ {\sc m\_vectorset} ]}

If ``p'' is a tagged pointer to a vector, and ``i'' is a valid index
into the vector, then the ith element of the vector is set to the
value ``v''. The value of \reg{result} is undefined after a call to
vectorset(), but is guaranteed to be a valid Scheme object. If ``p''
is not a tagged pointer to a vector, or if ``i'' is not a valid index
into the vector pointed to by ``p'', then the effect of calling
vectorset() is undefined. The argument ``i'' must be a fixnum.

\item {{\tt word *gcstart( word n )} \hfill [ {\sc m\_gcstart} ] }

If ``n'' is the a nonpositive fixnum, then the garbage collector is
invoked to do a collection, and the value of \reg{result} is unchanged
(modulo address updates). There are three cases: if ``n'' is -2, then
a full collection is performed; if ``n'' is -1, a tenuring collection
is performed; and if ``n'' is 0, and ephemeral collection is
performed, Values less than -2 cause undefined results.  Otherwise,
the garbage collector is invoked to collect the ephemeral area, a
block of ``n'' words is allocated as for alloc(), above, and
\reg{result} is set to an untagged pointer to the allocated memory. A
tenuring collection may be invoked even if ``n'' is not -1, and a full
collection may be invoked even if ``n'' is not -2, depending on the
internal state of the collector.  The parameter ``n'' must be a
fixnum, and other types cause undefined results.

\item {{\tt void stkuflow( void )} \hfill [ {\sc m\_stkuflow} ]}

Stkuflow() retrieves a continuation frame from the heap and puts it at
the top of the stack cache (growing down). There will be a dummy
continuation at the bottom of the stack cache. This continuation
contains a return address which points to stkuflow(); when underflow
occurs, stkuflow() is invoked and handles the underflow, returning to
the return address in the newly-fetched stack frame. A stack underflow
will never cause a garbage collection.

\item {{\tt void stkoflow( void )} \hfill [ {\sc m\_stkoflow} ] }

Stkoflow() should be invoked from the compiled application to flush the
stack cache. The flush may cause a garbage collection. 

\item {{\tt void save\_scheme\_context( void )} \hfill [ {\sc m\_save\_context} ] }

Save\_scheme\_context() saves the hardware-mapped part of the virtual machine
state into the ``globals'' array. If the virtual machine has not been
previously initialized, then the results are undefined.

\item {{\tt void restore\_scheme\_context( void )} \hfill [ {\sc m\_restore\_context} ]}

Restore\_scheme\_context() sets up the hardware-mapped part of the virtual
machine state from the saved values in the ``globals'' array. If ``globals''
has not been properly initialized, then the results are undefined. 

\item {{\tt word capture\_continuation( void )} \hfill [ {\sc m\_capture} ]}

Capture\_continuation() returns a tagged pointer to a structure which
represents the current continuation at the time the capture procedure was
called.

\item {{\tt void restore\_continuation( word c )} \hfill [ {\sc m\_restore} ] }

Restore\_continuation() takes a tagged pointer to a continuation structure
as returned from capture\_continuation() and reinstates that continuation.
The continuation which was current at the time restore\_continuation() was
called is simply discarded.

\end{description}

\section{Examples of use of the memory manager}

\begin{verbatim}
! Generic CONS using alloc()
!
! Assume values to cons are in RESULT and REG2 and that pointer to new 
! cell is to be left in RESULT.
! The code can be improved by moving the 'or' between the stores
! and using an adjusted offset in the second store.

    mov     %RESULT, %ARGREG2
    jmpl    %MILLICODE + M_ALLOC, %o7             ! allocate it
    mov     fixnum( 2 ), %RESULT
    st      %ARGREG2, [ %RESULT+CAR_OFFSET ]
    st      %REG2, [ %RESULT+CDR_OFFSET ]
    or      %RESULT, PAIR_TAG, %RESULT            ! set tag
\end{verbatim}

\begin{verbatim}
! Open-coded CONS, same assumptions as above.
!
! This code depends on there being a small heap overflow area which can
! validly be written into as long as the values written into it can be
! forgotten. This condition is guaranteed (and should be documented).

    st      %REG1, [ %E_TOP ]
    add     %E_TOP, 8, %E_TOP                     ! allocate optimistically
    cmp     %E_TOP, %E_LIMIT                      ! overflow?
    st      %REG2, [ %E_TOP-4 ]
    blt,a   L1                                    ! jump if not
    add     %E_TOP, PAIR_TAG-8, %RESULT
    jmpl    %MILLICODE + M_CONS, %o7
    mov     %REG2, %ARGREG2
L1:
\end{verbatim}


\section{The SPARC Implementation}

The SPARC implementation of the MMMPs is unspectacular. The highlights
are the (arguably sick, vile, and unnatural) internal calling
conventions, and the internal subroutines for garbage collection and
transaction management. In addition, some strategy decisions will be
discussed.

You will want to look at a source listing of ``Sparc/memory.s'' before you
read too much of the following.


\subsection{Internal calling conventions}

Whenever a millicode procedure is called, its return address (to
Scheme code) must be in \%o7. This value is known as the ERA or
``external return address''. In the case of a garbage collection, it is
expected to change, and must hence be dealt with in that respect.
However, MMMPs are never moved, and hence if an MMMP calls another,
the millicode return address (known as the MRA) can be saved anywhere.
Currently, if such a call happens (i.e. \_alloc calls gcstart), the ERA
is saved in \%TMP0, where gcstart expects to find it, and the MRA (into
\_alloc) is saved in \%o7 by the ``call'' instruction. Only one level of
millicode calls is possible using this convention, since there is no
provision for millicode to stuff an MRA anywhere but in \%o7, which of
course can hold only one. So far the MMMPs have needed only one level
of non-tail calls internally, but a much better solution would be to
have an internal stack on which to push MRAs. It is somewhat unclear
whether this would be a problem for reentrancy; the MMMPs are never
entered more than once, so this is not an issue here.

Since some MMMPs (like \_stkoflow and \_stkuflow) may not change the
{\sc \%RESULT} register, and since at least the overflow procedure may
trigger a garbage collection, and since gcstart changes {\sc \%RESULT}, then
these MMMPs must save {\sc \%RESULT} for later restoring it. The place of
choice for this save is in \verb+globals[ SAVED_RESULT_OFFSET ]+, which is
for this use. It is a rootable location. Currently, \_stkoflow(),
\_stkuflow(), \_setcar(), \_setcdr(), and \_vectorset() save {\sc \%RESULT} 
across calls
to internal millicode procedures.


\subsection{Internal Subroutines}

There are two internal subroutines: gcstart() (not to be confused with
the publicly available \_gcstart), and addtrans(). The former initiates a
garbage collection and has the same semantics as \_gcstart() (see above);
the latter adds a transaction to the transaction list if possible and
triggers a collection (by calling gcstart) if not possible (due to tenured
heap overflow).


\subsection{Strategy}

The big question in this section is what kind of collections to
trigger on various kinds of heap overflows. For some situations (e.g.
if \_alloc() overflows the heap) the answer is obvious; for others (e.g.
if \_stkoflow() overflows the heap), it is not. This section summarizes
the current decisions and comments on their appropriateness.

If \_alloc() or \_alloci() find that memory cannot be allocated because the
ephemeral heap is full, they call gcstart with an argument corresponding
to the number of words to allocate, forcing gcstart to trigger an
ephemeral collection.

If \_stkoflow() fills up the ephemeral heap, it calls on gcstart() to
perform an ephemeral collection.

If addtrans() discovers that the tenured heap is full, it triggers an
ephemeral collection. Previously, a full collection was performed, but this
can affect certain assignment-intensive programs very adversely.

\end{document}
