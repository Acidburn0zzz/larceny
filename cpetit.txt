Architecture of Petit Larceny (Standard-C back-end)
Last updated 981016 / lth


1. How to get started with the development environment

Start larceny with "nbuild -petit" or load "Util/load-twobit-C.sch" into
a running Larceny.


2. Status

In 0.34:

It runs and passes all tests in the testsuite.  Code compiled with
optimization is tolerably small (about 2x of native code) and has
OK performance.

Both the generational and stop+copy systems are able to rebuild
themselves and produce a bit-for-bit identical heap image and executable
(running Twobit in the Petit Larceny interpreter).

The major unresolved issue is how to compile and "load" packages that
can be loaded dynamically in the native version -- Twobit, for example.

In 0.36:

Currently getting a strange error (had this kind of error before):

Assembling Eval/evalprim.lop

*** Error encountered!
Deleting target file: Eval/evalprim.lop
Error: get-output-string: #<OUTPUT PORT *string*> is not a string output port.

> (debug)
Entering debugger; ? for help.
compiled procedure #f
Debug> b
=> compiled procedure #f
   compiled procedure #f
   interpreted expression (emit-string! as (apply twobit-format fmt operands))
   interpreted expression (begin (emit-string! as code-indentation) (emit-string! as (...)) ...)
   interpreted expression (begin (as-source! as (cdr source)) ((...) ...) ...)
   interpreted expression ((lambda (r) (begin ((lambda ...)))) ...)
   compiled procedure #f
   interpreted expression (begin (assemble-finalize! nested-as) (k nested-as segment))
   interpreted expression ((lambda (r) (begin ((lambda ...)))) ...)
   compiled procedure #f
   interpreted expression (begin (assemble-finalize! as) (assembly-end as segment))
   interpreted expression ((lambda (r) (begin ((lambda ...)))) ...)
   interpreted expression (writer (processer x) outport)
   interpreted expression (begin (writer (processer x) outport) (loop ...))
   compiled procedure #f
   compiled procedure #f
   interpreted expression (begin (process-file file outputfile write-lop (lambda (...) ...)) ...)
   interpreted expression (begin (error-handler (lambda args (begin (...) ...))) ...)
   interpreted expression (begin (if probe (begin (make:debugmsg target ...) ...) ...) ...)
   compiled procedure #f
   interpreted expression (begin (for-each make deps) (if ((...) ...) ...))
   interpreted expression (begin (if probe (begin (make:debugmsg target ...) ...) ...) ...)
   interpreted expression (begin (set! have-made (quote ())) (set! ...) ...)
   compiled procedure call-with-values
   compiled procedure #f
   compiled procedure call-with-values
   compiled procedure #f
   compiled procedure #f
   system continuation

(load "Util/load-twobit-C-be.sch")  ; error - wrong path
(load "Util/load-twobit-C-be.sch")  ; loads verbosely
(system "make lopclean")
(make-petit-heap)


3. Tasks underway

Missing features
 - Must implement and test all the dispatch mechanisms.
 - How to load and initialize compiled code.
 - How to use the FFI (essentially a dynamic-loading problem too).

Quality-of-implementation things; portability
 - Compile with LCC or other non-GCC compiler.
 - Must implement some mechanism whereby new C code is not recompiled if
   it's identical with existing C code and a newer .o file than existing
   C code exists.  This is the common case, _and_ would save massively
   on heap dump time.  ALSO NOTE OTHER DEPENDENCIES (notably twobit.h)
   MUST NOT HAVE CHANGED.  The latter should "only" be a problem during
   compiler development and can be finessed with a switch, maybe.
 - Could come up with a scheme where twobit_thunk_* names are seeded by the
   file name; this way, recompilation of C code will be even less frequent.
 - Portability issues with the use of the C compiler [exec'ing it, which
   switches to use (or whether it even _has_ command line parameters], 
   and also with the use of 'cat' in building the heap.
 - Deal with nonportable use of 'format' in dumpheap-extra.sch.
 - Heap images should contain information about binary format in
   addition to version, eg, PETIT-BE, PETIT-EL, SPARC-NATIVE, ...
 - Note that .a files can't have multiple files with the same basename;
   be careful!  [Shared libraries sidestep this for systems where
   sharedlibs are OK -- most unix systems should be OK, and it's only
   on these that the .a is an issue.]
 - Run-time libraries, notably I/O-related [Non-Unix OSs only]
 - Package twobit.h so that it can be included w/o reference to the
   header files it includes; this makes it easier to compile
   standalone (like Gambit).
 - Setup command lines in dumpheap-extra.c to reference the full
   path of libpetit.so so that executable can be moved.

Code generation quality [order of priority and expected payoff]
 - Introduce peephole optimizations in the assembler.
 - Cache STKP for speedup (maybe -- time both ways).
 - Deal with fallthrough issue in a reasonable way.
 - Can introduce a twobit_label macro that would be an implicit 
   function split.  It would make the code look a lot more natural, 
   and with the twobit_prologue() and a corresponding twobit_epilogue()
   [more properly called twobit_begin() and twobit_end()] it would 
   allow the use of the switch() technique.


4. Source files

The directory Rts/Standard-C contains all the support files for Petit
Larceny that it does not share with the rest of the system. Currently
there are the following source files:

	twobit.h	Macros for all MAL instructions and primops.
	multiply.c	Portable 32x32->64 multiplication code.
	millicode.h	Header file for portable millicode implementation.
	millicode.c	Portable millicode implementation, including
			dispatch loop.
	arithmetic.c	Generic arithmetic implementation; auto-generated
			from arithmetic.mac.
	arithmetic.mac	Generic arithmetic macros.
	expander.sch	Simple macro expander for generic arithmetic macros.

There are two other files:

	twobit.c.old	Experimental dispatch loop, etc (from Will).
	twobit.h.old	Experimental instruction macros, etc (from Will).

The directory Asm/Standard-C contains the assembler back-end for Petit
Larceny.  There are the following source files:

	pass5p2.sch	MAL code emitter procedures.
	dumpheap-extra.sch	Overriding procedures for heap dumper.
	switches.sch	Assembler switches.


5. Architecture

The compiler is not affected by the change in back-ends, and produces
LAP files like it used to.  The LAP files are assembled with the new
assembler, which produces LOP files that are different from the SPARC
LOP files.  

The new LOP files contain segments that are represented as lists with
three elements: code vector, constant vector, and list of C functions
defined by the code vector.  The code vector is a string that contains C
code.  The constant vector has the same tagged structure is in SPARC LOP
files, except that code vectors again are strings containing C code.
The global names can be used by a postprocessor to produce prototypes
for the functions defined in the code vector.  Each entry is a list of
length 3: function name, flag for whether the procedure is always
defined (some procedures are only defined if a certain calling
convention is used), and a flag for whether the procedure is the
top-level thunk that's to be run when a bootstrap heap image is loaded.

Every C function in a file is declared "static" and has a name that's
unique in the file.  When a C file is produced from a LOP file for
compilation, forward declarations are added at the beginning of the
file, all code vectors are copied from the segments to the file, and
finally trampolines are added that can be called at startup time.  Each
trampoline knows about the initialization procedures in the file, and
for each of them, in order, it creates a trivial thunk which it then
calls.

When a group of LOP files are dumped into a heap image, temporary C
source files are generated as outlined above and compiled individually,
and simultaneously, all the data from the LOP files are dumped into a
heap image that's identical to the standard heap image except that every
code vector slot contains #f.  The C code always knows which code vector
it needs and gets the code vector by naming it.  Consequently, the
startup-thunk list in the SPARC heap image is replaced by a C procedure
that knows the name of all the startup thunks and can just call them.

When a dumped heap is linked with Larceny run-time support, Larceny only
needs to know the name of the startup procedure.

The run-time system is available as an archive Rts/petit-larceny.a
(later to be a shared library petit-larceny.so).  The archive is created
by executing 'make petit'.  In particular, the archive contains a file
with a main() function.  When a heap is dumped, the resulting C files
should be compiled and then linked with the archive to produce an
executable (and a code-less heap image).


6. Startup

If the contents of SCHEME_STARTUP is a procedure with #f for the code
vector, then the code for the procedure is in the C procedure
twobit_start; this code is patched into the thunk and then the thunk is
called.  Otherwise it is a normal procedure, the code pointer is the
address of some C procedure, and the procedure should be called.

Twobit_start is the result of compiling the startup procedure in
Asm/Standard-C/dumpheap-extra.sch.  The startup procedure is called with
a single argument, the argument vector.  Its job is to call all the init
thunks in the heap and then call _go_ with the list of symbols to intern
and the argument vector.  In a native heap, the list of thunks is in a
list in the bootstrap procedure's constant vector.  In a C heap, the
code pointers are not present in the initial heap, so a trick is
necessary.  The startup procedure calls a special primitive,
mc_petit_patch_boot_code, which patches code vectors into the list of
thunks.  It gets the code pointers from an external array that is
created specially for each heap.  This array is called
twobit_start_procedures and is created by the heap dumper.  This is
the only change necessary in the boot code, relative to the native boot
code.

Heaps can be dumped iff code pointers don't move between program
invocations.


7. Runtime architecture (dispatch loop, generic arithmetic)

The RTS calls the boot procedure petit_larceny_start with the globals
vector as the only argument; any arguments to the boot procedure are
encoded in the register file in the globals vector.  A stack frame
already exists for the boot procedure to use.  The boot procedure sets
the return address in the frame to be dispatch_loop_return (see below).
Then, a jump buffer is created for longjmp, the first code vector is
extracted from the procedure in REG0, and that code vector is jumped to.
This transfers control to compiled Scheme code.

Whenever a code vector returns normally to the dispatch loop, it must
return a pointer to its continuation (a procedure).  The loop then
immediately calls that continuation.

However, it's also possible to transfer control via longjump.  The
procedure call_scheme does this: it saves the current state, creates a
new stack frame, sets REG0 to the procedure to call, and does a longjump
to the dispatch loop, which grabs the code vector from REG0 and calls
it, just like in the startup phase.  Normally this is not the way to
reach the dispatch loop: only Scheme-to-Scheme-thru-Millicode calls do
this.

The exit handler is reached if the initial Scheme procedure executes a
RETURN instruction.


General idea for generic arithmetic:

	add( a, b, k )
	{
	  if (both_fixnums( a, b )) {
	    r, oflo = ADD( a, b );
	    if (!oflo) {
	      RESULT = r;
	      return k;
	    }
	  }
	  /* oflo or not both fixnums */
	  mc_generic_add( globals, k ); /* does its thing inline or longjmps */
	}


8. Results of code generation tweaks

 - Pass globals as an argument to generated code; this will reduce code 
   size and improve performance.
     - reduced code size by 80KB.
     - reduced running time of (fib 26) by 130ms (not much!).

 - Cache RESULT for speedup.
     - reduces code size by ~50KB, rather less than expected.  This may
       be an indication that the generated C procedures are pretty small,
       which would definitely reduce the effectiveness of this optimization.
     - it works; the jury is still out on its effectiveness.  It appears
       to slow down interpreted code somewhat.  However, the interpreter
       procedures are quite small and it is reasonable that the save and
       restore work actually exceeds simple store work, because a result
       value is only ever moved to a register, hardly ever -- except in
       some primops -- used directly.  So this needs to be tested both
       ways on more typical code.  For the time being it has been turned 
       _OFF_.
 - Tune all the twobit_* macros (assume RESULT and STKP not cached).
     - Nice payoff in code size reduction!  Now down to 1585KB, about
       twice the amount of native code.
     - Performance improved some, too.
 - Code size: all calls to mc_exception have last two arguments 0, 0;
   having a special case for that would remove two static instructions 
   from every primitive that can fail.  Having special entry points
   for each exception (encoding the code in the name) might or might
   not save another.
     - Removing the two 0's resulted in 45KB code size reduction,
       now down to 1540KB.


9. How to do it on the Alpha?

The appropriate compiler flag for 32-bit mode appears to be
`-xtaso_short' (use 32-bit pointers); the appropriate linker flag is
`-taso' (load in low 32 bit address range).  However, using -xtaso_short
gives a compiler warning that "headers are not protected".  The problem
here is explained in the manpage for protect_headers_setup(8); systems
staff needs to run this script to configure the header files for use
with 32-bit pointers.

On the other hand it may be just as good to insert the header protection
manually in all source files -- that way, machines on which header
protection has not been done won't trip us up.  But it does increase the
clutter, and it is compiler dependent -- DEC may change the
implementation at some point.

-O appears to be adequate, -O2 may have minor benefits.  -O2 will do
inlining of static procedures; may be worthwhile for the
Cheny-on-the-MTA jump discipline.

Note: the DEC Alpha is little-endian.  That means the heap images must
be little-endian, or byteswapping must happen at load time on some
architectures.  It would be feasible for the bootstrap heap dumper to
always create big-endian heaps, and for the heap loader to check the
type code and do byteswapping when necessary.  Byteswapping is not
necessary with dumped heaps, and hsplit could also be made to do
byteswapping.

Progress: the load-twobit-C-* scripts now encode byte order, and
nbuild.sch makes sure to initialize the heap dumper with the right byte
ordering.  (The assembler has not been fixed but that's not an issue yet
because we only need to worry about endianness in the assembler when
generating native code.  Both the SPARC and the PPC are big-endian.)

Little-endian issues:
 - heap loader (must load little-endian words for roots, but first header
   word is same endianness on all architectures)
 - bignum primitives
 - generic arithmetic that accesses bytes (eg for tags in dispatch tree)
 - twobit.h code that accesses bytes (eg for tags in typechecking)


X. Postprocessing the output for debugging purposes

Try the following (works on vega, at least):

gcc -IRts/Standard-C -IRts/Sys -IBuild -E fib.c | \
	indent -kr -i2 | \
	grep -v '^ *$' > fib.i


