$Id$

We will release the SPARC back-end only for the first release.
The version of the first release will be 1.0-alpha1.

----------------------------------------------------------------------

Currently testing
  - GC benchmark suite with block compilation mode and (fast-safe-code), 
    on Vega.  Nucleic2 is not included.
  - GC benchmark suite with conservative system and split heap, on Mintaka.

TOP PRIORITY

- Really need to test (write-barrier #f) on applicable systems, with all 
  other parameter settings varied.
  - worked fine on conservative system with fast-safe-code.

- Really need to run at least one test run with a split heap on 
  the conservative system.
  - currently running autobuild w/reorganize, (fast-safe-code), on mintaka.


----------------------------------------------------------------------

[Release]
  * Source freeze (in this order):
    - Move version number to 0.41
    - Branch source tree as branch-1-0-a1
  * Source archive
    - move version number on branch to 1.0a1
    - iterate until it works:
      - cvs export on branch-1-0-a1
      - run Scripts/release-1.0a1
      - run ( cd Rts; BUILD_HOST=chez make config ) 
      - make source archive
      - install, rebuild, run some simple tests.
  * Archives:
    - Get binary distributions from the source archive builds
    - Archive names and contents
      larceny-1.0a1-src.tar.gz               pruned src tree
      larceny-1.0a1-sunos4-bin.tar.gz        binary, heaps, Scripts/*
      larceny-1.0a1-sunos5-bin.tar.gz        binary, heaps, Scripts/*
      larceny-1.0a-doc.tar.gz                (pruned?) doc tree
  * Finish release notes
  * Put release date on download page.
  * Add archive sizes on download page.
  * Move archives and files to FTP directory
  * Test that FTP works the way it's supposed to.

[Release party]
  * Where & when         [ Tentative: Tue 29 Dec, evening, Franklin ]
  * What to eat          [ Pizza, ice cream, brownies ]
  * What to play with    [ Mac 512K + MacScheme
                           Sage + ExperLisp
                           ??? + Larceny
                           PC + PC Scheme ]

----------------------------------------------------------------------

Things that should be renamed:

  Util/std-heap.sch    ->   Util/larceny-heap.sch
  Util/init-comp.sch   ->   Util/larceny-heap-init.sch
  Eval                 ->   Interpreter
  Eval/eval.sch        ->   Interpreter/interp.sch
  Eval/evalprim.sch    ->   Interpreter/interp-prim.sch

----------------------------------------------------------------------

[FFI]
  * FFI procedures are not hidden in larceny.heap.
  * Sundry bugs must be fixed (see the TODO file).
    - How to load e.g. the file socket-support.o that has unresolved
      external references?
    - Test (better) on SunOS 5.
    - Test on SunOS 4.
    - Write guidelines for compiling C code for use with FFI.
    - Should exit if errors are discovered in the relinking phase.
    - Document!
    - larceny_call() must deal with stack overflow.
  * Testing.

[Standard heap]
  * Should the debugger be in r5rs.heap?  Yes!

[Libraries]
  * Arguably the intepreter's wacky notion of legal environment arguments
    should not be the default.  This should be a switch that's called by
    std-heap.sch and otherwise undocumented. Could call it 

       (interpreter/allow-illegal-use-of-environments)

    Better to fix this properly by integrating environments and syntax
    environments the way it "should" be done.

[Misc]
  * Debugger: breakpt could be called `break-entry' to be compatible
    with MacScheme, would anyway be a better name.

[Assembler bugs]
  * A MacScheme NOP instruction shouldn't result in a NOP being
    generated in the SPARC assembly (I think).

[Compiler bugs]
  * Want switches called
      standard-mode        (what's now called standard-code)
      r4rs-mode
      r5rs-mode
      ieee-mode

  * Want to print a warning if compile-file is used with "slow"
    switch settings (non-semantics-changing optimizations or
    integrate-usual-procedures off).

  * 'Case' really ought to do better when the constants are fixnums, 
     currently it just expands to a call to memv.

  * Block compiler and primitive definitions, e.g., 
       (define car (lambda (x) (car x)))
    [Did the block compiler fix fix this?]

  * Need inline procedures and constant folding for fixnum operations.

