This is the file ${LARCENY}/TODO-RELEASE

We will release the SPARC back-end only for the first release.
The version of the first release will be 1.0-alpha1.

The following items are _important_ to fix or include for the first
release.  The complete to-do list (file ${LARCENY}/TODO) is much longer.


Current task
------------

Agenda
------

 - move over more files from original directory
	Testsuite stuff
	???
 - move Larceny Notes to repository
 - performance tuning / more optimizations / fixnum primitives / 
   flonum primitives / assessment
 - ...

Tasks
-----

[New version of Twobit]  [Will]
  * Hygienic macros.
  * Multiple values (somewhat optional -- can be worked around).
  * Prototype Pass 3.

[Development system]
  * Clean up compile313.sch
    - remove twobit-auxiliary-expander [goes away with new pass1]

[Debugger]
  * Test more, make sure it works OK (at least as well as the old one)
  * Clean up and integrate trace package.

[SPARC assembler]  [Both]
  * Test cases:

    (and (unsafe-code) (write-barrier))             ; fast, generational
    (and (not (unsafe-code)) (write-barrier))       ; safe, generational
    (and (unsafe-code) (not (write-barrier)))       ; fast, stop+copy
    (and (not (unsafe-code)) (not (write-barrier))) ; safe, stop+copy

  * Fixnum-only arithmetic 
    - also with peephole optimization
    - requires some compiler support to rewrite n-ary to binary form
    - operations (compatible with Chez Scheme):

      Operations take fixnum arguments and return fixnum results.
      In safe mode, operands are type checked and the result is checked
      for overflow; in unsafe mode, neither.
        (most-negative-fixnum)
        (most-positive-fixnum)
        (fx+ n1 ...)
        (fx- n1 n2 ...)
        (fx* n1 ...)
        (fxquotient n1 n2)
        (fxremainder n1 n2)

      Operations take fixnum arguments and return boolean results.
      In safe mode, operands are type checked; in unsafe mode, not.
      Must also implement for-control peephole optimization.
        (fx= n1 n2 ...)
        (fx< n1 n2 ...)
        (fx> n1 n2 ...)
        (fx<= n1 n2 ...)
        (fx>= n1 n2 ...)
        (fxzero? n)
        (fxpositive? n)
        (fxnegative? n)

  * Peephole optimization
    - Can improve code for shifts by using `andi r, 0xfc, t' trick.

  * Needless code BLOAT
    - Inline CONS -- 5 instructions out-of-line, 13 in-line.
      Results in about 19KB of extra code in the basic heap image,
      i.e., 2.5KB per instruction we can squeeze from the in-line
      version.
      [ Code mostly implemented -- see sparcprim-part2.sch -- but one
        millicode entry point must be created. New code 8 instructions. ]

[FFI]  [Lars]
  * Sundry bugs must be fixed (see the TODO file).
  * Testing.

[User/reference documentation] [Lars]
  * Clean it up (see the TODO file).

[Misc] [Lars]
  * Clean up toplevel makefile -- most file lists are no longer
    needed, because CVS takes care of distribution management (to a point).
  * Fold patch0.sch into the compiler / assembler
  * Create a version of slib.init that works for Larceny.
  * Fix all BUGS with medium or high priority.
  * Copyright notice on all files, and in the release directory.
  * CVS tag on all files.
  * Release procedure.


If time permits
---------------

[Run-time system]  [Lars]
  * Support heap dumping with generational GC.

[SPARC assembler]
  * The code for op2imm generates slow code for some primitives: it emits 
    the constant into SECOND and then does a non-imm operation.  It gets
    + and - right; it would be nice to get =, <, <=, >, >= also, although
    the savings is one (static or dynamic) instruction, and the peephole
    optimizer gets most of the cases -- it's only where the datum is in
    RESULT and the result is being left in RESULT where this optimization
    matters.  Payoffs are slightly better for char=?, etc, since it's 
    costly to generate a character constant (2 instructions).  Still
    I expect most operations to work on operands in register, so the
    peephole optimizer will take care of it.

  * Peephole optimizations
      Unimplemented peephole operations
        bytevector operations
          bytevector-length
          bytevector-ref          (also op2imm)
          bytevector-set!
          bytevector-like-length
          bytevector-like-ref     (also op2imm)
          bytevector-like-set!
        vector-like operations
          vector-like-length
          vector-like-ref         (also op2imm)
          vector-like-set!
        others
          char->integer
          integer->char
          logand logior logxor lognot sll srl sra


Tasks completed
---------------

[New version of Twobit]
  * Code generator.
  * Bug fixes.

[SPARC assembler]
   * Redundant header load
   * Use HW divide in millicode  [quotient only; some speedup seen]
   * Peephole optimization extensions and bugfixes
      reasonable names for the peepholed operations!
        dresop2imm, etc -- use eg. 'reg/op2imm/setreg' instead
        translate primitive names 'car' -> 'internal:car' in peephole opt.
      boolean evaluation for control:
        numeric comparisons
        character comparisons
        eq?
        null?
        eof-object?
        fixnum?
        char?
      unimplemented peephole optimizations:
        vector operations
          vector-length
          vector-ref    (also op2imm)
          vector-set!
        string operations
          string-length
          string-ref    (also op2imm)
          string-set!
        others
          reg _; op2 set-car!,_ or set-cdr!,_, or cell-set!
          global _ ; setreg _
          reg ; setglbl _
          const _ ; return (when _ fits in instr (sm. fixnum, bool, null))
	  global _; invoke _            (remove redundant check)
          global _; setrtn _; invoke _  (remove redundant check)
          reg _ ; op1 --; setreg _ 
          reg _ ; op1 --
          op1 --; setreg _ 
        misc
          op2imm eq?,x   where x is #t, #f, (), fixnum [also for control]
   * Unsafe-mode should turn off _all_ typechecking
      lognot, logand, logior, logxor
      char->integer
      integer->char
      make-bytevector
      bytevector-fill!
   * It's worthwhile to introduce millicode call for some primitive
     exceptions, encoding the exception code (and possibly other arguments)
     in the handler rather than passing them as arguments; this saves 
     instructions at every call site.
       invoke         -- no need for ex. code
       global         -- cell is in ARGREG2, no need for ex. code
       global/invoke  -- cell is in ARGREG2, no need for ex. code
       argc           -- no need for ex. code or PROC pointer
  * Needless code BLOAT!
     lsh, rshl, rsha both have two copies of error code!
  * Make-string should be a primitive.

[Interpreter]  [Lars]
  * Include debugging support on the level of compiled code (which is not
    impressive, but better).

[Libraries]
  * Dynamic-wind must be made compatible with multiple values.
    [This was already done!]
  * Make run-benchmark compatible with Gambit-C:
      (run-benchmark "name" iterations thunk result-tester)
    Make the new version be compatible with both Gambit and Larceny
    but print a warning if Larceny semantics are being used.

[Development system]
  * Clean up compile313.sch
    - split compiler switches and assembler switches
    - remove twobit-target-architecture, if possible
