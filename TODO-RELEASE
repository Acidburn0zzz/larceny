We will release the SPARC back-end only for the first release.
The version of the first release will be 1.0-alpha1.

The following items are _important_ to fix or include for the first
release.  The complete to-do list (file ${LARCENY}/TODO) is much longer.


Current task
------------

Signatures from Mitch on proposal sheet!


To-do list
----------

 - Copyright on pretty printer                [followup II sent to marc]
 - Investigate stop+copy collector: larceny -stats and display-memstats
   only report one heap area, even with a split heap.  There should be
   two!  Either this is a bug in the reporting code or there's an RTS bug.
 - Move over more files from pre-0.36 directory
	Experimental
	???
 - A graph printer is highly desirable for including source code in compiled
   files -- the unpreprocessed source code as emitted to the heap image
   takes over twice the space of the fully-commented, fully-indented source 
   files.  That's not adequate.


Important Changes to announce
-----------------------------

Lib now has subdirectories.
Make-larceny-heap has been renamed as make-sparc-heap.
Removed backward-compatible names repl-eval-procedure, repl-display-procedure.
nbuild is now build.
Larceny is default host for build -- MUST have 'larceny' in path.
larceny.bin, not larceny.
sparc.heap, not larceny.heap.


Tasks
-----

[New version of Twobit]
  * Hygienic macros.
    - In compiler.            [done]
    - In interpreter.
    - In environments, somehow.
  * Must react to include-procedure-name, etc.
  * I don't understand why load-environment complains about every1? 
    being unavailable -- it's available in COMPILER and should not be
    needed anywhere else.  Why does the name appear in the interaction
    environment?  Who places it there?  It just seems to appear after
    COMPILER has been loaded (see 'check' in load-env.sch).

[Debugger]
  * Interpreter integration.  It would be better if the interpreter
    kept track of two pieces of debugging info: both the current
    expression (which one would get from the summary, maybe) and
    the current interpreted procedure, so that 'C' could print the
    code for the entire procedure, not just the expression.  Debugger
    need not change for this -- it's the interpreter that must be fixed.
    [And while we're at it, WIBNI it kept track of the original source,
     not the macro-expanded source?]
    Wait for new pass1 and use its conventions.

[SPARC assembler]  [Both]
  * Test cases:

    (and (unsafe-code) (write-barrier))             ; fast, generational
    (and (not (unsafe-code)) (write-barrier))       ; safe, generational
    (and (unsafe-code) (not (write-barrier)))       ; fast, stop+copy
    (and (not (unsafe-code)) (not (write-barrier))) ; safe, stop+copy

  * Fixnum-only arithmetic -- see Asm/Sparc/sparcprim-part4.sch.
    Remaining tasks:
      - optimize fx+ and fx- when it's possible to undo.
      - fxquotient, fxremainder
      - pass1 modifications (see the mentioned file)  [will]
      - document it!  We have fx+, fx-, fx--, fx*, fxzero?, fxpositive?,
        fxnegative?, fx=, fx<, fx<=, fx>, fx>=.
      - more testing, but looks OK.


[FFI]
  * Sundry bugs must be fixed (see the TODO file).
    - How to load e.g. the file socket-support.o that has unresolved
      external references?
    - Test (better) on SunOS 5.
    - Test on SunOS 4.
    - Write guidelines for compiling C code for use with FFI.
    - Should exit if errors are discovered in the relinking phase.
    - Document!
    - larceny_call() must deal with stack overflow.
  * Testing.

[User/reference documentation]
  * Compilation documentation
      compiling.html                 [cleaned up, not proofread]
      starting.html
      repl.html
      developing.html
      bdw.html

[Bugs]
  * Fix all BUGS with medium or high priority.

[Misc]
  * Further use of nbuild-files in Lib/makefile.sch.
  * At release time: change home page.
  * Release procedure.
    - decide what's needed in a release, create shell script to strip or
      extract.
    - decide on test procedures.
    - make sure that Build files are included in distribution (this is
      required for a host-less build on a system that can't run the
      precompiled binaries).


If time permits
---------------

[Testing]
  * Clean up test suite in general -- include programs from the
    test directory, and clean them up.
  * Create Larceny Note about how to run tests.

[Run-time system]  [Lars]
  * Support heap dumping with generational GC.

[SPARC assembler]
  * The code for op2imm generates slow code for some primitives: it emits 
    the constant into SECOND and then does a non-imm operation.  It gets
    + and - right; it would be nice to get =, <, <=, >, >= also, although
    the savings is one (static or dynamic) instruction, and the peephole
    optimizer gets most of the cases -- it's only where the datum is in
    RESULT and the result is being left in RESULT where this optimization
    matters.  Payoffs are slightly better for char=?, etc, since it's 
    costly to generate a character constant (2 instructions).  Still
    I expect most operations to work on operands in register, so the
    peephole optimizer will take care of it.

  * Peephole optimizations
      Unimplemented peephole operations
        bytevector operations
          bytevector-length
          bytevector-ref          (also op2imm)
          bytevector-set!
          bytevector-like-length
          bytevector-like-ref     (also op2imm)
          bytevector-like-set!
        vector-like operations
          vector-like-length
          vector-like-ref         (also op2imm)
          vector-like-set!
        others
          char->integer
          integer->char
          logand logior logxor lognot sll srl sra

   - Implement const/setreg/skip peephole optimization for simple constants
     and any target register -- allows the delay slot of the branch to be
     filled.

[Dev. env]
  * Would be possible to just have one procedure 'make-larceny-heap' that
    would build for the correct target.  This would be a real improvement.


Tasks completed
---------------

[New version of Twobit]
  * Code generator.
  * Bug fixes.

[SPARC assembler]
   * Redundant header load
   * Use HW divide in millicode  [quotient only; some speedup seen]
   * Peephole optimization extensions and bugfixes
      reasonable names for the peepholed operations!
        dresop2imm, etc -- use eg. 'reg/op2imm/setreg' instead
        translate primitive names 'car' -> 'internal:car' in peephole opt.
      boolean evaluation for control:
        numeric comparisons
        character comparisons
        eq?
        null?
        eof-object?
        fixnum?
        char?
      unimplemented peephole optimizations:
        vector operations
          vector-length
          vector-ref    (also op2imm)
          vector-set!
        string operations
          string-length
          string-ref    (also op2imm)
          string-set!
        others
          reg _; op2 set-car!,_ or set-cdr!,_, or cell-set!
          global _ ; setreg _
          reg ; setglbl _
          const _ ; return (when _ fits in instr (sm. fixnum, bool, null))
	  global _; invoke _            (remove redundant check)
          global _; setrtn _; invoke _  (remove redundant check)
          reg _ ; op1 --; setreg _ 
          reg _ ; op1 --
          op1 --; setreg _ 
        misc
          op2imm eq?,x   where x is #t, #f, (), fixnum [also for control]
   * Unsafe-mode should turn off _all_ typechecking
      lognot, logand, logior, logxor
      char->integer
      integer->char
      make-bytevector
      bytevector-fill!
   * It's worthwhile to introduce millicode call for some primitive
     exceptions, encoding the exception code (and possibly other arguments)
     in the handler rather than passing them as arguments; this saves 
     instructions at every call site.
       invoke         -- no need for ex. code
       global         -- cell is in ARGREG2, no need for ex. code
       global/invoke  -- cell is in ARGREG2, no need for ex. code
       argc           -- no need for ex. code or PROC pointer
  * Needless code BLOAT!
    - lsh, rshl, rsha both have two copies of error code -- fixed
    - Inline CONS -- 5 instructions out-of-line, 13 in-line.
      Results in about 19KB of extra code in the basic heap image,
      i.e., 2.5KB per instruction we can squeeze from the in-line
      version.  New code 8 instructions.
  * Make-string should be a primitive.
  * Shifts now check shift count.

[Interpreter]  [Lars]
  * Include debugging support on the level of compiled code (which is not
    impressive, but better).

[Libraries]
  * Dynamic-wind must be made compatible with multiple values.
    [This was already done!]
  * Make run-benchmark compatible with Gambit-C:
      (run-benchmark "name" iterations thunk result-tester)
    Make the new version be compatible with both Gambit and Larceny
    but print a warning if Larceny semantics are being used.

[Development system]
  * Clean up compile313.sch
    - split compiler switches and assembler switches
    - remove twobit-target-architecture, if possible
