
			 Wouldn't it be nice if...
		  Various possible enhancements to Larceny

			 Last updated 940803 by lth



Section I. Performance enhancements

001 (old idea) 

    Can we keep the return address in a register? For leaves, this is a bit
    of a win because we save a store and a load on each call to a leaf.

    Simply speaking, we can save the return address on a SAVE and restore
    it on a POP. (Some parts of the run-time system must change to make
    this work properly, but it is clearly doable.) When the compiler emits
    code which allocates only one reusable stack frame per procedure, we
    are in business.

002 (old idea)

    Every global should have a function cell. The compiler must know about
    this cell. When calling a globally bound procedure, it can execute a
    special variant of the 'GLOBAL' instruction to fetch the contents of the
    function cell; it can then generate a variant of INVOKE which does not
    check that its argument is a procedure. We must also change the SETGLBL
    instruction to update the cell correctly.

    The cell representation must be changed for this to work if we still
    want to be able to keep the cell's name around.

    The peephole optimizer can do this to an extent.

003 (old idea)

    We should use an operating system timer instead of a software timer.
    There is some hair associated with dealing with timer interrupts and
    switching between modes (context switches may become more expensive
    and fast context switches (save and restore) are not so simple any more),
    and if the traps are very expensive this will not save much, but in
    general it is probably a win.

    Calls to unknown procedures will be faster because the timer check
    can be part of the argc check.

    In particular, once the interrupt handling logic is in place, we can
    deal with other interrupts like ^C and breakpoints generated by trap
    instructions.

004 (old idea)

    The varargs millicode should do the checks for no extra args so that we
    can avoid falling into C in this (fairly ocmmon, I think) case.

005 (old idea)

    Schedule the instructions in the compnum code.

006 940719 / lth (v0.20)

    Double-word loads and store should be implemented for SAVE/RESTORE
    and in the context-switching code. Ideally, it should also be implemented
    in LAMBDA/LEXES, but that means changing the procedure layout.

    This means that we must doubleword-align REG0 in the globals table,
    and make sure it stays aligned.

007 940721 / lth (v0.20)

    Should avoid storing the frame size in the frame until the frame is
    spilled. Instead, the return address can be used as a pointer into
    the code stream to look for a literal which contains the frame size.

    This saves two instructions (and one memory reference) on every frame
    creation; its payoff once the compiler reuses stack frames is uncertain.
    
    This idea does not interact real well code which defers generating a 
    return address to the time of the call rather than setting the 
    return address up at the time the frame is saved; if the stack must
    be flushed after the stack was created but before the return address
    is generated, there is no way for it to know the size.

008 940721 / lth (v0.20)

    Implement calls to madvise(); this may be a win if memory is tight.

009 940803 / lth (v0.21)

    Some callee-saves registers, perhaps.

010 940803 / lth (v0.21)

    More peephole optimizations:
     - collapse 'global + invoke' into 'global-funcell + invoke-proc',
       so that we can have a function cell. The compiler can do this too,
       but I bet the peephole optimizer does nearly as well.

     - collapse strings of CONSes to allocate memory once and then
       simply grab from this pool. Not general, but should work well
       on open-coded calls to 'list'.

011 940803 / lth (v0.21)

    General post-optimization:
     - perform more register allocation in the assembler to map the
       virtual registers onto available HW registers, as needed.

     - collapse some storage allocation checks (CONS) with heap overflow
       check, since stack lives in heap.

     - caching ribs and constant vectors in registers; really a special
       case of CSE.

012 940803 / lth (v0.21)

    Faster globals checking using trampolines: every global reference is
    compiled as a three-instruction call to a millicode procedure:

	jmpli	[ %MILLICODE + MC_GLOBAL ], %o7
	mov	<const vector offset for cell>, %TMP0
	nop

    The millicode proc checks the global, and signals an exception if it
    is not set. If the global is already OK, it overwrites the above code
    with the typical 3-instruction sequence for 'global'.

    Drawbacks: the three loads will not be able to utilize any cached
    constant vector, and the loads cannot be scheduled. If code is in the
    static area, the static area must be unprotected before the writes.
    Caches must be flushed after the write. General complexity.

    Advantages: full checking at the same cost (currently) as no checking.

013 940803 / lth (v0.21)

    Assembler hacks:
     - Multiply-by-fixnum-constant can be coded in-line in many cases.

     - Quotient/remainder by fixnum power of 2 can be coded in-line.


II. Nice features to have

001 (old idea)

    Add a profiler. We want to do something like the one described by 
    Appel/Duba/MacQueen for SML/NJ; should probably put this into the
    compiler, but it could go into the first pass of the assembler without
    messing up any machine dependent code generators or constant vector
    layouts.

002 940719 / lth (v0.20)

    We want more memory statistics: user time spent in gc; sizes of heaps. 

003 940719 / lth (v0.20)

    Support for a 'system call' primop so that we can avoid all the different
    assembly language callouts for e.g. Unix primitives. What we want is
    a single callout 'syscall' which takes a numeric argument (the primitive
    to call) and some more arguments; the C code then looks up the procedure
    in a table and jumps to it with the arguments required. For example,
    we call a procedure syscall

       (syscall syscall/unixio/read fd buffer nbytes)

    where the syscall procedure is coded simply as

       ((op1 syscall)
        (return))

    which is translated to a millicode trap which just falls into C:

      void C_syscall()
      {
        system_calls[ nativeint( globals[ G_REG1 ] ) ]();
      }

    where system_calls is an array of procedures. This is, in some sense,
    a very limited foreign function interface.

004 940721 / lth (v0.20)

    Port to Solaris (since SunOS is dying). Should not be hard.

005 940721 / lth (v0.20)

    Support split instruction and data caches (I believe the Sparc 10 have
    split caches); the collector must flush any addresses in tospace which
    contain code.

006 940721 / lth (v0.20)

    Move over to ANSI C; gcc is available nearly everywhere and even Sun have
    ANSI-compliant compilers.
