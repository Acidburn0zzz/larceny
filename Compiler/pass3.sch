; Third pass of the Scheme 313 compiler:
;   estimation of types and representations.
;
; This pass operates as a source-to-source transformation on
; expressions written in the subset of Scheme described by the
; following grammar, where the input and output expressions
; satisfy certain additional invariants described below.
;
; "X ..." means zero or more occurrences of X.
;
; L  -->  (lambda (I_1 ...)
;           (begin D ...)
;           (quote <info>)
;           E)
;      |  (lambda (I_1 ... . I_rest)
;           (begin D ...)
;           (quote (R F))
;           E)
; D  -->  (define I L)
; E  -->  (quote K)                        ; constants
;      |  (begin I)                        ; variable references
;      |  L                                ; lambda expressions
;      |  (E0 E1 ...)                      ; calls
;      |  (set! I E)                       ; assignments
;      |  (if E0 E1 E2)                    ; conditionals
;      |  (begin E0 E1 E2 ...)             ; sequential expressions
; I  -->  <identifier>
;
; <info>  -->  (T F)
; T  -->  <see below>
; F  -->  (I ...)
;
; Invariants that hold for the input:
;   *  There are no assignments except to global variables.
;   *  If I is declared by an internal definition, then the right hand
;      side of the internal definition is a lambda expression and I
;      is referenced only in the procedure position of a call.
;   *  Every procedure defined by an internal definition takes a
;      fixed number of arguments.
;   *  For each lambda expression, the associated F is a list of all
;      the identifiers that occur free in the body of that lambda
;      expression, and possibly a few extra identifiers that were
;      once free but have been removed by optimization.
;   *  Variables named IGNORED are neither referenced nor assigned.
;   *  The T field is garbage.
;
; Invariants that hold for the output:
;   *  There are no assignments except to global variables.
;   *  If I is declared by an internal definition, then the right hand
;      side of the internal definition is a lambda expression and I
;      is referenced only in the procedure position of a call.
;   *  Every procedure defined by an internal definition takes a
;      fixed number of arguments.
;   *  For each lambda expression, the associated F is a list of all
;      the identifiers that occur free in the body of that lambda
;      expression, and possibly a few extra identifiers that were
;      once free but have been removed by optimization.
;   *  Variables named IGNORED are neither referenced nor assigned.
;   *  The T field contains the type inferred for the lambda expression.
;
; Limitations:  Type estimation is performed for only one group of
; internal definitions at a time.  The types of innermost definitions
; are estimated first, assuming nothing about the types of outer
; variables.  This is probably the wrong order.  To do it right,
; all internal definitions should be lifted to the outermost lambda
; expression, the types should be estimated, and then internal
; definitions should be lowered to their final position.  Another
; problem with estimating the types of innermost definitions first
; is that the algorithm has to traverse them multiple times.  What
; to do?
;
; Algorithm:  Given a group of internal definitions
; (BEGIN (DEFINE f_1 (LAMBDA (v_11 v_12 ...) ...)) ...) and the
; expression E in the body of the lambda that contains the definitions,
; choose new type variables a_11, a_12, ..., b_1, b_2, ... and solve
; the data flow equations
;
;    b_1 = <type synthesized for body of f_1>
;       ...
;    a_11 = <join over all calls to f_1 of type of first argument>
;       ...
;
; by using \bottom as the initial approximation for all type variables.
; A LET encountered within E or the definition of an f_i is treated as
; though the manifest lambda expression were the rhs of an internal
; definition, but taking extra arguments that correspond to the formal
; arguments of the procedure within which it appears.  Exception: any
; nested internal definitions or lambda expressions that appear within
; nested internal definitions will simply be assumed to have type
; object x ... x object --> object.

; Types.
;
; The types manipulated by this compiler are generated by:
;
; T  -->  D  |  (procedure P1 P2 ...)
; D  -->  (object)
;      |  (boolean)
;      |  (character)
;      |  (string)
;      |  (symbol)
;      |  (emptylist)
;      |  (pair D1 D2)            ; (pair)   = (pair (object) (object))
;      |  (list D)                ; (list)   = (list (object))
;      |  (vector D)              ; (vector) = (vector (object))
;      |  (procedure)
;      |  (number)
;      |  (exact)
;      |  (inexact)
;      |  (real)
;      |  (exactreal)
;      |  (inexactreal)
;      |  (integer)
;      |  (exactinteger)
;      |  (inexactinteger)
;      |  (fixnum)
;      |  (index)
;      |  (bottom)
; P  -->  (T A ...)
; A  -->  D  |  (not D)
;
; These types form a complete lattice under the transitive closure of:
;
;     (bottom)          <=        T        <=  (object)
;     (emptylist)       <=  (list T)
;     (pair T (list T)) <=  (list T)
;     (integer)         <=  (real)         <=  (number)
;     (inexactinteger)  <=  (inexactreal)  <=  (inexact)  <=  (number)
;     (exactinteger)    <=  (exactreal)    <=  (exact)    <=  (number)
;     (inexactinteger)  <=  (integer)
;     (inexactreal)     <=  (real)
;     (exactinteger)    <=  (integer)
;     (exactreal)       <=  (real)
;     (index)           <=  (fixnum)       <=  (exactinteger)
;
; and for procedure types T1 and T2, T1 <= T2 iff:
;
; for all (T A1 ... Ak) such that T2 = (procedure ... (T A1 ... Ak) ...),
; /\ { T'  |  T1 = (procedure ... (T' A1' ... Ak') ...)
;             & A1 <= A1' & ... & Ak <= Ak' }
;   <=  T
;
; where /\ means glb and (procedure) is taken to mean
; (procedure ((object)) ((object) (object)) ((object) (object) (object)) ...)
;
; and where the ordering on simple types D is extended to complement types A by
; (not D1)  <=  (not D2)     iff  D2 <= D1;
; (not D1)  <=  D2           iff  D1 = (object) or D2 = (object);
; D1        <=  (not D2)     iff  (join D1 D2) = (object).
;
; The second case of this particular extension to complement types
; is justified by the fact that for any types T1 and T2 other than (object),
; there exists a type T3 disjoint from both T1 and T2.
; The third case is justified by the fact that joins in the sublattice
; of simple types are identical to unions in the domain of expressed values.
;
; Interpretation of procedure types.
;
;     P = (T A ...) means that when given arguments of type A ...,
;     the procedure is guaranteed to return a result of type T if
;     it returns at all.  (A value x is of type (not T) if x is not
;     of type T.)
;     (procedure P ...) means the meet of the types (procedure P) ...;
;     that is, the procedure satisfies all of the partial specifications
;     P ... .
;
; Example:  The type of + is
; (procedure ((bottom) (not (number)) (not (number)))
;            ((number) (number) (number))
;            ((exact) (exact) (exact))
;            ((inexact) (exact) (inexact))
;            ((inexact) (inexact) (exact))
;            ((inexact) (inexact) (inexact))
;            ((real) (real) (real))
;            ((integer) (integer) (integer))
;            ((fixnum) (index) (index)))
;
; The + procedure also satisfies the following specifications, but these
; are implied by the above:
;            ((object) (object) (object))
;            ((inexactreal) (inexactreal) (inexactreal))
;            ((exactinteger) (exactinteger) (exactinteger))
;            ((exactinteger) (fixnum) (fixnum))
; and so on.
;
;
; Type expressions.
;
; Texp  -->  T
;         |  Tvar
;         |  (call Texp0 Texp1 ...)
;         |  (join Texp ...)
;         |  (meet Texp ...)
; Tvar  -->  <string>

; The uninteresting part: traverse the given expression until
; a group of internal definitions is found.

(define (pass3 exp)
  (define (f exp)
    (case (car exp)
      ((quote)    #t)
      ((lambda)   (lambda.T-set! type:procedure)
                  (if (null? (lambda.defs exp))
                      (f (lambda.body exp))
                      (estimate-types exp)))
      ((set!)     (f (assignment.rhs exp)))
      ((if)       (f (if.test exp))
                  (f (if.then exp))
                  (f (if.else exp)))
      ((begin)    (if (variable? exp)
                      #t
                      (for-each f (begin.exprs exp))))
      (else       (f (call.proc exp))
                  (for-each f (call.args exp)))))
  (f exp))

(define (estimate exp env flow)
  (case (car exp)
    ((quote)    (values (typeof (constant.value)) constraints:null))
    ((lambda)   (estimate-lambda exp env flow))
    ((set!)     (values type:object constraints:null))
    ((if)       (estimate-conditional (if.test exp)
                                      (if.then exp)
                                      (if.else exp)
                                      env
                                      flow))
    ((begin)    (if (variable? exp)
                    (values (type-env-lookup env (variable.name exp))
                            constraints:null)
                    (estimate-sequential (begin.exprs exp) env flow)))
    (else       (estimate-call (call.proc exp) (call.args exp) env flow))))

(define (estimate-lambda exp env flow)
  (let ((formals (make-null-terminated (lambda.args exp)))
        (newenv
         (extend-type-env env
                          formals
                          (map (lambda (x) type:object) formals))))
    (estimate-lambda-body exp newenv flow)
    (values type:procedure constraints:null)))

(define (estimate-lambda-body exp env flow)
  (let* ((defs (lambda.defs exp))
         (procnames (map def.lhs defs))
         (templates (map cons
                         procnames
                         (map lambda.args (map def.rhs defs))))
         (flow (extend-flow flow templates))
         (env2 (extend-type-env env
                                procnames
                                (map (lambda (name)
                                       (flow-lookup flow name))
                                     procnames))))
    (for-each (lambda (def)
                (flow-constrain!
                 flow
                 (def.lhs def)
                 (estimate (lambda.body (def.rhs def))
                           (extend-type-env
                            env2
                            (lambda.args (def.rhs def))
                            (map (lambda (i)
                                   (flow-lookup-arg flow i))
                                 (iota (length (lambda.args (def.rhs def))))))
                           flow)))
              defs)
    (estimate (lambda.body exp) env2 flow)))

(define (estimate-conditional e0 e1 e2 env flow)
  (receive-values
   (lambda () (estimate e0 env flow))
   (lambda (type0 constraints0)
     (let ((newenv (constrain-type-env env constraints0)))
       (receive-values
        (lambda ()
          (estimate e1
                    (if (and (call? e0)
                             (variable? (call.proc e0))
                             (type-predicate? (variable.name (call.proc e0)))
                             (variable? (car (call.args e0))))
                        (constrain-type-env
                         newenv
                         (make-type-constraint
                          (variable.name (call.args e0))
                          (type-predicate-type (variable.name (call.proc e0)))))
                        newenv)
                    flow))
        (lambda (type1 constraints1)
          (receive-values
           (lambda () (estimate e2 newenv flow))
           (lambda (type2 constraints2)
             (values (join-types type1 type2)
                     (meet-constraints
                      constraints0
                      (join-constraints constraints1 constraints2)))))))))))         

(define (estimate-sequential exprs env flow)
  (if (null? (cdr exprs))
      (estimate (car exprs) env flow)
      (receive-values
       (lambda () (estimate (car exprs) env flow))
       (lambda (type constraints)
         (estimate-sequential (cdr exprs)
                              (constrain-type-env env constraints)
                              flow)))))

(define (estimate-call proc args env flow)
  (receive-values
   (lambda () (estimate-args args env flow))
   (lambda (types constraints1)
     (let ((newenv (constrain-type-env env constraints1)))
       (receive-values
        (lambda () (estimate proc newenv flow))
        (lambda (type0 constraints0)
          (let ((constraints2
                 (if (ground-type? type0)
                     (compute-constraints type0 proc args env flow)
                     '())))
            (let ((constraints (union constraints0 constraints1 constraints2)))
              (values (make-type-call (constrain-type type0 constraints)
                                      (constrain-types types constraints))
                      constraints)))))))))

(define (estimate-args exprs env flow)
  (if (null? (cdr exprs))
      (receive-values
       (lambda () (estimate (car exprs) env flow))
       (lambda (type constraints)
         (values (list type) constraints)))
      (receive-values
       (lambda () (estimate (car exprs) env flow))
       (lambda (type0 constraints0)
         (receive-values
          (lambda () (estimate-args (cdr exprs) env flow))
          (lambda (types constraints)
            (values (cons type0 types)
                    (union constraints0 constraints))))))))

; Constraints come from calls in which the type of the procedure
; is known (a ground type) and at least one argument is a variable
; reference.

(define (compute-constraints type0 proc args env flow)
  (define (loop badtype-tuples args)
    (cond ((null? args) '())
          ((variable? (car args))
           (union (constrain (variable.name (car args))
                             (map car badtype-tuples))
                  (loop (map cdr badtype-tuples) (cdr args))))
          (else (loop (map cdr badtype-tuples) (cdr args)))))
  (define (constrain name badtypes)
    (cond ((null? badtypes) '())
          ((negative-type? (car badtypes))
           (cons (list name (type-complement (car badtypes)))
                 (constrain name (cdr badtypes))))
          (else (constrain name (cdr badtypes)))))
  (cond ((not (ground-type? type0)) '())
        ((not (procedure-type? type0))
         (warn "Call to non-procedure" type0 proc args)
         '())
        (else (let ((badtype-tuples (map cdr (error-specs type0))))
                (if (not (null? badtype-tuples))
                    (loop badtype-tuples args)
                    '())))))

; Auxiliary procedures for pass 3.

(define (lambda.T L) (car (cadr (cadddr exp))))
(define (lambda.T-set! L T) (set-car! (cadr (cadddr exp)) T))

; Flow equation structures.
; A typical structure looks like
;
;    (((reverse z)           ; templates
;      (loop x y))
;     ((b_1 a_11)            ; typevars
;      (b_2 a_21 a_22))
;     ((b_1 b_2)                     ; b_1 is a subtype of b_2
;      (b_2 a_22)                    ; b_2 is a subtype of a_22
;      (b_2 b_2)                     ; b_2 is a subtype of b_2
;      (a_11 OBJECT)                 ; a_11 is a subtype of OBJECT
;      (a_21 a_11)                   ; a_21 is a subtype of a_11
;      (a_22 EMPTYLIST)              ; a_22 is a subtype of EMPTYLIST
;      (a_21 (CDR a_21))             ; a_21 is a subtype of (CDR a_21)
;      (a_22 (CONS (CAR a_21) a_22)  ; a_22 is a subtype of (CONS (CAR a_21) a_22)

(define (make-flow templates)
  (list templates
        (map (lambda (template)
               (map generate-type-variable template))
             templates)
        '()))
(define (flow.templates flow) (car flow))
(define (flow.typevars flow) (cadr flow))
(define (flow.inequalities flow) (caddr flow))

(define (flow-template-add! flow template)
  (set-car! flow (cons template (car flow)))
  (set-car! (cdr flow)
            (cons (map generate-type-variable template)
                  (cadr flow))))
(define (flow-inequality-add! flow lhs rhs)
  (set-car! (cddr flow)
            (cons (list lhs rhs) (caddr flow))))

; OUTLINE: TODO.
;
; (traverse exp env flow)
; returns [T constraints]
;
;    exp            expression
;    env            map from identifiers to type expressions
;    flow           mutable structure containing:
;                     set of flow equations.
;                     a map from known procedure names to list of
;                       type variables (b a1 ... ak).
;                     a map from known procedure names to lambda
;                       expressions.
;    T              a type
;    constraints    set of inequalities of form a_i <= texp,
;                   where a_i is a type variable and texp is
;                   a type expression.
