;; Larceny -- the generic assembler.
;; Peephole optimization code.
;;
;; $Id$
;;
;; The procedure peep is called with the as structure as an argument
;; before every instruction is emitted. It may replace the prefix of the
;; instruction stream by some other instruction sequence.
;;
;; The current structure is not quite right; if we have a stream ABD and
;; the patterns are AB, ABC, and BD, and BD is preferred over AB, then AB
;; will still be chosen because it comes first. Hard to see a good way
;; around this.
;;
;; Invariant: if the peephole optimizer finds nothing to fix, then 
;;
;;  (let ((t1 (as-source as)))
;;    (peep as)
;;    (eq? t1 (as-source as)))
;;
;; that is, the source list is not changed, and indeed, if the optimizer
;; does change something, then the above does not hold.

(define (peep as)
  (let* ((t0 (as-source as))
	 (i1  (if (null? t0) '(-1 0 0 0) (car t0)))
	 (t1  (if (null? t0) t0 (cdr t0)))
	 (i2  (if (null? t1) '(-1 0 0 0) (car t1)))
	 (t2  (if (null? t1) t1 (cdr t1)))
	 (i3  (if (null? t2) '(-1 0 0 0) (car t2)))
	 (t3  (if (null? t2) t2 (cdr t2)))
	 (o1  `(car cdr ,name:CELL-REF))   ; unary ops for reg-op-setreg
	 (o2  '(+ - eq? cons))             ; binary ditto
	 (o2i '(+ -))                      ; ditto with immediate
	 (b1  '(null? pair? zero?))        ; unary ops for reg-test-branch
	 (b2  '(< > >= <= = eq?))          ; binary ditto
	 (b2i '(< > >= <= = eq?)))         ; ditto with immediate
    (cond ((and (eq? (car i1) $reg) (hwreg? (cadr i1)))
	   (cond ((and (eq? (car i2) $op1) (memq (cadr i2) o1))
		  (cond ((and (eq? (car i3) $setreg) (hwreg? (cadr i3)))
			 ; (reg n)
			 ; (op1 op)
			 ; (setreg m)
			 (as-source! as (cons `(,$dresop1 ,(cadr i2)
							  ,(cadr i1)
							  ,(cadr i3))
					      t3)))
			(else
			 ; (reg n)
			 ; (op1 op)
			 (as-source! as (cons `(,$dresop1 ,(cadr i2)
							  ,(cadr i1)
							  RESULT)
					      t2)))))
		 ((and (eq? (car i2) $op2) (memq (cadr i2) o2))
		  (cond ((and (eq? (car i3) $setreg) (hwreg? (cadr i3)))
			 ; (reg n)
			 ; (op2 op m)
			 ; (setreg l)
			 (as-source! as (cons `(,$dresop2 ,(cadr i2)
							  ,(cadr i1)
							  ,(caddr i2)
							  ,(cadr i3))
					      t3)))
			(else
			 ; (reg n)
			 ; (op2 op m)
			 (as-source! as (cons `(,$dresop2 ,(cadr i2)
							  ,(cadr i1)
							  ,(caddr i2)
							  RESULT)
					      t2)))))
		 ((and (eq? (car i2) $op2imm)
		       (memq (cadr i2) o2i)
		       (immediate-int? (caddr i2)))
		  (cond ((and (eq? (car i3) $setreg) (hwreg? (cadr i3)))
			 ; (reg n)
			 ; (op2imm op i)
			 ; (setreg m)
			 (as-source! as (cons `(,$dresop2imm ,(cadr i2)
							     ,(cadr i1)
							     ,(caddr i2)
							     ,(cadr i3))
					      t3)))
			(else
			 ; (reg n)
			 ; (op2imm op i)
			 (as-source! as (cons `(,$dresop2imm ,(cadr i2)
							     ,(cadr i1)
							     ,(caddr i2)
							     RESULT)
					      t2)))))
		 ; (reg n)
		 ; (op1 op)
		 ; (branchf L)
		 ((and (eq? (car i2) $op1)
		       (memq (cadr i2) b1)
		       (eq? (car i3) $branchf))
		  (as-source! as (cons `(,$optbreg1 ,(cadr i2)
						    ,(cadr i1)
						    ,(cadr i3))
				       t3)))
		 ; (reg n)
		 ; (op2 op m)
		 ; (branchf L)
		 ((and (eq? (car i2) $op2)
		       (memq (cadr i2) b2)
		       (eq? (car i3) $branchf))
		  (as-source! as (cons `(,$optbreg2 ,(cadr i2)
						    ,(cadr i1)
						    ,(caddr i2)
						    ,(cadr i3))
				       t3)))
		 ; (reg n)
		 ; (op2imm op i)
		 ; (branchf L)
		 ((and (eq? (car i2) $op2imm)
		       (memq (cadr i2) b2i)
		       (eq? (car i3) $branchf)
		       (immediate-int? (caddr i2)))
		  (as-source! as (cons `(,$optbreg2imm ,(cadr i2)
						       ,(cadr i1)
						       ,(caddr i2)
						       ,(cadr i3))
				       t3)))
		 ; (reg n)
		 ; (setreg m)
		 ((eq? (car i2) $setreg)
		  (if (eq? (cadr i1) (cadr i2))
		      (as-source! as t2)
		      (as-source! as (cons `(,$movereg ,(cadr i1) ,(cadr i2))
					   t2))))
		 (else
		  #f)))
	  ; (op1 op)
	  ; (branchf L)
	  ((and (eq? (car i1) $op1)
		(memq (cadr i1) b1)
		(eq? (car i2) $branchf))
	   (as-source! as (cons `(,$optbreg1 ,(cadr i1)
					     RESULT
					     ,(cadr i2))
				t2)))
	  ; (op2 op n)
	  ; (branchf L)
	  ((and (eq? (car i1) $op2)
		(memq (cadr i1) b2)
		(eq? (car i2) $branchf))
	   (as-source! as (cons `(,$optbreg2 ,(cadr i1)
					     RESULT
					     ,(caddr i1)
					     ,(cadr i2))
				t2)))
	  ; (op2imm op imm)
	  ; (branchf L)
	  ((and (eq? (car i1) $op2imm)
		(memq (cadr i1) b2i)
		(eq? (car i2) $branchf)
		(immediate-int? (caddr i1)))
	   (as-source! as (cons `(,$optbreg2imm ,(cadr i1)
						RESULT
						,(caddr i1)
						,(cadr i2))
				t2)))
	  ; (const c)
	  ; (setreg n)
	  ((and (eq? (car i1) $const)
		(eq? (car i2) $setreg)
		(hwreg? (cadr i2)))
	   (as-source! as (cons `(,$constreg ,(cadr i1) ,(cadr i2))
				t2)))
	  ; (op1 op)
	  ; (setreg k)
	  ((and (eq? (car i1) $op1)
		(memq (cadr i1) o1)
		(eq? (car i2) $setreg)
		(hwreg? (cadr i2)))
	   (as-source! as (cons `(,$dresop1 ,(cadr i1)
					    RESULT
					    ,(cadr i2))
				t2)))
	  ; (op2 op k1)
	  ; (setreg k2)
	  ((and (eq? (car i1) $op2)
		(memq (cadr i1) o2)
		(eq? (car i2) $setreg)
		(hwreg? (cadr i2)))
	   (as-source! as (cons `(,$dresop2 ,(cadr i1)
					    RESULT
					    ,(caddr i1)
					    ,(cadr i2))
				t2)))
	  ; (op2imm op imm)
	  ; (setreg k)
	  ((and (eq? (car i1) $op2imm)
		(memq (cadr i1) o2i)
		(eq? (car i2) $setreg)
		(hwreg? (cadr i2)))
	   (as-source! as (cons `(,$dresop2imm ,(cadr i1)
					       RESULT
					       ,(caddr i1)
					       ,(cadr i2))
				t2)))
	  (else
	   #f))))


(define (peeptest istream)
  (let ((as (make-assembly-structure istream)))
    (let loop ((l '()))
      (if (null? (as-source as))
	  (reverse l)
	  (begin (peep as)
		 (let ((a (car (as-source as))))
		   (as-source! as (cdr (as-source as)))
		   (loop (cons a l))))))))

