<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from sassy.tex by tex2page, v 20050501
(running on MzScheme 301, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
Sassy - 0.2
</title>
<link rel="stylesheet" type="text/css" href="sassy-Z-S.css" title=default>
<meta name=robots content="noindex,follow">
</head>
<body>
<div id=content>
<div align=right class=navigation><i>[Go to <span><a href="sassy.html">first</a>, <a href="sassy-Z-H-6.html">previous</a></span><span>, <a href="sassy-Z-H-8.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="sassy-Z-H-2.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="sassy-Z-H-15.html#node_index_start">index</a></span>]</i></div>
<p></p>
<a name="node_chap_5"></a>
<h1 class=chapter>
<div class=chapterheading><a href="sassy-Z-H-2.html#node_toc_node_chap_5">Chapter 5</a></div><br>
<a href="sassy-Z-H-2.html#node_toc_node_chap_5">The Text Section</a></h1>
<p>
<a name="node_idx_86"></a></p>
<p>
<a name="node_tag_Temp_8"></a>
<a name="node_tag_Temp_9"></a></p>
<p>
This chapter describes Sassy's instruction syntax and its facilities
for controlling the flow of computation. If you only want to write
traditional-looking assembly programs with Sassy, consisting of just
labels and instructions, then Sassy can handle that just fine.</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>text</span> <span class=variable>&lt;text-top-level&gt;</span> ...)

<span class=variable>text-top-level</span> <span class=variable>=</span> (<span class=keyword>label</span> <span class=variable>&lt;label&gt;</span>)                             <span class=comment>; &quot;empty&quot; label definition</span>
               | (<span class=keyword>label</span> <span class=variable>&lt;label&gt;</span> <span class=variable>&lt;text-item&gt;</span> ...)             <span class=comment>; label definition</span>
               | (<span class=keyword>locals</span> (<span class=variable>&lt;label-name&gt;</span> ...) <span class=variable>&lt;text-item&gt;</span> ...) <span class=comment>; locals declaration</span>
               | <span class=variable>&lt;text-item&gt;</span>                                 <span class=comment>; anonymous text</span>
               | (<span class=keyword>align</span> <span class=variable>&lt;amount&gt;</span>)

<span class=variable>text-item</span>      <span class=variable>=</span> (<span class=keyword>label</span> <span class=variable>&lt;label&gt;</span>)
               | (<span class=keyword>label</span> <span class=variable>&lt;label&gt;</span> <span class=variable>&lt;text-item&gt;</span> ...)
               | (<span class=keyword>locals</span> (<span class=variable>&lt;label-name&gt;</span> ...) <span class=variable>&lt;text-item&gt;</span> ...)
               | <span class=variable>&lt;instruction&gt;</span>
               | <span class=variable>&lt;assertion&gt;</span>
               | <span class=variable>&lt;control-primitive&gt;</span>
               
</pre><p></p>
<p>
Note: in the text section, the <code class=scheme><span class=keyword>align</span></code> special form may only appear at a <code class=scheme><span class=keyword>text</span></code> directive's top level.</p>
<p>

</p>
<a name="node_sec_5.1"></a>
<h2><a href="sassy-Z-H-2.html#node_toc_node_sec_5.1">5.1&nbsp;&nbsp;Instructions</a></h2>
<p>
<a name="node_idx_88"></a></p>
<p>
<a name="node_tag_Temp_10"></a></p>
<p>
Sassy's instruction syntax is based on Intel's, except that each instruction looks like a Scheme function call. Thus there are no commas. Sassy uses the same instruction and register names and recognizes the same operands as those listed in the <a href="http://intel.com/design/pentium4/manuals/index_new.htm#sdm_vol2a">Intel manuals</a>. The order of the operands is also identical, and so, like the <code class=verbatim>set!</code> idiom of Scheme, the destination comes first, the source second.</p>
<p>
</p>
<pre class=verbatim>intel: add eax, 4&nbsp;
intel: mov cx, 3&nbsp;
&nbsp;
sassy: (add eax 4)&nbsp;
sassy: (mov cx 3)&nbsp;
</pre><p></p>
<p>

</p>
<a name="node_sec_5.1.1"></a>
<h3><a href="sassy-Z-H-2.html#node_toc_node_sec_5.1.1">5.1.1&nbsp;&nbsp;Immediates</a></h3>
<p>
<a name="node_idx_90"></a></p>
<p>
Immediates are usually integers of the appropriate size. If an operand is a dword-sized operand and you write a float, <code class=verbatim>sassy</code> converts it to its little-endian IEEE-754 single-precision representation.</p>
<p>
You may also write characters and strings. <code class=verbatim>sassy</code> places the byte value of the character in the lowest order byte and places <code class=verbatim>0</code> in the rest. A string can have no more characters than the size in bytes of the operand; <code class=verbatim>sassy</code> pads the remainder with <code class=verbatim>0</code>.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>mov</span> <span class=variable>eax</span> (<span class=keyword>dword</span> <span class=selfeval>#\a</span>))   <span class=variable>=&gt;</span> (<span class=variable>mov</span> <span class=variable>eax</span> <span class=selfeval>#x61</span>)
(<span class=variable>mov</span> <span class=variable>eax</span> (<span class=keyword>dword</span> <span class=selfeval>&quot;abc&quot;</span>)) <span class=variable>=&gt;</span> (<span class=variable>mov</span> <span class=variable>eax</span> <span class=selfeval>#x61626300</span>)
</pre><p></p>
<p>

</p>
<a name="node_sec_5.1.2"></a>
<h3><a href="sassy-Z-H-2.html#node_toc_node_sec_5.1.2">5.1.2&nbsp;&nbsp;Addressing</a></h3>
<p>
<a name="node_idx_92"></a></p>
<p>
Sassy currently only understands 32-bit addressing syntax, regardless of the current setting of the <code class=scheme><span class=keyword>bits</span></code> directive. In 16-bit mode, sassy emits an extra prefix byte (#x67) to signal to the processor that the following instruction is using 32-bit addressing syntax. </p>
<p>
Write effective addresses using the following form:</p>
<p>
</p>
<pre class=scheme>(<span class=builtin>&amp;</span> <span class=variable>&lt;items&gt;</span> ...)
</pre><p></p>
<p>
The &lt;items&gt; should be at least one, but not more than one of each, of the following in any order. The effective address is the implied sum of all the items.</p>
<p>
<a name="node_idx_94"></a>
<a name="node_idx_96"></a>
</p>
<ul>
<li><p>Any number of integers (displacements)
</p>
<li><p>Zero or one 32-bit general purpose registers (base)
</p>
<li><p>Zero or one labels or custom relocations (displacements)
</p>
<li><p>Zero or one indexes and scales, written as follows, where <code class=verbatim>&lt;scale&gt;</code> is <code class=verbatim>1</code>, <code class=verbatim>2</code>, <code class=verbatim>4</code>, <code class=verbatim>8</code>.
</p>
<pre class=scheme>(<span class=builtin>*</span> <span class=variable>&lt;32-bit-reg&gt;</span> <span class=variable>&lt;scale&gt;</span>)
(<span class=builtin>*</span> <span class=variable>&lt;scale&gt;</span> <span class=variable>&lt;32-bit-reg&gt;</span>)
</pre><p>
</p>
</ul><p></p>
<p>
Some examples:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>add</span> <span class=variable>ecx</span> (<span class=builtin>&amp;</span> <span class=variable>edx</span>))
(<span class=variable>mov</span> <span class=variable>edx</span> (<span class=builtin>&amp;</span> (<span class=builtin>*</span> <span class=selfeval>8</span> <span class=variable>ecx</span>)))
(<span class=variable>add</span> <span class=variable>eax</span> (<span class=builtin>&amp;</span> <span class=selfeval>#x64</span>))
(<span class=variable>mov</span> <span class=variable>eax</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span> (<span class=builtin>*</span> <span class=variable>ebx</span> <span class=selfeval>4</span>) <span class=variable>edx</span> <span class=selfeval>1000</span>))
(<span class=variable>add</span> <span class=variable>eax</span> (<span class=builtin>&amp;</span> <span class=selfeval>-1</span> <span class=selfeval>2</span> <span class=selfeval>-3</span> <span class=selfeval>4</span> <span class=variable>ebx</span> <span class=selfeval>-5</span> <span class=selfeval>6</span> <span class=selfeval>-7</span> <span class=selfeval>8</span>))
</pre><p></p>
<p>
Sassy understands these idioms as well:</p>
<p>
</p>
<pre class=scheme>(<span class=builtin>&amp;</span> <span class=variable>edx</span> <span class=variable>ebx</span>)   <span class=variable>=&gt;</span> (<span class=builtin>&amp;</span> <span class=variable>edx</span> (<span class=builtin>*</span> <span class=variable>ebx</span> <span class=selfeval>1</span>)) <span class=comment>; If two registers are supplied,</span>
                                   <span class=comment>; the second is assembled as an index with</span>
                                   <span class=comment>; a scale of 1</span>
(<span class=builtin>&amp;</span> (<span class=builtin>*</span> <span class=variable>eax</span> <span class=selfeval>2</span>)) <span class=variable>=&gt;</span> (<span class=builtin>&amp;</span> <span class=variable>eax</span> (<span class=builtin>*</span> <span class=variable>eax</span> <span class=selfeval>1</span>)) <span class=comment>; If only a scale and index are given,</span>
                                   <span class=comment>; it is assembled as a base+index*scale/2</span>
</pre><p></p>
<p>
<a name="node_idx_98"></a>
<a name="node_idx_100"></a>
<a name="node_idx_102"></a>
<a name="node_idx_104"></a>
<a name="node_idx_106"></a>
<a name="node_idx_108"></a>
<a name="node_idx_110"></a></p>
<p>
Finally, if you want to tell Sassy to emit a segment override prefix
for a particular memory operand, use one of the following syntaxes for
the addressing operand (If you are trying to generate branch taken/branch not taken prefixes, which are the same prefix byte as  <code class=verbatim>cs</code> and <code class=verbatim>ds</code>, please <a href="#node_tag_Temp_11">see below</a>):</p>
<p>
</p>
<pre class=scheme>(<span class=variable>cs</span> (<span class=builtin>&amp;</span> <span class=variable>edx</span>))
(<span class=variable>ds</span> (<span class=builtin>&amp;</span> (<span class=builtin>*</span> <span class=selfeval>8</span> <span class=variable>ecx</span>)))
(<span class=variable>ss</span> (<span class=builtin>&amp;</span> <span class=selfeval>#x64</span>))
(<span class=variable>es</span> (<span class=builtin>&amp;</span> <span class=variable>edx</span>))
(<span class=variable>fs</span> (<span class=builtin>&amp;</span> (<span class=builtin>*</span> <span class=selfeval>8</span> <span class=variable>ecx</span>)))
(<span class=variable>gs</span> (<span class=builtin>&amp;</span> <span class=selfeval>#x64</span>))
</pre><p></p>
<p>
<a name="node_idx_112"></a>
<a name="node_idx_114"></a>
<a name="node_idx_116"></a>
<a name="node_idx_118"></a>
<a name="node_idx_120"></a>
<a name="node_idx_122"></a>
Sassy also includes some macros that translate into the above:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>cs:</span> <span class=variable>edx</span>)       <span class=variable>=&gt;</span> (<span class=variable>cs</span> (<span class=builtin>&amp;</span> <span class=variable>edx</span>))
(<span class=variable>ds:</span> (<span class=builtin>*</span> <span class=selfeval>8</span> <span class=variable>ecs</span>)) <span class=variable>=&gt;</span> (<span class=variable>ds</span> (<span class=builtin>&amp;</span> (<span class=builtin>*</span> <span class=selfeval>8</span> <span class=variable>ecs</span>)))
(<span class=variable>ss:</span> <span class=selfeval>#x64</span>)      <span class=variable>=&gt;</span> (<span class=variable>ss</span> (<span class=builtin>&amp;</span> <span class=selfeval>#x64</span>))
(<span class=variable>es:</span> <span class=variable>edx</span>)       <span class=variable>=&gt;</span> (<span class=variable>es</span> (<span class=builtin>&amp;</span> <span class=variable>edx</span>))
(<span class=variable>fs:</span> (<span class=builtin>*</span> <span class=selfeval>8</span> <span class=variable>ecs</span>)) <span class=variable>=&gt;</span> (<span class=variable>fs</span> (<span class=builtin>&amp;</span> (<span class=builtin>*</span> <span class=selfeval>8</span> <span class=variable>ecs</span>)))
(<span class=variable>gs:</span> <span class=selfeval>#x64</span>)      <span class=variable>=&gt;</span> (<span class=variable>gs</span> (<span class=builtin>&amp;</span> <span class=selfeval>#x64</span>))
</pre><p></p>
<p>

</p>
<a name="node_sec_5.1.3"></a>
<h3><a href="sassy-Z-H-2.html#node_toc_node_sec_5.1.3">5.1.3&nbsp;&nbsp;Operand Sizes</a></h3>
<p>
<a name="node_idx_124"></a></p>
<p>
Because many of the x86's instructions are overloaded, meaning the same instruction can sometimes accept different operands of various sizes in various orders, and will output different opcode sequences, Sassy has to try and infer the operand size from the context in which the operand appears. Sassy uses the opcode of the instruction itself, the other operands in the instruction, and the current setting of the <code class=scheme><span class=keyword>bits</span></code> directive (the default is 32), to do so.</p>
<p>
If instead you would like to be explicit, you may use the supplied hinting mechansim to specify an operand size for immediates and memory addresses (registers always have an implied size):</p>
<p>
<a name="node_idx_126"></a>
<a name="node_idx_128"></a>
<a name="node_idx_130"></a>
<a name="node_idx_132"></a>
<a name="node_idx_134"></a>
<a name="node_idx_136"></a>
<a name="node_idx_138"></a>
</p>
<pre class=scheme>(<span class=keyword>byte</span>   <span class=variable>&lt;operand&gt;</span>) <span class=variable>=&gt;</span> <span class=variable>8-bit</span>
(<span class=keyword>word</span>   <span class=variable>&lt;operand&gt;</span>) <span class=variable>=&gt;</span> <span class=variable>16-bit</span>
(<span class=keyword>dword</span>  <span class=variable>&lt;operand&gt;</span>) <span class=variable>=&gt;</span> <span class=variable>32-bit</span>
(<span class=keyword>qword</span>  <span class=variable>&lt;operand&gt;</span>) <span class=variable>=&gt;</span> <span class=variable>64-bit</span>
(<span class=keyword>tword</span>  <span class=variable>&lt;operand&gt;</span>) <span class=variable>=&gt;</span> <span class=variable>80-bit</span>
(<span class=keyword>dqword</span> <span class=variable>&lt;operand&gt;</span>) <span class=variable>=&gt;</span> <span class=variable>128-bit</span>
</pre><p></p>
<p>
If you don't use the hinting mechanism, Sassy tries, with one exception (see below), to match an ambiguous operand size to the size of another operand in the instruction. Any hint you supply to one operand will be used to infer the size of the other:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>mov</span> <span class=variable>ebx</span> <span class=selfeval>4</span>)      <span class=variable>=&gt;</span> (<span class=variable>mov</span> <span class=variable>ebx</span> (<span class=keyword>dword</span> <span class=selfeval>4</span>))
(<span class=variable>mov</span> <span class=variable>cx</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>)) <span class=variable>=&gt;</span> (<span class=variable>mov</span> <span class=variable>cx</span> (<span class=keyword>word</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>)))
(<span class=variable>mov</span> <span class=variable>al</span> <span class=selfeval>100</span>)     <span class=variable>=&gt;</span> (<span class=variable>mov</span> <span class=variable>al</span> (<span class=keyword>byte</span> <span class=selfeval>100</span>))
(<span class=variable>mov</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>) (<span class=keyword>byte</span> <span class=selfeval>100</span>)) <span class=variable>=&gt;</span> (<span class=variable>mov</span> (<span class=keyword>byte</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>)) (<span class=keyword>byte</span> <span class=selfeval>100</span>))
</pre><p></p>
<p>
If that's not possible, Sassy examines the current <code class=scheme><span class=keyword>bits</span></code> setting and uses that size for the operands:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>bits</span> <span class=selfeval>32</span>)
(<span class=variable>mov</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>) <span class=selfeval>10</span>) <span class=variable>=&gt;</span> (<span class=variable>mov</span> (<span class=keyword>dword</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>)) (<span class=keyword>dword</span> <span class=selfeval>10</span>))

(<span class=keyword>bits</span> <span class=selfeval>16</span>)
(<span class=variable>mov</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>) <span class=selfeval>10</span>) <span class=variable>=&gt;</span> (<span class=variable>mov</span> (<span class=keyword>word</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>)) (<span class=keyword>word</span> <span class=selfeval>10</span>))
</pre><p></p>
<p>
The exception to the above is the case where certain instructions can generate shorter opcode sequences when their source operand is an immediate and a byte, instead of a word or dword. In those cases, Sassy uses the shorter form when the source operand is in fact a byte. This applies to the following instructions: <code class=verbatim>adc add and cmp or sbb sub xor push imul</code>.</p>
<p>
For example:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>add</span> <span class=variable>ecx</span> <span class=selfeval>4</span>)         <span class=variable>=&gt;</span> <span class=variable>Sassy</span> <span class=variable>assumes</span> <span class=variable>the</span> <span class=variable>default</span> <span class=variable>of</span> (<span class=variable>add</span> <span class=variable>ecx</span> (<span class=keyword>byte</span> <span class=selfeval>4</span>))
(<span class=variable>add</span> <span class=variable>ecx</span> (<span class=keyword>dword</span> <span class=selfeval>4</span>)) <span class=variable>=&gt;</span> <span class=variable>Sassy</span> <span class=variable>uses</span> <span class=variable>the</span> <span class=variable>long</span> <span class=variable>form</span>
</pre><p></p>
<p>
Finally, for any floating-point, mmx, or sse instruction that can accept memory operands of different sizes, the default is always a dword-sized operand. In these cases, other operand sizes of memory addresses must be explicitly specified:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>fst</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>))         <span class=variable>=&gt;</span> <span class=variable>Sassy</span> <span class=variable>assumes</span> <span class=variable>the</span> <span class=variable>default</span> <span class=variable>of</span> (<span class=variable>fst</span> (<span class=keyword>dword</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>)))
(<span class=variable>fst</span> (<span class=keyword>qword</span> (<span class=builtin>&amp;</span> <span class=variable>foo</span>))) <span class=variable>=&gt;</span> <span class=variable>Explicit</span> <span class=keyword>qword</span> <span class=variable>memory</span> <span class=variable>operand</span>
</pre><p></p>
<p>
<a name="node_idx_140"></a>
<a name="node_idx_142"></a>

</p>
<a name="node_sec_5.1.4"></a>
<h3><a href="sassy-Z-H-2.html#node_toc_node_sec_5.1.4">5.1.4&nbsp;&nbsp;Jumps and Calls</a></h3>
<p>
<a name="node_idx_144"></a></p>
<p>
The normal syntax for writing direct branches or conditional branches is <code class=verbatim>(jmp foo)</code> or <code class=verbatim>(jnz bar)</code>. For these direct branches that you write, <code class=verbatim>sassy</code> assumes that they are near branches, and thus generates 2-byte or 4-byte relative address depending on the current setting of the <code class=scheme><span class=keyword>bits</span></code> directive. You always write the branch target you want (not the relative distance - <code class=verbatim>sassy</code> computes that).</p>
<p>
Some special forms exists for designating explicit short, near, and far versions of <code class=verbatim>jmp</code>, <code class=verbatim>call</code>, and the <code class=verbatim>jcc</code>-family of instructions. For branches that you write (not Sassy's internally generated branches  --  see below), if you write a ``short'' branch, <code class=verbatim>sassy</code> assembles a short branch provided the branch target is within range. Otherwise an ``out of range'' error will be signalled. </p>
<p>
<a name="node_idx_146"></a>
<a name="node_idx_148"></a>
</p>
<pre class=scheme>(<span class=variable>jnz</span> <span class=variable>short</span> <span class=variable>foo</span>)
(<span class=variable>jnz</span> <span class=variable>near</span>  <span class=variable>foo</span>)

(<span class=variable>jmp</span> <span class=variable>short</span> <span class=variable>foo</span>)
(<span class=variable>jmp</span> <span class=variable>near</span>  <span class=variable>foo</span>)
</pre><p></p>
<p>
<a name="node_idx_150"></a>
<a name="node_idx_152"></a>
<a name="node_idx_154"></a></p>
<p>
For far jumps and calls to other segments, if you want to write a direct call, you specify a far pointer with two operands:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>jmp</span>  <span class=variable>&lt;imm16&gt;</span>  <span class=variable>&lt;imm32&gt;</span>) <span class=comment>; jmp #x1234:12345678</span>
(<span class=variable>jmp</span>  <span class=variable>&lt;imm16&gt;</span>  <span class=variable>&lt;imm16&gt;</span>) <span class=comment>; jmp #x1234:1234</span>
(<span class=variable>call</span> <span class=variable>&lt;imm16&gt;</span>  <span class=variable>&lt;imm32&gt;</span>) <span class=comment>; call #x1234:12345678</span>
(<span class=variable>call</span> <span class=variable>&lt;imm16&gt;</span>  <span class=variable>&lt;imm16&gt;</span>) <span class=comment>; call #x1234:1234</span>
</pre><p></p>
<p>
The first operand specifies the segment, and the second the offset into that segment. For either operand, you can specify an operand size of <code class=scheme><span class=keyword>word</span></code> or <code class=scheme><span class=keyword>dword</span></code>, to be explicit.</p>
<p>
To write an indirect far call, where the segment and offset are specified at a memory address, you use the keyword <code class=verbatim>far</code> in the instruction:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>jmp</span> <span class=variable>far</span> <span class=variable>&lt;mem32&gt;</span>)
(<span class=variable>jmp</span> <span class=variable>far</span> (<span class=keyword>word</span> <span class=variable>&lt;mem32</span>))
(<span class=variable>call</span> <span class=variable>far</span> <span class=variable>&lt;mem32&gt;</span>)
(<span class=variable>call</span> <span class=variable>far</span> (<span class=keyword>word</span> <span class=variable>&lt;mem32</span>))
</pre><p></p>
<p>
<a name="node_tag_Temp_11"></a>

</p>
<a name="node_sec_5.1.5"></a>
<h3><a href="sassy-Z-H-2.html#node_toc_node_sec_5.1.5">5.1.5&nbsp;&nbsp;Prefixes</a></h3>
<p>
<a name="node_idx_156"></a></p>
<p>
Sassy knows the prefixes <code class=verbatim>lock</code>, <code class=verbatim>rep</code>, <code class=verbatim>repe</code>, <code class=verbatim>repne</code>, <code class=verbatim>repz</code>, and <code class=verbatim>repnz</code>. Write them in the following manner:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>&lt;prefix&gt;</span> <span class=variable>&lt;instruction&gt;</span>)
<span class=variable>e.g.</span>
(<span class=variable>lock</span> (<span class=variable>inc</span> (<span class=builtin>&amp;</span> <span class=variable>my-guard</span>)))
</pre><p></p>
<p>
<a name="node_idx_158"></a>
<a name="node_idx_160"></a>
Sassy also knows about the branch hint prefixes used to control the processor's default branch-prediction behavior. Sassy uses <code class=verbatim>brt</code> to generate a ``branch taken'' prefix, and <code class=verbatim>brnt</code> to generate a ``branch not taken'' prefix. Use these prefixes with a <code class=verbatim>jcc</code> instruction, as above:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>brt</span>  (<span class=variable>jnz</span> <span class=variable>foo</span>))
(<span class=variable>brnt</span> (<span class=variable>jz</span> <span class=variable>foo</span>))
</pre><p></p>
<p>

</p>
<a name="node_sec_5.2"></a>
<h2><a href="sassy-Z-H-2.html#node_toc_node_sec_5.2">5.2&nbsp;&nbsp;Assertions</a></h2>
<p>
<a name="node_idx_162"></a></p>
<p>
You can control the flow of computation by using ``assertions'' and
``control primitives''.</p>
<p>
Assertions check whether or not particular flags are set in x86's ``eflags'' register, and alter the flow of computation accordingly by inserting conditional and unconditional branches. Exactly how the flow of computation is altered depends on their contextual use within a particular control primitive.</p>
<p>
You write the assertions by writing the cc-code for the jcc-family of instructions followed by an exclamation point.</p>
<p>
</p>
<pre class=scheme><span class=builtin>o!</span>               <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>overflow</span>
<span class=builtin>no!</span>              <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>not</span> <span class=variable>overflow</span>
<span class=builtin>b!</span>  <span class=variable>/</span> <span class=builtin>c!</span>  <span class=variable>/</span> <span class=builtin>nae!</span> <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>carry</span>
<span class=builtin>ae!</span> <span class=variable>/</span> <span class=builtin>nb!</span> <span class=variable>/</span> <span class=builtin>nc!</span>  <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>not</span> <span class=variable>carry</span>
<span class=builtin>e!</span>  <span class=variable>/</span> <span class=builtin>z!</span>         <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>zero</span>
<span class=builtin>ne!</span> <span class=variable>/</span> <span class=builtin>nz!</span>        <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>not</span> <span class=variable>zero</span>
<span class=builtin>be!</span> <span class=variable>/</span> <span class=builtin>na!</span>        <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>either</span> <span class=variable>carry</span> <span class=variable>or</span> <span class=variable>zero</span>
<span class=builtin>a!</span>  <span class=variable>/</span> <span class=builtin>nbe!</span>       <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>neither</span> <span class=variable>carry</span> <span class=variable>or</span> <span class=variable>zero</span>
<span class=builtin>s!</span>               <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>sign</span>
<span class=builtin>ns!</span>              <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>not</span> <span class=variable>sign</span>
<span class=builtin>p!</span>  <span class=variable>/</span> <span class=builtin>pe!</span>        <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>parity</span>
<span class=builtin>np!</span> <span class=variable>/</span> <span class=builtin>po!</span>        <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>not</span> <span class=variable>parity</span>
<span class=builtin>l!</span>  <span class=variable>/</span> <span class=builtin>nge!</span>       <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>less</span> <span class=variable>than</span>
<span class=builtin>ge!</span> <span class=variable>/</span> <span class=builtin>nl!</span>        <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>greater</span> <span class=variable>than</span> <span class=variable>or</span> <span class=variable>equal</span> <span class=variable>to</span>
<span class=builtin>le!</span> <span class=variable>/</span> <span class=builtin>ng!</span>        <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>less</span> <span class=variable>than</span> <span class=variable>or</span> <span class=variable>equal</span> <span class=variable>to</span>
<span class=builtin>g!</span>  <span class=variable>/</span> <span class=builtin>nle!</span>       <span class=variable>=&gt;</span> <span class=variable>assert</span> <span class=variable>greater</span> <span class=variable>than</span>
</pre><p></p>
<p>
Since assertions may succeed or fail, there are always two possible paths to take, called the ``win'' and ``lose'' continuations. In addition, control primitives themselves may also ``win'' or ``lose'' depending upon whether they succeed or fail, but instructions always succeed or ``win''. By saying ``something wins'' I mean that the computation immediately proceeds with the ``win'' continuation, possibly via a branch, and when ``something loses'', computation immediately proceeds with the ``lose'' continuation, also possibly by branching.</p>
<p>

</p>
<a name="node_sec_5.3"></a>
<h2><a href="sassy-Z-H-2.html#node_toc_node_sec_5.3">5.3&nbsp;&nbsp;Control Primitives</a></h2>
<p>
<a name="node_idx_164"></a></p>
<p>
In the following, <i>item</i> and refers to a <code class=verbatim>&lt;text-item&gt;</code>. For illustrative examples (and the code they compile down to), please have a look at the Scheme files in the <code class=verbatim>tests/prims</code> directory in Sassy's distribution directory.</p>
<p>

</p>
<a name="node_sec_5.3.1"></a>
<h3><a href="sassy-Z-H-2.html#node_toc_node_sec_5.3.1">5.3.1&nbsp;&nbsp;The COMFY core</a></h3>
<p>
<a name="node_idx_166"></a></p>
<p>
The following implement <a href="http://home.pipeline.com/~hbaker1/sigplannotices/column04.tex.gz">Baker's semantics</a>:</p>
<p>
<a name="node_idx_168"></a>
<code class=scheme>(<span class=builtin>seq</span> <span class=variable>item</span> ...)</code> tries to execute each <i>item</i> in order. As soon as any of them fail, then the whole <code class=scheme><span class=builtin>seq</span></code> immediately loses. If they all succeed, then the <code class=scheme><span class=builtin>seq</span></code> wins.</p>
<p>
<a name="node_idx_170"></a>
<code class=scheme>(<span class=builtin>inv</span> <span class=variable>item</span>)</code> is equivalent to Baker's ``not''. This exchanges the win and lose continuations of the <i>item</i>. That is, if it would normally win, it loses, and vice-versa.</p>
<p>
<a name="node_idx_172"></a>
<code class=scheme>(<span class=builtin>if</span> <span class=variable>test</span> <span class=variable>conseq</span> <span class=variable>altern</span>)</code> Each of the arguments to <code class=scheme><span class=builtin>if</span></code> is a <code class=verbatim>&lt;text-item&gt;</code>. This form executes <i>test</i> with a win of <i>conseq</i> and a lose of <i>altern</i>. The whole <code class=scheme><span class=builtin>if</span></code> <strong>always wins</strong>.</p>
<p>
<a name="node_idx_174"></a>
<code class=scheme>(<span class=builtin>alt</span> <span class=variable>item</span> ...)</code> tries to execute each <i>item</i> in order. As soon as one of them succeeds, the whole <code class=scheme><span class=builtin>alt</span></code> wins. If an item fails, the next <i>item</i> is tried.</p>
<p>
<a name="node_idx_176"></a>
<code class=scheme>(<span class=builtin>times</span> <span class=variable>amount</span> <span class=variable>item</span>)</code> ``unrolls loops''. That is, the <i>item</i> will be executed (and compiled) a number of times equal to <i>amount</i>. The copies are wrapped in a <code class=scheme><span class=keyword>begin</span></code>.</p>
<p>
<a name="node_idx_178"></a>
<code class=scheme>(<span class=builtin>iter</span> <span class=variable>item</span>)</code> is equivalent to Baker's ``loop''. The <i>item</i> is executed <i>ad infinitum</i>, meaning <code class=scheme><span class=builtin>iter</span></code> <strong>can never win</strong>. However, if the <i>item</i> fails then the whole <code class=scheme><span class=builtin>iter</span></code> loses.</p>
<p>
<a name="node_idx_180"></a>
<code class=scheme>(<span class=builtin>while</span> <span class=variable>test</span> <span class=variable>body</span>)</code> is another looping construct. Each time through the loop, <i>test</i> is tried. If it succeeds, the <i>body</i> is executed. If it fails, then the whole <code class=scheme><span class=builtin>while</span></code> wins. On the other hand, if the <i>body</i> fails, then the whole <code class=scheme><span class=builtin>while</span></code> loses.</p>
<p>

</p>
<a name="node_sec_5.3.2"></a>
<h3><a href="sassy-Z-H-2.html#node_toc_node_sec_5.3.2">5.3.2&nbsp;&nbsp;Sassy Extensions</a></h3>
<p>
<a name="node_idx_182"></a></p>
<p>
<a name="node_tag_Temp_12"></a></p>
<p>
<a name="node_idx_184"></a>
<code class=scheme>(<span class=keyword>begin</span> <span class=variable>item</span> ... <span class=variable>tail</span>)</code> executes each <i>item</i> with both a win and lose continuation of <strong>the next <i>item</i></strong>. The exception is the <i>tail</i>, which is executed with the win and lose continuations of the whole <code class=scheme><span class=keyword>begin</span></code>. So if <i>tail</i> succeeds, the <code class=scheme><span class=keyword>begin</span></code> wins. Otherwise it loses. </p>
<p>
At the top level of <code class=scheme><span class=keyword>text</span></code> directive, (and indeed, in between <code class=scheme><span class=keyword>text</span></code> directives) <code class=verbatim>sassy</code> implicitly wraps all of the <code class=verbatim>&lt;text-items&gt;</code> in a <code class=scheme><span class=keyword>begin</span></code>. As well, following a <code class=verbatim>&lt;label&gt;</code> declaration, all of the <code class=verbatim>&lt;text-items&gt;</code> at the label's top level are explicitly wrapped in a <code class=scheme><span class=keyword>begin</span></code>.</p>
<p>
<a name="node_idx_186"></a>
<code class=scheme>(<span class=builtin>until</span> <span class=variable>test</span> <span class=variable>body</span>)</code> is like <code class=scheme><span class=builtin>while</span></code>, except that the <i>test</i> is subjected to a <code class=scheme><span class=builtin>inv</span></code>. So each time through the loop, if <i>test</i> fails, the <i>body</i> is executed, but if it succeeds, then the whole <code class=scheme><span class=builtin>until</span></code> wins. Like <code class=scheme><span class=builtin>while</span></code>, if the <i>body</i> fails, the whole <code class=scheme><span class=builtin>until</span></code> loses.</p>
<p>
The following are provided to provide some means of ``capturing'' and over-riding the continuations.</p>
<p>
</p>
<hr>
<p><a name="node_idx_188"></a>
<a name="node_idx_190"></a>
<a name="node_idx_192"></a>
</p>
<pre class=scheme>(<span class=builtin>with-win</span> <span class=variable>k-win</span> [<span class=variable>item</span>])
(<span class=builtin>with-lose</span> <span class=variable>k-lose</span> [<span class=variable>item</span>])
(<span class=builtin>with-win-lose</span> <span class=variable>k-win</span> <span class=variable>k-lose</span> [<span class=variable>item</span>])
</pre><p></p>
<p>
(The square brackets around <i>item</i> are meant to indicate that it is optional. See below)</p>
<p>
Each of these compiles <i>item</i> with an explicit win or lose continuation (or both) of <i>k-win</i> or <i>k-lose</i>, effectively overriding the particular default or implicit continuation Sassy would normally supply to the <i>item</i>. The continuation may be a <code class=scheme><span class=variable>text-item</span></code> or one of the specials symbols <code class=scheme><span class=keyword>$win</span></code> or <code class=scheme><span class=keyword>$lose</span></code>. Thus it is possible to express the semantics of many of Sassy's primitives in an explicit continuation-passing style. Examples of this are <a href="sassy-Z-H-11.html#node_tag_Temp_19">here</a>.</p>
<p>
</p>
<pre class=scheme>(<span class=builtin>with-win</span> <span class=variable>bar</span>
 (<span class=builtin>if</span> (<span class=builtin>seq</span> (<span class=variable>cmp</span> <span class=variable>eax</span> <span class=selfeval>3</span>)
          <span class=builtin>e!</span>)
     (<span class=variable>push</span> <span class=variable>eax</span>)   <span class=comment>; after the push jmp to bar</span>
     (<span class=variable>push</span> <span class=variable>ebx</span>))) <span class=comment>; after the push jmp to bar</span>
</pre><p></p>
<p>
</p>
<pre class=scheme>(<span class=builtin>with-win-lose</span> (<span class=variable>jmp</span> <span class=selfeval>1000</span>) (<span class=variable>call</span> <span class=variable>foo</span>)
  (<span class=builtin>seq</span>
   (<span class=variable>push</span> <span class=variable>eax</span>)
   (<span class=variable>=</span> <span class=variable>ecx</span> <span class=selfeval>4</span>))) <span class=comment>; if eax is 4, then (jmp 1000), else (call foo)</span>
</pre><p></p>
<p>
</p>
<pre class=scheme>(<span class=keyword>label</span> <span class=variable>and-some-blocks</span>
  (<span class=builtin>with-win</span> (<span class=keyword>begin</span> (<span class=variable>push</span> <span class=variable>eax</span>)
                   (<span class=variable>push</span> <span class=variable>ebx</span>))
    (<span class=builtin>with-win</span> (<span class=variable>zero?</span> <span class=variable>ebx</span>)
      (<span class=variable>zero?</span> <span class=variable>eax</span>))))

<span class=variable>==</span>

(<span class=keyword>label</span> <span class=variable>and-some-blocks</span>
  (<span class=builtin>seq</span> (<span class=variable>zero?</span> <span class=variable>eax</span>)
       (<span class=variable>zero?</span> <span class=variable>ebx</span>)
       (<span class=keyword>begin</span> (<span class=variable>push</span> <span class=variable>eax</span>)
              (<span class=variable>push</span> <span class=variable>ebx</span>))))
</pre><p></p>
<p>
<code class=verbatim>sassy</code> places the win or lose continuations after the items. If you use <code class=scheme><span class=builtin>with-win-lose</span></code>, the lose continuation occurs last, the win continuation second, and the item first.</p>
<p>
If an explicit continuation is either an unconditional branch <code class=scheme>(<span class=variable>jmp</span> ...)</code> or the instruction <code class=scheme>(<span class=variable>ret</span>)</code>, <code class=verbatim>sassy</code> does not emit an extra branch to the contextual continuation of the ``jmp'' or ``ret'', since these imply that the actual continuation of the thread of computation is the target of these branches.</p>
<p>
<a name="node_idx_194"></a>
<a name="node_idx_196"></a>
In addition, sometimes you may want <code class=verbatim>sassy</code> to emit a ``single instruction'' as a continuation, but nothing else. This might occur in the succeed or fail arm of an <code class=scheme><span class=builtin>if</span></code>, for instance. In this case you can write either <code class=scheme>(<span class=builtin>seq</span>)</code> or <code class=scheme>(<span class=keyword>begin</span>)</code> (an ``empty'' sequence or block) for the <i>item</i>. This triggers the continuation generators without emitting anything else into the instruction stream. (The empty sequence and block are actually valid syntax anywhere.) Or you may simply elide the item, and the compiler will insert the extra <code class=scheme>(<span class=builtin>seq</span>)</code> automatically.</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>text</span> (<span class=variable>mov</span> <span class=variable>eax</span> <span class=selfeval>10</span>)

      (<span class=keyword>label</span> <span class=variable>foo</span> 
        (<span class=builtin>if</span> (<span class=variable>=</span> <span class=variable>eax</span> <span class=selfeval>3</span>)
	    (<span class=builtin>with-win</span> (<span class=variable>ret</span>))          <span class=comment>; if eax is 3, just (ret)</span>
            (<span class=builtin>with-win</span> <span class=variable>foo</span>             <span class=comment>; otherwise loop to foo</span>
              (<span class=variable>sub</span> <span class=variable>eax</span> <span class=selfeval>1</span>)))))
</pre><p></p>
<p>
</p>
<hr>
<p><a name="node_idx_198"></a>
<a name="node_idx_200"></a></p>
<p>
<code class=scheme><span class=keyword>$win</span></code> and <code class=scheme><span class=keyword>$lose</span></code> are two special symbols that Sassy reserves for itself so that you may explicitly refer to the values (the addresses) of the current win and lose continuations. They always refer to the exact win or lose continuation in effect at the point of their usage, including explicit continuations given by <code class=scheme><span class=builtin>with-win</span></code> etc. (Sassy records relocations for every usage of these).</p>
<p>
</p>
<pre class=scheme>(<span class=builtin>seq</span> (<span class=variable>add</span> <span class=variable>eax</span> <span class=selfeval>1</span>)
     (<span class=variable>push</span> <span class=keyword>$win</span>)  <span class=comment>; pushes the address of (add ebx 2)</span>
     (<span class=variable>add</span> <span class=variable>ebx</span> <span class=selfeval>2</span>)
     (<span class=variable>push</span> <span class=keyword>$lose</span>) <span class=comment>; pushes the address of the</span>
                  <span class=comment>; lose continuation of the enclosing seq</span>
     (<span class=variable>add</span> <span class=variable>ecx</span> <span class=selfeval>3</span>))
</pre><p></p>
<p>
</p>
<hr>
<p><a name="node_idx_202"></a></p>
<p>
<code class=scheme><span class=keyword>$eip</span></code> is a special symbol that Sassy reserves for itself to allow you to refer to the address of the next instruction. It <strong>always</strong> refers to the next instruction.</p>
<p>
</p>
<hr>
<p><a name="node_idx_204"></a>
<code class=scheme>(<span class=builtin>esc</span> (<span class=variable>instruction</span> ...) <span class=variable>item</span>)</code> ``turns off'' Sassy's continuation tracking for a moment so that you may explicitly store the value of a continuation (which is just an address). Sassy compiles <i>item</i> in the normal way, but it places each <i>instruction</i> in order just before the <i>item</i>, and each <i>instruction</i> is compiled with the <i>item's</i> win and lose continuations. Thus, if any of the <i>instructions</i> utilize the special symbols <code class=scheme><span class=keyword>$win</span></code> and <code class=scheme><span class=keyword>$lose</span></code>, they will represent the win and lose addresses of the <i>item</i>. </p>
<p>
This is useful, for instance, in the following ``multiple-dispatch'' situation, where the calling convention consists of pushing the return address first, and the arguments second. Assume the functions ``foo'' and ``bar'' pop their arguments, do their thing, and end with a <code class=verbatim>(ret)</code> (or a pop and a branch).</p>
<p>
</p>
<pre class=scheme>(<span class=builtin>esc</span> ((<span class=variable>push</span> <span class=keyword>$win</span>))
     (<span class=builtin>if</span> (<span class=builtin>seq</span> (<span class=variable>cmp</span> <span class=variable>eax</span> <span class=selfeval>10</span>)
              <span class=builtin>z!</span>)
         (<span class=builtin>with-win</span> <span class=variable>foo</span> (<span class=variable>push</span> <span class=variable>ebx</span>))
         (<span class=builtin>with-win</span> <span class=variable>bar</span> (<span class=variable>push</span> <span class=variable>ecx</span>))))
</pre><p></p>
<p>
The functions ``foo'' and ``bar'' will both return to the win continuation of the <code class=scheme><span class=builtin>if</span></code>, rather than into an arm of the <code class=scheme><span class=builtin>if</span></code> itself, from which they would immediately branch out of (``branch tensioning'', in other words).</p>
<p>
</p>
<hr>
<p><a name="node_idx_206"></a>
<a name="node_idx_208"></a>
</p>
<pre class=scheme>(<span class=builtin>leap</span> <span class=variable>item-with-mark</span>)
(<span class=builtin>mark</span> <span class=variable>item</span>)
</pre><p></p>
<p>
These two forms work together to allow you to write a branch into the middle of an otherwise nested structure. At the desired entry point to the structure use <code class=scheme><span class=builtin>mark</span></code>, and wrap the whole thing in a <code class=scheme><span class=builtin>leap</span></code>. If <code class=scheme><span class=builtin>leap</span></code> can't find a <code class=scheme><span class=builtin>mark</span></code> it does nothing. This is useful, for instance, for entering a loop at an arbitrary point. </p>
<p>
</p>
<pre class=scheme>(<span class=builtin>leap</span> (<span class=builtin>iter</span> (<span class=builtin>seq</span> (<span class=variable>add</span> <span class=variable>esp</span> <span class=selfeval>8</span>)
                 (<span class=builtin>mark</span> (<span class=variable>pop</span> <span class=variable>ecx</span>))
                 (<span class=variable>=</span> <span class=variable>ecx</span> <span class=selfeval>3</span>))))
</pre><p></p>
<p>

</p>
<a name="node_sec_5.3.3"></a>
<h3><a href="sassy-Z-H-2.html#node_toc_node_sec_5.3.3">5.3.3&nbsp;&nbsp;A Note on Branch Optimization</a></h3>
<p>
<a name="node_idx_210"></a></p>
<p>
Sassy currently optimizes <strong>all</strong> of its internally generated branches for size, so whenever it can assemble the ``short'' form of an internally generated conditional or unconditonal branch, it does so (provided the branch is not to an explicit continuation that is a label), regardless of the branch's direction. This comes at a small cost, because this means <code class=verbatim>sassy</code> has to make at least two passes, and possibly several more, over its looping forms (<code class=scheme><span class=builtin>iter</span></code>, <code class=scheme><span class=builtin>while</span></code>, and <code class=scheme><span class=builtin>until</span></code>). Though this is the only time Sassy makes more than one pass, in the future, if this cost becomes unbearable, I may provide a compiler option for strict one-pass assembly of these forms, using <a href="http://home.pipeline.com/~hbaker1/Prag-Parse.html">Baker's techniques (see section D.4)</a>.</p>
<p>

</p>
<div align=right class=navigation><i>[Go to <span><a href="sassy.html">first</a>, <a href="sassy-Z-H-6.html">previous</a></span><span>, <a href="sassy-Z-H-8.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="sassy-Z-H-2.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="sassy-Z-H-15.html#node_index_start">index</a></span>]</i></div>
<p></p>
</div>
</body>
</html>
