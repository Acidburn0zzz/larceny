; -*- text -*-
; ./BUGS
; $Id: BUGS,v 1.6 1997/07/07 20:28:23 lth Exp lth $


			 KNOWN BUGS IN LARCENY
			 ---------------------

Bugs are listed in the order recorded.  Fixed bugs have been moved to
the file BUGS-FIXED.  An entry consists of an entry number, the version
of Larceny in which the bug was discovered, the date it was recorded, a
description of the problem, and any supporting documentation,
information, test cases, and so on.


003  (v0.26)

     Singlestepping does not seem to work any longer.

005  (v0.27e)

     While the system can now grow the heap to any size (by growing the
     descriptor tables), an attempt to start the system with more than 32MB
     or so of initial heap will result in a segmentation fault.

     The reason is that the size of the descriptor tables during startup
     is limited to 32 MB.  A larger size will result in an attempt to grow
     them, which results in a barrier function being called to install the
     new tables.  But at this point the barrier has not yet been initialized,
     so garbage is accessed.

010  (v0.28)

     Error in vector-ref

     Symptom:
	> (vector-ref (vector-ref (sys$get-resource-usage) 11) 3)
	#<WEIRD OBJECT>

     Another:
	> (vector-ref '#(1 2 3) 3)
	quote

     Most likely the 'blu' below should be 'bleu' (code from 
     Sparcasm/gen-prim.sch).

	(define (emit-vector-like-ref! as r fault tag)
	  (let ((r1 (force-hwreg! as r $r.argreg2)))
	    (if (not (unsafe-code))
		(begin
		  (emit! as `(,$i.andicc ,r1 3 ,$r.g0))
		  (emit! as `(,$i.bne.a ,fault))
		  (emit! as `(,$i.slot))
		  (emit! as `(,$i.ldi ,$r.result (- ,tag) ,$r.tmp2))
		  (emit! as `(,$i.srai ,$r.tmp2 8 ,$r.tmp2))
		  (emit! as `(,$i.subrcc ,$r.tmp2 ,r1 ,$r.g0))
		  (emit! as `(,$i.blu ,fault))))
	    (emit! as `(,$i.addi ,$r.result ,(- 4 tag) ,$r.tmp0))
	    (emit! as `(,$i.ldr ,$r.tmp0 ,r1 ,$r.result))))

     Note: fix this in the _new_ assembler.

011  (v0.28)

     Error reporting for vector-ref is broken:

	> (vector-ref '#(1 2 3) 4)
	Error: Exception-handler: confused about vector-ref: #(1 2 3) 2

     This is a known problem: the value '2' is not the right value;
     the generated code does not pass the right value to the fault handler.

     Note: fix this in the _new_ assembler.

012  (v0.28)  970507

     Remembered-set size information from the command line is disregarded
     when creating the remembered sets in the garbage collector.

     See file Rts/Sys/memmgr.c

013  (v0.28)  970507

     Error reporting for bytevector-like-ref is broken:

	(bytevector-like-ref "123" 4)
	Error: Exception-handler: confused about bytevector-like-ref: 123 2

     See bug 011 (same problem).

     Note: fix this in the _new_ assembler.

014  (v0.28)  970507

     Error reporting for bytevector-ref is broken:

	(bytevector-ref (make-bytevector 3) 4)
	Error: Exception-handler: confused about bytevector-ref: 
		#<BYTEVECTOR> 2

     See bugs 011/013.

     Note: fix this in the _new_ assembler.

015  (v0.28)  970507

     Error reporting for bytevector-set! is broken:

	(bytevector-set! (make-bytevector 3) 4 27)
	Error: bytevector-set!: 3 is not a valid index into bytevector

     Note: fix this in the _new_ assembler.

016  (v0.28)  970507

     Error reporting for vector-set! is broken:

	(vector-set! (vector 1 2 3) 4 0)
	Error: vector-set!: 3 is not a valid index into vector

     Note: fix this in the _new_ assembler.

018  (v0.28)  970507

     Expt only takes exact integer powers:

	(expt 2 1.5)
	Error: expt: don't yet know how to deal with21.5

019  (v0.28)  970507

     With the generational collector, it is only possible to allocate objects
     that fit in the youngest generation, and that generation is of a
     fixed size.  This should not be a problem with the stop-and-copy (heaps=1)
     or conservative collectors.

     This should be fixed by allowing objects to be allocated "on the side"
     of the youngest generation; the current barrier system should be able
     to deal with this.

021  (v0.28b) 970528

     Free list coalescing is not done properly in unix-alloc.c.  This is 
     a benign problem with the current GC structure, but should be fixed.
     - free list should be address ordered (for coalescing, and also so
       that we can return memory to the OS).
     - a new free block can merge two previously separated blocks so that
       all three blocks become one.

022  (v0.28d) 970625

     The following functions do not accept complex arguments:
	SQRT, SIN, COS, TAN, ASIN, ACOS, ATAN, LOG, EXP

     [970701: Actually, I've implemented LOG, EXP, SIN, COS, TAN, ASIN, ACOS, 
      and ATAN; SQRT remains.  Also, these must all be tested.  --lars ]

026  (v0.28d) 970701

     LOG does not accept negative arguments.

027  (v0.28c(?)) 970609

     Message-ID: <3399DA5B.CEE@ccs.neu.edu>
     Date: Sat, 07 Jun 1997 17:02:22 -0500
     From: William D Clinger <will@ccs.neu.edu>
     To: lth@ccs.neu.edu
     Subject: FYI: progress on the non-predictive collector
     
     [...]

     While tracking this down I encountered a repeatable segmentation
     fault, which occurs with the old version of cheney.c as well as
     the new version.  It can be replicated with:
     
     % cd /proj/will/Benchmarks
     % larc0 -np -steps 100
     > (load "temp.sch")
     > (foo 0)
     > (foo 0)
     > (foo 4)
     > (foo 4)
     > (display-memstats (memstats))
     > (define (gc)
         (collect 1 'collect)
         (collect 2 'collect)
         (collect 3 'collect)
         (display-memstats (memstats)))
     > (gc)
     > (foo 4)
     
     I will leave "larc0" and "temp.sch" alone until this bug is
     fixed.
     
     Will

     COMMENTS:

     That command line expands to 
        larceny -heaps 2 -size1 1024K -steps 100 -stepsize 256K -lomark2 1 \
		-himark2 100 -lomark3 1 -himark3 100 larceny.heap
     where larceny.heap is really /proj/will/Larceny0.28b/larceny.heap.

     This crash is not repeatable in 0.28d with the 0.28d heap image and 
     my own set of {dynamic.sch, dynamic.fasl} files.  Will has since
     recompiled dynamic.sch, so my files (April 30) are probably closer to
     the originals.

     It is also not repeatable in 0.28d with the 0.28b heap image and my
     own set of {dynamic.sch, dynamic.fasl} files.

     It is also not repeatable in 0.28c as built by Will on 6/11, with the
     0.28c heap image.

     TO DO:

     Need to check how this works in v0.28b (last full distribution).

029  (v0.28c) 970612

     Message-ID: <339EFE09.176@ccs.neu.edu>
     Date: Wed, 11 Jun 1997 14:36:11 -0500
     From: William D Clinger <will@ccs.neu.edu>
     To: lth@ccs.neu.edu
     Subject: a more significant segmentation fault
     
     Here's a more bothersome segmentation fault, which occurs following
     a non-predictive gc.  I've copied all of the files to *.bug.
     
     Will
     
     ----
     
     [Benchmarks]% !!
     larc2 -calibrate -steps 62 -himark3 100
     Calibration run using non-predictive collector
     Larceny v0.28c/precise (SunOS;split) (will/Wed Jun 11 13:36:01 EDT 1997)
     Non-predictive hi_mark=100, lo_mark=0, oflo_mark=80.
     GC type: sc/fixed+2*sc/variable+static
     
     Heap statistics:
     Generation 0
       Size of semispace 1: 262144 bytes
       Size of semispace 2: 262144 bytes
       Live data: 0 bytes
       Live stack: 0 bytes
     Generation 1
       Size of semispace 1: 524288 bytes
       Size of semispace 2: 0 bytes
       Live data: 0 bytes
     Generation 2
       Size of semispace 1: 16252928 bytes
       Size of semispace 2: 0 bytes
       Live data: 0 bytes
     Generation 3
       Size of semispace 1: 0 bytes
       Size of semispace 2: 0 bytes
       Live data: 0 bytes
     Generation 4
       Size of semispace 1: 825344 bytes
       Size of semispace 2: 0 bytes
       Live data: 825344 bytes
     
     > (load "temp.m.sch")
     > (promote-always)
     > (load "gcbench1.fasl")
     > (define vecs
         (measurements (lambda () #t) gc-benchmark 0))
     
     j=0
     GC in the non-predictive heap: k=62, j=0.
     Finished non-predictive GC; k=62, j=0.
     GC in the non-predictive heap: k=62, j=0.
     Finished non-predictive GC; k=62, j=0.
     The garbage collector should touch about 32 megabytes of heap storage.
     The use of more or less memory will skew the results.
     
     --------------------------------------------------------
     GCBench18
     Garbage Collector Test
      Stretching memory with a binary tree of depth 18
      Total memory available= ???????? bytes  Free memory= ???????? bytes
     
     --------------------------------------------------------
     GCBench: Main
      Creating a long-lived binary tree of depth 16
      Creating a long-lived array of 524284 inexact reals
     Non-predictive 'old' area overflowed by 494528 bytes.
     GC in the non-predictive heap: k=62, j=0.
     Finished non-predictive GC; k=62, j=0.
      Total memory available= ???????? bytes  Free memory= ???????? bytes
     Creating 33824 trees of depth 4
     
     --------------------------------------------------------
     GCBench: Top down construction
     Words allocated: 6291936
     Words reclaimed: 6255936
     Elapsed time...: 3094 ms (User: 3080 ms; System: 10 ms)
     Elapsed GC time: 700 ms (in 96 collections.)
     
     --------------------------------------------------------
     GCBench: Bottom up construction
     Words allocated: 6291936
     Words reclaimed: 6266580
     Elapsed time...: 2884 ms (User: 2530 ms; System: 30 ms)
     Elapsed GC time: 343 ms (in 96 collections.)
     Creating 8256 trees of depth 6
     
     --------------------------------------------------------
     GCBench: Top down construction
     Words allocated: 6291744
     Words reclaimed: 6239014
     Elapsed time...: 2754 ms (User: 2740 ms; System: 10 ms)
     Elapsed GC time: 331 ms (in 96 collections.)
     
     --------------------------------------------------------
     GCBench: Bottom up construction
     Words allocated: 6291744
     Words reclaimed: 6340534
     Elapsed time...: 2707 ms (User: 2600 ms; System: 10 ms)
     Elapsed GC time: 389 ms (in 96 collections.)
     Creating 2052 trees of depth 8
     
     --------------------------------------------------------
     GCBench: Top down construction
     Words allocated: 6292104
     Words reclaimed: 6213388
     Elapsed time...: 2828 ms (User: 2830 ms; System: 0 ms)
     Elapsed GC time: 398 ms (in 96 collections.)
     
     --------------------------------------------------------
     GCBench: Bottom up construction
     Words allocated: 6292104
     Words reclaimed: 6445302
     Elapsed time...: 2698 ms (User: 2690 ms; System: 10 ms)
     Elapsed GC time: 446 ms (in 97 collections.)
     Creating 512 trees of depth 10
     
     --------------------------------------------------------
     GCBench: Top down construction
     Words allocated: 6289056
     Words reclaimed: 6157312
     Elapsed time...: 3352 ms (User: 3090 ms; System: 0 ms)
     Elapsed GC time: 685 ms (in 96 collections.)
     
     --------------------------------------------------------
     GCBench: Bottom up construction
     Words allocated: 6289056
     Words reclaimed: 6410754
     Elapsed time...: 3062 ms (User: 3040 ms; System: 20 ms)
     Elapsed GC time: 799 ms (in 96 collections.)
     Creating 128 trees of depth 12
     
     --------------------------------------------------------
     GCBench: Top down construction
     Words allocated: 6291360
     Words reclaimed: 6163250
     Elapsed time...: 3939 ms (User: 3920 ms; System: 20 ms)
     Elapsed GC time: 1504 ms (in 96 collections.)
     
     --------------------------------------------------------
     GCBench: Bottom up construction
     Words allocated: 6291360
     Words reclaimed: 6347916
     Elapsed time...: 4533 ms (User: 4530 ms; System: 10 ms)
     Elapsed GC time: 2266 ms (in 96 collections.)
     Creating 32 trees of depth 14
     
     --------------------------------------------------------
     GCBench: Top down construction
     Words allocated: 6291936
     Words reclaimed: 4621340
     Elapsed time...: 6811 ms (User: 6450 ms; System: 10 ms)
     Elapsed GC time: 4284 ms (in 96 collections.)
     
     --------------------------------------------------------
     GCBench: Bottom up construction
     Non-predictive 'old' area overflowed by 476344 bytes.
     GC in the non-predictive heap: k=62, j=0.
     Finished non-predictive GC; k=62, j=0.
     Non-predictive 'old' area overflowed by 453784 bytes.
     GC in the non-predictive heap: k=62, j=0.
     Segmentation fault
     

     COMMENTS:
     The command line expands as
       larceny -heaps 3 -stats -annoy-user \
        -size1 256K -lomark1 0 -himark1 100 -oflomark1 25 \
        -size2 512K -lomark2 0 -himark1 100 -oflomark2 48 \
        -steps 62 -stepsize 256K -himark3 100 larceny.heap
     where all the files are in Bugs/029.
     [The third line has a bug -- should be himark2.]

     The segmentation fault happens in realloc(); here's the traceback:

Program received signal SIGSEGV, Segmentation fault.
0xef77dbbc in realloc ()
(gdb) where
#0  0xef77dbbc in realloc ()
#1  0x4f88 in must_realloc (ptr=0x252b8, bytes=320) at Sys/malloc.c:42
#2  0xd6f4 in extend_chunk_array (s=0x23880) at Sys/semispace.c:124
#3  0xd56c in ss_expand (s=0x23880, bytes_request=262144) at Sys/semispace.c:90
#4  0xf9c4 in expand_semispace (ss=0x23880, lim=0xefffed94, dest=0xefffed90, 
    bytes=262144) at Sys/cheney.c:878
#5  0xea00 in scan_oflo_normal (scanptr=0x52b0ac, scanlim=0x538000, 
    scan_chunk_idx=0, e=0x1e7d8, iflush=1) at Sys/cheney.c:707
#6  0xe86c in scan_oflo (scanptr=0x4f8000, scanlim=0x538000, scan_chunk_idx=0, 
    e=0x1e7d8, iflush=1, may_be_partial=0) at Sys/cheney.c:688
#7  0xdcb8 in oldspace_copy (gc=0x234a0, tospace=0x23880, tospace2=0x0, 
    effective_generation=0, may_be_partial=0, op=5472256) at Sys/cheney.c:585
#8  0xda6c in gclib_copy_younger_into (gc=0x234a0, tospace=0x23880)
    at Sys/cheney.c:471
#9  0x10228 in internal_collect (heap=0x238a8) at Sys/np-sc-heap.c:410
#10 0x1011c in internal_promote (heap=0x238a8, force_collection=0)
    at Sys/np-sc-heap.c:377
#11 0xfed4 in promote (heap=0x238a8) at Sys/np-sc-heap.c:272
#12 0x9b44 in promote_out_of (gc=0x234a0, generation=1) at Sys/memmgr.c:597
#13 0xbb0c in collect (heap=0x237b0) at Sys/old-heap.c:250
#14 0xba1c in promote (heap=0x237b0) at Sys/old-heap.c:202
#15 0x9b44 in promote_out_of (gc=0x234a0, generation=0) at Sys/memmgr.c:597
#16 0xb364 in collect (heap=0x23710, request_bytes=20) at Sys/young-heap.c:281
#17 0x9a7c in collect (gc=0x234a0, generation=0, type=GC_COLLECT, 
    request_bytes=20) at Sys/memmgr.c:535
#18 0x12ac8 in garbage_collect3 (gen=0, type=0, request_bytes=20)
    at Sys/gc.c:78
#19 0x2498 in C_garbage_collect (type=0, request_words=20) at Sys/cglue.c:22
#20 0x5704 in internal_callout_to_C ()
#21 0x1c4c4 in globals ()

     Error is not repeatable in working version of 0.28d. (Sigh.)

     Error is also not repeatable in v0.28b (as distributed).  Notably,
     promote-always was not supported in 0.28b, and heap contraction was
     still in place, so the memory behavior should be pretty different in
     0.28b vs. later versions.


NEXT ENTRY: 030

; eof
