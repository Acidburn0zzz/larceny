Copyright 1998 Lars T Hansen.                   -*- text -*-

$Id$


			 KNOWN BUGS IN LARCENY


These are bugs that are or may be visible to the Scheme programmer.
Outright compiler bugs are sometimes only known to Will.

Bugs are listed in the order recorded.  Fixed bugs have been moved to
the file BUGS-FIXED.  Each entry consists of an entry number, the
version of Larceny in which the bug was discovered, the date it was
recorded and who found it, a description of the problem, and any
supporting documentation, information, test cases, and so on.

Priority high: "Must be fixed ASAP"
Priority medium: "Should be fixed ASAP"
Priority low: "Fix whenever."


HIGH PRIORITY BUGS: 88, 111, 136.


005  (v0.27e)
     Priority: low.
     Category: RTS / correctness

     While the system can now grow the heap to any size (by growing the
     descriptor tables), an attempt to start the system with more than 32MB
     or so of initial heap will result in a segmentation fault.

     The reason is that the size of the descriptor tables during startup
     is limited to 32 MB.  A larger size will result in an attempt to grow
     them, which results in a barrier function being called to install the
     new tables.  But at this point the barrier has not yet been initialized,
     so garbage is accessed.

     This is generally no longer a problem, since heaps are allocated
     lazily.  It will become a problem when someone tries to load a heap
     image of about 32MB or more.

034  v0.28f (970723 / lth)
     Priority: very low.
     Category: SPARCASM / correctness

     The number of arguments in a procedure call expression is limited to 
     1023.  This is due to the way the argument count is set up during 
     INVOKE and the way it is compared during ARGS=, ARGS>=.

     Note that expressions like (apply + massively-long-list) still work,
     because + takes 0 or more arguments (so the comparison is with 0), and
     apply computes the correct length of the list.  It is only a syntactic
     call expression that is so limited.

     This is easy to fix, and the fix does not impact code that has no
     more than 1023 arguments in a call.

     The compiler does in fact emit an 'invoke n' instruction for even 
     large n, so this is a real bug.

036  v0.28f (970826 / lth -- old bug)
053  v0.32 (971107 / lth)
     Priority: low.
     Category: LIB / quality-of-implementation

     Reader bugs.

   * The reader accepts \ as an initial character in symbols, but not
     as a subsequent, and when it is an initial character, it is not
     an escape character.

     I think the right behavior for \ is to work as an escape character
     in symbols and be valid everywhere in a symbol; \c should then mean
     literally c everywhere (notably preserving case, but also allowing
     spaces, control characters, and non-standard characters).  In 
     particular, if a symbol starts with \c, then even if symbols may not
     usually start with c, the interpretation should be a symbol.

   * Another reader problem:

	(symbol->string '|#x) => ""
	(symbol->string '|#x|) => "|#x"

     On the whole, the dark corners of the input syntax are indeed dark.

042 v0.31 (971024 / lth)
    Priority: should not be fixed.
    Category: LIB / correctness

    > (+ 'a)
    a
    > (* 'a)
    a

    [Thanks to Galen, who did not report this but who told me of this
     bug in the free version of Allegro Common Lisp for Windows(!).]

056 v0.32 (980126 / lth); v0.40 (981217 / lth)
    Priority: low
    Category: BUILD / correctness

    The development environment (both Chez Scheme and Larceny hosts):

	; Just finished make-larceny-heap
	> (inline-barrier)

	*** Error encountered!
	Deleting target file: larceny.heap

	Error: variable inline-barrier is not bound.
	Type (debug) to enter the debugger.

    In this case, it should not delete the previous target!  This did not
    happen on a subsequent try.  

    Notes:
    Looks like an error handler is not being taken down.

    In fact, it only appears to happen after a ^C has interrupted 
    a previous command; could it be that the interrupt handler does not
    interact properly with the error system?

057 v0.32 (980403 / lth)
087 v0.39 (981216 / lth)
    Priority: low
    Category: LIB / correctness

    Memstats and the static area:

    * Memstats does not return information that distinguishes the static
      area, if present.  Instead it returns information about Generation #n.
      So the info is there, it's just not being distinguished.

    Display-memstats:

    * Does not distinguish the static area in its printout.

    * Displays information about the non-predictive remembered set even
      though it is not in use.

    (See also fixed bug 86, which solved part of the problem: gathering
     the statistics in the RTS.)

062 v0.33 (980430 / wdc)
    Priority: low
    Category: LIB / performance

    Floating point output is very, very slow.  The Dragon4 algorithm, which
    uses (slow) bignums, should be replaced by Dybvig's algorithm.

067 v0.34 (980603 / lth)
    Priority: low
    Category: LIB / correctness

    This is wrong:

	> (char-upcase #\ÿ)
	#\ß
	> (char-downcase #\ß)
	#\ÿ

    because these letters are not upper/lower case variants of each other. 
    This example presents a slight problem for existing character 
    processing code if an alphabetical is both upper and lower case,
    but character processing code is character set dependent anyway,
    so it must be fixed.

    [Must fix this both in the reader and in Lib/string.sch.]

069 v0.34 (980611 / lth)
    Priority: low
    Category: LIB / correctness

    Writer: this is weird but mostly benign because "read" discards the
    backslashes properly:

	> (write "a;b;c")
	"a\;b\;c"

    It's not benign when code parsing text created with write does not
    expect the backslashes; it should probably be fixed.  (On the other 
    hand it's no worse than quoting symbols with vertical bars.)

071 v0.34 (981016 / wdc)
    Priority: low
    Category: BUILD / quality-of-implementation

    DISASSEMBLE-FILE does not work on .fasl files.

    Notes:
    The problem here is that FASL files do not have sufficient info
    for disassembly -- the tags present in LOP files are missing.  This
    will be fixed when we go to a FASL format that allows separate 
    loading and linking, because that format will retain the tags.

072 v0.34 (981113 / lth)
    Priority: medium.
    Category: LIB, TWOBIT / user-friendliness

    The (break) procedure always invokes the RTS debugger.  It would be
    more useful if it would invoke the user-installable breakpoint handler,
    if that has been installed.  The current behavior should be renamed
    as 'debugvsm'.

    Chez Scheme uses a parameter 'break-handler'; we should too.

074 v0.36 (981207 / dougo)
    Priority: medium.
    Category: AUXLIB / correctness

    Records (defined with make-record-type et al in Experimental/record.sch)
    are no longer displayed with the record type printer; it just displays
    "#<STRUCTURE>".

    Notes:
    This is in the 0.36 "std.heap" with installed pretty printer.

    That's because the pretty printer (which is used for the repl printer) 
    does not use the structure printer to print structures.   Fixing this
    will probably require changing the semantics of the structure printer,
    which now has no notion of "layout".

077 v0.36 (981207 / lth)
    Priority: low.
    Category: LIB / correctness

    Jaffer's test suite:

	(#<PROCEDURE string->number> "3i")  ==> 0+3i
	 BUT EXPECTED #f
	(#<PROCEDURE string->number> "3I")  ==> 0+3i
	 BUT EXPECTED #f
	(#<PROCEDURE string->number> "33i")  ==> 0+33i
	 BUT EXPECTED #f
	(#<PROCEDURE string->number> "33I")  ==> 0+33i
	 BUT EXPECTED #f
	(#<PROCEDURE string->number> "3.3i")  ==> 0.0+3.3i
	 BUT EXPECTED #f
	(#<PROCEDURE string->number> "3.3I")  ==> 0.0+3.3i
	 BUT EXPECTED #f

    The problem is that the number syntax in the Report requires an 
    explicit sign if a complex has no real part.  (There are plenty of
    similar "bugs" in the number parser, see comments in the code.)

083 v0.38 (981215 / lth)
    Priority: medium.
    Category: TWOBIT / correctness

    Bugs w.r.t. R4RS, R5RS, or the IEEE standard:

    * some top-level names are reserved by the macro expander:
      lambda, define, quote, begin, if, set!

    * some top-level names are reserved by the quasiquote macro:
      lambda, define, quote, begin, if, set!

    See also 091.

084 v0.39 (981216 / lth)
    Priority: low
    Category: INTERPRETER / correctness

    Minor interpreter bug: it gives bad error messages when using
    primitive names in environments that don't have those primitives.

	> (eval '(let ((a 1)) (foo a)) (null-environment 4))
	Error: Reference to undefined global variable `foo'.
	> (eval '(let ((a 1)) (car a)) (null-environment 4))
	Error: Attempt to apply #!undefined, which is not a procedure.

    The problem is that the interpreter has a fixed notion about what
    constitutes a primitive.  Technically, there should be a primitive 
    table that is relative to the environment.

085 v0.39 (981216 / lth)
    Priority: medium
    Category: LIB, INTERPRETER, TWOBIT / correctness

    Environments should contain syntax environments, and both 
    compile-expression (Compiler/compile313.sch) and macro-expand 
    (Eval/macro-expand.sch) should allow any environment to be used.

    [In any case the current setup is not the right thing.]

088 v0.40 (981219 / lth)
    Priority: high.
    Category: LIB / performance

    When running with (integrate-usual-procedures #f), arithmetic is quite
    slow, because the definitions of '+' etc are coded in Scheme using
    rest args.  Much better would be if they were written in MAL in 
    the same way as read-char / write-char, special-casing 0, 1, 2, 3, and
    4 arguments, or, even better, using case-lambda.

    On vega:

	> (default-code)
	#t
	> (define (fib n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2)))))
	fib
	> (run-with-stats (lambda () (fib 30)))
	Words allocated: 10770618
	Words reclaimed: 10738790
	Elapsed time...: 5863 ms (User: 5840 ms; System: 0 ms)
	Elapsed GC time: 174 ms (in 41 collections.)
	832040

    In fact, the interpreter is only 50% slower:

	vega(197) % larceny -small
	Larceny v0.40 (precise:SunOS5:split) (lth 18-Dec-98 17:59:12)

	> (define (fib n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2)))))
	fib
	> (run-with-stats (lambda () (fib 30)))
	Words allocated: 10770624
	Words reclaimed: 10733898
	Elapsed time...: 8376 ms (User: 8200 ms; System: 20 ms)
	Elapsed GC time: 85 ms (in 41 collections.)
	832040

    This would be better:

	(define +
	  (case-lambda
	   (() 0)
	   ((x) x)
	   ((x y) (+ x y))
	   ((x y z) (+ (+ x y) z))
	   ((w x y z) (+ (+ (+ w x) y) z))
	   ((x . rest) (let loop ((x x) (rest rest))
	                 (if (null? rest)
	                     x
	                     (loop (+ x (car rest)) (cdr rest)))))))

    By hacking together MAL code that does the above for + and -,
    we find that:

	> (fib-benchmark)   ; That's fib(30)

	--------------------------------------------------------
	Standard fib
	Words allocated: 474
	Words reclaimed: 0
	Elapsed time...: 2533 ms (User: 2520 ms; System: 0 ms)
	Elapsed GC time: 0 ms (in 0 collections.)

    (`<' of 2 arguments does not cons anything, nor does it go out-of-line,
     because it takes 2 or more arguments and the no-extra-arguments case
     is in-lined and only stores () in a register.)

    That isn't as good as Chez Scheme -- 1660 ms -- but it's a lot 
    better than it was!  

    The time improves to 2300 ms with slightly smarter code, and to 2150 ms
    if we can avoid the stack frame creation, which may be possible
    with fundamental MAL support (so we don't have to free up a register
    temporarily).

    We can do better by improving the speed of global procedure calls: 
    using a function cell, caching global cells.   These in themselves do 
    not appear to be enough, though --  experiments with caching and 
    unsafe-code does not reduce the time much from the above (only by 
    about 100ms).  

    Fact: the following (illegal) code for + and - results in a run time
    of 2300 ms:

	(define + (lambda (a b . rest) (if (null? rest) (+ a b) ...)))
	(define - (lambda (a b . rest) (if (null? rest) (- a b) ...)))

    Possible MAL support: 

      (args-switch ((2 1002) (0 1000) (1 1001) (3 1003) (* 1004)))

    which says go to 1002 if 2 args, 1000 if 0, ..., and to 1004 if none of
    the above.  Does not destroy RESULT.  Ordering can be used as an 
    optimization hint but has no semantic meaning.  It would be reasonable 
    to limit the argument count in the non-* case to some fairly small number.

    [Numbers to be taken with a grain of salt.]

    A caching strategy for 'known' globals, like that used by the interpreter,
    helps.  Of course, it bloats the code somewhat, but it appears that the 
    code size increase is linear if one is careful about lifting common 
    expressions.  Chez Scheme gets good performance apparently w/o doing this,
    because code that uses 'plus' for '+' runs as fast as code that uses '+',
    at optimize-level 1.

089 v0.40 (981219 / lth)
    Priority: medium.
    Category: RTS / quality-of-implementation

    Should catch SIGSEGV, SIGBUS because broken unsafe code can otherwise 
    cause a core dump.

    Notes:
    This is partly implemented in Rts/Sys/signals.c but not complete; a 
    minor redesign of the exception handling system seems in order.

090 v0.40 (981219 / lth )
    Priority: medium.
    Category: TWOBIT / performance

    With (integrate-usual-primitives #f), calls to the primitives 
    .make-cell, .cell-ref, and .cell-set! are compiled as normal 
    procedure calls.  This runs correctly -- I've added the correct
    names to the environment -- but code that uses assignments takes
    a performance hit.

    The way to fix this may be to make (integrate-usual-primitives #f) not
    change the way the compiler operates but instead just reduce the
    primitive table to contain the name:* primitives.

091 v0.40 (981219 / lth )
    Priority: medium.
    Category: TWOBIT / correctness

    The macro expander generates calls to procedures (unspecified) and 
    (undefined).  With (integrate-usual-primitives #f), this is incorrect 
    -- either these should be the procedures (.unspecified) and (.undefined),
    in which case see Bug 090, or they should be the correct constants.

094 v0.41 (981221 / lth)
    Priority: medium.
    Category: TWOBIT / correctness

    Block compiler and primitive definitions interact poorly.  The following
    hangs:

       (define car (lambda (x) (car x)))

095 v1.0a1 (981221 / lth)
    Priority: low
    Category: BUILD / correctness

    `make realclean' removes files that were in the distribution archive.
    That's not a real problem, because the files it removes are only there
    to allow an executable to be built without a host system; once it's 
    built, Larceny can be used as a host system.  Still, this is somewhat
    counter-intuitive.

098 v1.0a1 (981221 / wdc)
    Priority: medium.
    Category: INTERPRETER / correctness

    Define-inline works in larceny.heap but not in r5rs.heap.

099 v1.0a1 (990104 / lth)
    Priority: medium.
    Category: INTERPRETER / correctness

    define-inline is available in scheme-report-environment and 
    null-environment but should not be:

	> (eval '(define-inline foo (syntax-rules () ((foo x) x))) 
                (scheme-report-environment 5))

100 v1.0a1 (990104 / lth)
    Priority: low.
    Category: TWOBIT / quality-of-implementation

    The routines m-warn and m-error used by the macro expander should
    signal their conditions using machinery that ensures that output 
    ports are still open (in the same way the REPL does this).  Perhaps
    this should wait until we have some exception machinery.

101 v1.0a1 (990104 / lth)
    Priority: low.
    Category: TWOBIT / quality-of-implementation

    From: will
    >A larger problem is that warnings and error messages ought to be
    >expressed in terms of the original source code, or as original as
    >macro-expanded source can be.  Thus the (.begin|18|21) form should
    >have been reported as (begin).  I doubt whether this will be fixed
    >anytime soon, though.

102 v1.0a1 (990104 / lth)
    Priority: low
    Category: LIB / quality-of-implementation

    Loader bug.

    The loader (really: the reader) produces a strange error when
    confronted with a file that is neither a Scheme source file nor a 
    FASL file, e.g. when given a heap image as in the popular error

	larceny sparc.heap

    (which tells larceny to load sparc.heap as a Scheme file).

    To fix this, the loader should set up an exception handler and
    catch (some) errors signalled by READ.

103 v1.0a1 (990104 / lth)
    Priority: medium.
    Category: TWOBIT / quality-of-implementation

    Macro expander bug.

    This should be easy to fix.  See also Bug 090, Bug 091.

	Date: Fri, 18 Dec 1998 17:48:22 -0500
	From: Lars Thomas Hansen <lth@ccs.neu.edu>

	[This is with up-to-date sources except sparc.imp.sch]

	As far as I'm concerned, this is a minor annoyance: it's not entirely
	reasonable for Twobit to warn me with (integrate-usual-procedures #f).
	I can imagine differing opinions on the matter.

	> (integrate-usual-procedures #f)
	#f
	> (define + (lambda (a b) (cons a b)))
	WARNING from macro expander:
	Redefining 
	+
	+
	> (+ 1 2)
	(1 . 2)

106 v1.0a1 (990108 / lth)
    Priority: medium.
    Category: LIB / quality-of-implementation

    This is silly:

	> (procedure-name max)
	.max|3

    I don't know whether the compiler or the assembler should be responsible
    for cleaning this up; either way, the name needs to be demangled.

108 v1.0a1 (990208 / lth)
    Priority: medium.
    Category: RTS / correctness

    Very large fixnums that result in address wrap-around make some 
    allocation primitives crash the system:

	> (make-vector (- (expt 2 29) 4))

	Process scheme segmentation violation (core dumped)

	> (make-bytevector (- (expt 2 29) 4))

	Process scheme segmentation violation (core dumped)

111 v1.0a1 (990317 / lth)
    Priority: high
    Category: TWOBIT / correctness

    [This may have been fixed when bug 109 was fixed, but I haven't
    yet checked. - wdc]

    Message-Id: <199903171640.LAA27566@vega.ccs.neu.edu>
    To: will@ccs.neu.edu
    Subject: Re: Twobit bug 
    Date: Wed, 17 Mar 1999 11:40:46 -0500
    From: Lars Thomas Hansen <lth@ccs.neu.edu>

    I also found another bug just now -- another coredump.  I haven't
    investigated it because I have other things to do and I managed to work
    around it, but I saved the pertinent data and information.  Again it
    appears to be related to a (large) nest of internal definitions.  
    The tar file with the information is
    /home/lth/net/larceny/compiler-bug-990317.tar, in case you're
    interested.  (It could be an assembler error as well as a compiler
    error.)

112 v0.34 (981016 / wdc)
    Priority: medium
    Category: TWOBIT / quality-of-implementation

    Space leaks can result from stale registers and stack slots.

113 v0.34 (981016 / wdc)
    Priority: medium
    Category: TWOBIT / quality-of-implementation

    Space leaks can result from dead variables in registers or in
    the stack.

114 v0.34 (981016 / wdc)
    Priority: low
    Category: TWOBIT / quality-of-implementation

    Space leaks can result from dead variables in closures.

125 v1.0a1 (990429 / lth)
    Priority: low
    Category: FFI / correctness

    Sometimes Larceny dumps core on exit after the FFI has been used to
    load a file and link to functions in it repeatedly (as when errors
    have occurred).  Here's a backtrace:

	(gdb) where
	#0  0xef660cac in __do_global_dtors_aux ()
	#1  0xef660c84 in _fini ()
	#2  0xef7ca07c in ?? ()
	#3  0xef698d28 in _exithandle ()
	#4  0xef7080ac in exit ()
	#5  0x1a400 in UNIX_exit (code=0) at Sys/unix.c:279
	#6  0x19f7c in larceny_syscall (nargs=1, nproc=7, args=0x3d2a4)
	    at Sys/syscall.c:80
	#7  0x1b150 in C_syscall () at Sparc/cglue.c:201
	#8  0x1b380 in callout_to_C ()
	#9  0x3d298 in globals ()
	#10 0x15768 in main (argc=2, argv=0xeffff104) at Sys/larceny.c:159

    This could have happened because the shared library was recompiled
    and the operating system pages in the library directly from the
    file.

126 v0.43 (990629 / lth)
    Priority: medium
    Category: LIB / correctness

    The enable-interrupts primitive does double duty: it enables 
    interrupts, and it sets the timer value.  At the time I thought 
    this was very clever...  However, we get into problems in 
    call-without-interrupts:

	(define (call-without-interrupts thunk)
	  (let ((old #f))
	    (dynamic-wind 
	     (lambda () (set! old (disable-interrupts)))
	     thunk
	     (lambda () (if old (enable-interrupts old))))))
    
    As you can see, any time spent in the critical region is not deducted
    from the budget of the thread.  This seems fairly innocent.  However,
    consider this straightforward implementation:

	(define (block t)
	  (if (not *tasking-on*) (error "Tasking is not on."))
	  (if (not (task? t)) (error "BLOCK: " t " is not a task."))
	  (let ((critical? (tasks/in-critical-section?)))
	    (call-without-interrupts
	      (lambda ()
	        (cond ((tasks/runnable? t)
		       (run-queue.remove! *run-queue* t))
	              ((eq? t (tasks/current-task))
	               (tasks/switch #f critical?)))))))

    The task will be blocked, but when it is restarted by the scheduler
    with the full quantum, the call to call-without-interrupts will
    re-enable interrupts with the saved value (which can be anything).

    It's possible to code around that problem, but we shouldn't have to.
    So enable-interrupts should be split into two primitives:
    enable-interrupts, which takes no arguments, and timer-set!, which
    takes a new timer value.  disable-interrupts should return a boolean,
    and not #f or the current timer value.  If it turns out that we
    need to be able to read the timer, we can introduce a timer-get
    procedure later.

128 v0.43 (990701 / lth)
    Priority: medium
    Category: RTS / correctness

    When we use the conservative collector with ALL_INTERIOR_POINTERS=0,
    then some tricky code in the RTS that allocates a single chunk of 
    memory and splits it into multiple objects won't work.  The places
    where this occurs are _at_least_ the following (I have not scanned
    the sources completely):

       Rts/Sys/stats.c, for memstats structure    [ this has been fixed ]
       Rts/Sparc/cglue.c, for rest args           [ this has been fixed ]
       Rts/Sys/argv.c, for arg vector and strings
       Rts/Standard-C/millicode.c, for rest args 
       Rts/Sys/ffi.c, for args to Scheme callbacks

    Impact: current fixes are enough to allow benchmarking, but the
    others must be fixed.

129 v0.43 (990709 / lth)
    Priority: low
    Category: TWOBIT / correctness

    The macro expander incorrectly gives a warning about empty top-level 
    BEGIN forms:

	> (begin)
	WARNING from macro expander:
	Non-standard begin expression
	(begin)


130 v0.43 (990715 / lth)
    Priority: medium
    Category: TWOBIT / correctness

    Twobit is confused by the following program, which uses a trick to ensure
    that knowledge of the default fill is only encoded in the compiler.  I use
    a similar trick for make-vector; it signals an error for that too.


    > (compile '(define make-string
	          (lambda (x . rest)
		    (if (null? rest)
	  	        (make-string x)
		        (make-string x (car rest))))))
    WARNING from macro expander:
    Redefining 
    make-string
    Error: Wrong number of arguments to integrable procedure(make-string .x|1)

132 v0.43 (990715 / lth)
    Priority: medium
    Category: RTS / space usage

    It would appear, according to output from -annoy-user, that the space
    assigned to remembered sets grows monotonically, which is not what
    we would like -- space should be returned to the common pool
    whereever possible.  Most reasonably, pool memory should be freed
    when a remset is cleared.

133 v0.43 (990903 / lth)
    Priority: low
    Category: TWOBIT, probably / IEEE FP std compliance

	> (+ 0.0 -0.0)
	-0.0
	> (+ -0.0 0.0)
	0.0
	> (define (x a) (+ a -0.0))
	x
	> (x 0.0)
	0.0

    This came up on comp.lang.functional.  David McClain clamed that
    (+ 0.0 -0.0) => 0.0 and my *inference* was that the IEEE std mandates
    this, in which case Twobit improperly constant-folds the first
    expression above.

    In any case the compiler and interpreter give different results for
    the first expression.

    It appears there's no way in larceny at present to distinguish -0.0
    from 0.0 without looking at the actual bits.

134 v0.45 and all earlier (990915 / lth)
    Priority: medium
    Category: RTS measurements / correctness

    The number of words copied and moved are overreported by factors of four, 
    because the stats module does not convert bytes to words when computing
    these fields.

    Not yet fixed because benchmarking is ongoing and there's no desire
    to rock the boat until we're out of that phase.

136 v0.45
    Priority: high
    Category: TWOBIT / correctness

    Interaction of toplevel BEGINs with DEFINEs.  The macro
    
    (define-syntax define-values
      (syntax-rules ()
        ((define-values (?v1 ?v2 ...) ?expr)
         (begin
           (define __super-secret-variable-name
             (call-with-values 
              (lambda () ?expr)
              (lambda values values)))
           (define-values #t (?v1 ?v2 ...) __super-secret-variable-name 0)))
        ((define-values #t () ?v ?n)
         (set! ?v #f))
        ((define-values #t (?v1 ?v2 ...) ?v ?n)
         (begin
           (define ?v1 (list-ref ?v ?n))
           (define-values #t (?v2 ...) ?v (+ ?n 1))))))
    
    run on the code
    
    (define-values (a) (values 1))
    
    expands as 
    
    ((lambda ()
       (begin
         (begin
           (set! .__super-secret-variable-name|1
             (call-with-values
               (lambda () (values '1))
               (lambda .values|1|3 .values|1|3)))
           '.__super-secret-variable-name|1)
         (begin
           (set! a
             (list-ref __super-secret-variable-name '0))
           'a)
         (set! __super-secret-variable-name '#f))))
    
    but the expansion incorrectly uses an alpha-converted name for
    __super-secret-variable-name in the definition but not in later uses.
    
NEXT ENTRY: 137

; eof
