; -*- text -*-
; ./BUGS
; $Id: BUGS,v 1.6 1997/07/07 20:28:23 lth Exp lth $


			 KNOWN BUGS IN LARCENY
			 ---------------------

Bugs are listed in the order recorded.  Fixed bugs have been moved to
the file BUGS-FIXED.  An entry consists of an entry number, the version
of Larceny in which the bug was discovered, the date it was recorded, a
description of the problem, and any supporting documentation,
information, test cases, and so on.


005  (v0.27e)

     While the system can now grow the heap to any size (by growing the
     descriptor tables), an attempt to start the system with more than 32MB
     or so of initial heap will result in a segmentation fault.

     The reason is that the size of the descriptor tables during startup
     is limited to 32 MB.  A larger size will result in an attempt to grow
     them, which results in a barrier function being called to install the
     new tables.  But at this point the barrier has not yet been initialized,
     so garbage is accessed.

011  (v0.28)

     Error reporting for vector-ref is broken:

	> (vector-ref '#(1 2 3) 4)
	Error: Exception-handler: confused about vector-ref: #(1 2 3) 2

     This is a known problem: the value '2' is not the right value;
     the generated code does not pass the right value to the fault handler.

     Fix this in the _new_ assembler only.

     Consolidated bugs: [013,015,014,016].  This is really a problem with
     the way emit-double-tagcheck-assert! and emit-single-tagcheck-assert!
     are implemented in the assembler.  Tag checking code needs to be
     revisited anyway, which is why I haven't implemented a quick fix.
     --lars

     [013] Error reporting for bytevector-like-ref is broken:

	(bytevector-like-ref "123" 4)
	Error: Exception-handler: confused about bytevector-like-ref: 123 2

     [014] Error reporting for bytevector-ref is broken:

	(bytevector-ref (make-bytevector 3) 4)
	Error: Exception-handler: confused about bytevector-ref: 
		#<BYTEVECTOR> 2

     [015] Error reporting for bytevector-set! is broken:

	(bytevector-set! (make-bytevector 3) 4 27)
	Error: bytevector-set!: 3 is not a valid index into bytevector

     [016] Error reporting for vector-set! is broken:

	(vector-set! (vector 1 2 3) 4 0)
	Error: vector-set!: 3 is not a valid index into vector


012  (v0.28)  970507

     Remembered-set size information from the command line is disregarded
     when creating the remembered sets in the garbage collector.

     See file Rts/Sys/memmgr.c

018  (v0.28)  970507

     Expt only takes exact integer powers:

	(expt 2 1.5)
	Error: expt: don't yet know how to deal with21.5

019  (v0.28)  970507

     With the generational collector, it is only possible to allocate objects
     that fit in the youngest generation, and that generation is of a
     fixed size.  This should not be a problem with the stop-and-copy (heaps=1)
     or conservative collectors.

     This should be fixed by allowing objects to be allocated "on the side"
     of the youngest generation; the current barrier system should be able
     to deal with this.

021  (v0.28b) 970528

     Free list coalescing is not done properly in unix-alloc.c.  This is 
     a benign problem with the current GC structure, but should be fixed.
     - free list should be address ordered (for coalescing, and also so
       that we can return memory to the OS).
     - a new free block can merge two previously separated blocks so that
       all three blocks become one.

022  (v0.28d) 970625

     The following functions do not accept complex arguments:
	SQRT, SIN, COS, TAN, ASIN, ACOS, ATAN, LOG, EXP

     [970701: Actually, I've implemented LOG, EXP, SIN, COS, TAN, ASIN, ACOS, 
      and ATAN; SQRT remains.  Also, these must all be tested.  --lars ]

026  (v0.28d) 970701

     LOG does not accept negative arguments.

     [970716: Actually, this has been implemented, but it remains to be
      tested.  --lars ]

031  v0.28e (970708 / lth)

     dynamic-wind must be made thread-aware: there are race conditions.

032  v0.28e (970715 / lth)

     It appears that the error continuation grows longer and longer with
     each error.

NEXT ENTRY: 033.

; eof
